{
  "hash": "23e13feca75ddc2401460f592b7bf70f",
  "result": {
    "markdown": "---\ntitle: \"循环\"\n---\n\n\n> 参考：\n>\n> [*【R语言】优雅的循环迭代：purrr包*](https://zhuanlan.zhihu.com/p/168772624)\n>\n> <https://purrr.tidyverse.org>\n\n**循环迭代，**就是将一个函数依次应用（映射）到序列的每一个元素上。用R写**循环**从低到高有三种境界：基础的显式`for`循环，到`apply()`函数家族，最后到`purrr`包`map()`函数家族泛函式编程。在R语言中应该尽量避免显式循环的应用。而`apply()`函数家族和`map()`函数家族都能够用于避免显式使用循环结构。`map()`系列函数提供了更多的一致性、规范性和便利性，更容易记住和使用。速度来说，`apply()`家族稍快，但可以忽略不计。\n\n## `apply`函数家族\n\n`lapply()`包含在R的基础包内，返回一个长度与 X（输入）相同的**列表**，其中的每个元素都是将目标函数（FUN）应用于X的相应元素的结果。其基本语法和map()一致，所以参考下面的map()函数的介绍。与之类似的`apply()`函数适合对数据框的操作，能够将目标函数应用于输入数据的行或列，然后输出一个向量或列表。\n\n生成案例数据\n\n\n::: {.cell hash='loop_cache/html/unnamed-chunk-1_21f5009c3737f42d86c4a01851704c3b'}\n\n```{.r .cell-code}\nmydata <- matrix(1:9, ncol = 3,nrow = 6) #生成一个3列、6行的矩阵数据\nmydata[3,3] <- NA #生成一个缺失值\nmydata <- as.data.frame(mydata) #如果要生成新的一列需要转换为数据框形式\nmydata\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  V1 V2 V3\n1  1  7  4\n2  2  8  5\n3  3  9 NA\n4  4  1  7\n5  5  2  8\n6  6  3  9\n```\n:::\n:::\n\n\n计算mydata数据集中每一行的均值并添加到每一行后面\n\n\n::: {.cell hash='loop_cache/html/unnamed-chunk-2_74c4539864b44382508cea1675fe1a77'}\n\n```{.r .cell-code}\nmydata$Row_Means <- apply(\n  mydata,\n  MARGIN = 1, # 1:对每行进行运算；2:对列进行运算；MARGIN=c(1,2)对行、列运算\n  mean, # 要应用的函数\n  na.rm = T # 是否忽略缺失值\n) \nmydata\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  V1 V2 V3 Row_Means\n1  1  7  4         4\n2  2  8  5         5\n3  3  9 NA         6\n4  4  1  7         4\n5  5  2  8         5\n6  6  3  9         6\n```\n:::\n:::\n\n\n求mydata数据集每一行第一列和第二列的均值\n\n\n::: {.cell hash='loop_cache/html/unnamed-chunk-3_73b13cb0e7bc797b2105cde902cae012'}\n\n```{.r .cell-code}\nmydata$Row_Means12 <- apply(mydata[, c(1:2)], MARGIN = 1, mean,na.rm = T)\nmydata\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  V1 V2 V3 Row_Means Row_Means12\n1  1  7  4         4         4.0\n2  2  8  5         5         5.0\n3  3  9 NA         6         6.0\n4  4  1  7         4         2.5\n5  5  2  8         5         3.5\n6  6  3  9         6         4.5\n```\n:::\n:::\n\n\n对mydata的每一列进行求和运算\n\n\n::: {.cell hash='loop_cache/html/unnamed-chunk-4_9dc0018e9639a6273a4cad4e17c2c841'}\n\n```{.r .cell-code}\nCol_Sums <- apply(mydata, MARGIN = 2, sum, na.rm = T)\nmydata <- rbind(mydata, Col_Sums)\nmydata\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  V1 V2 V3 Row_Means Row_Means12\n1  1  7  4         4         4.0\n2  2  8  5         5         5.0\n3  3  9 NA         6         6.0\n4  4  1  7         4         2.5\n5  5  2  8         5         3.5\n6  6  3  9         6         4.5\n7 21 30 33        30        25.5\n```\n:::\n:::\n\n\n------------------------------------------------------------------------\n\n## `purrr`包`map()`函数家族\n\n### `map()` {#sec-map_function}\n\n依次应用**一元函数**到**一个序列**的每个元素上，**基本等同 `lapply()`**：\n\n::: callout-tip\n序列包括以下的类型：\n\n-   **原子向量**（各个元素都是同类型的），包括 6 种类型：logical、integer、double、character、complex、raw，其中 integer 和 double 也统称为numeric\n\n-   **列表**（包含的元素可以是不同类型的）\n:::\n\n![](images/截屏2024-01-23%2017.18.19.png)\n\n\n::: {.cell hash='loop_cache/html/unnamed-chunk-5_8893146350f7924b971a935883167e03'}\n\n```{.r .cell-code}\nlibrary(purrr)\nchr <- list(x = c(\"a\", \"b\"), y = c(\"c\", \"d\"))\nchr\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n$x\n[1] \"a\" \"b\"\n\n$y\n[1] \"c\" \"d\"\n```\n:::\n\n```{.r .cell-code}\n# 让chr中的字符降序排列\nmap(chr, sort, decreasing = TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n$x\n[1] \"b\" \"a\"\n\n$y\n[1] \"d\" \"c\"\n```\n:::\n:::\n\n\n如过`map()`应用对象是数据框，那么会将函数应用于数据框的**每一列**（**可以把数据框的每一列看作一个元素**）:\n\n\n::: {.cell hash='loop_cache/html/unnamed-chunk-6_1f0c72da9704c7551b9a2a8dbcaa1f90'}\n\n```{.r .cell-code}\nx_df <- data.frame(a = 1:10, b = 11:20, c = 21:30)\nx_df\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n    a  b  c\n1   1 11 21\n2   2 12 22\n3   3 13 23\n4   4 14 24\n5   5 15 25\n6   6 16 26\n7   7 17 27\n8   8 18 28\n9   9 19 29\n10 10 20 30\n```\n:::\n\n```{.r .cell-code}\n# 计算x_tab每一列的均值\nmap(x_df, mean)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n$a\n[1] 5.5\n\n$b\n[1] 15.5\n\n$c\n[1] 25.5\n```\n:::\n:::\n\n\n`mean()`函数还有其它参数，如 `na.rm`，这些需要特别指定的目标函数参数可以放到函数的后面：\n\n\n::: {.cell hash='loop_cache/html/unnamed-chunk-7_57444492423d4e14419dc0a3fb7a64b7'}\n\n```{.r .cell-code}\nmap(x_df, mean, na.rm = TRUE)  # 因为数据不含NA, 故结果同上\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n$a\n[1] 5.5\n\n$b\n[1] 15.5\n\n$c\n[1] 25.5\n```\n:::\n:::\n\n\n### `map2()`\n\n依次应用**二元函数**到**两个序列**的**每对**元素上（要求两个序列有相同的长度）：\n\n![](images/截屏2024-01-23%2017.21.54.png)\n\n\n::: {.cell hash='loop_cache/html/unnamed-chunk-8_53418b17179c9fe6913a24831a37ee4a'}\n\n```{.r .cell-code}\nx <- list(a = 1:10, b = 11:20, c = 21:30)\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n$a\n [1]  1  2  3  4  5  6  7  8  9 10\n\n$b\n [1] 11 12 13 14 15 16 17 18 19 20\n\n$c\n [1] 21 22 23 24 25 26 27 28 29 30\n```\n:::\n\n```{.r .cell-code}\ny <- list(1, 2, 3)\ny\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[[1]]\n[1] 1\n\n[[2]]\n[1] 2\n\n[[3]]\n[1] 3\n```\n:::\n\n```{.r .cell-code}\nmap2(x, y,\\(x, y) x*y)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n$a\n [1]  1  2  3  4  5  6  7  8  9 10\n\n$b\n [1] 22 24 26 28 30 32 34 36 38 40\n\n$c\n [1] 63 66 69 72 75 78 81 84 87 90\n```\n:::\n:::\n\n\n`map2()`应用对象也可以是数据框和向量：\n\n\n::: {.cell hash='loop_cache/html/unnamed-chunk-9_b936755d46e3cbb3d8b6875f8b5420c5'}\n\n```{.r .cell-code}\ny_vec <- c(1:3)\ny_vec\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1 2 3\n```\n:::\n\n```{.r .cell-code}\n# 将y_vec中的每一个元素逐一与x_df中对应的列中的每个值相乘\nmap2(x_df, y_vec, \\(x, y) x*y)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n$a\n [1]  1  2  3  4  5  6  7  8  9 10\n\n$b\n [1] 22 24 26 28 30 32 34 36 38 40\n\n$c\n [1] 63 66 69 72 75 78 81 84 87 90\n```\n:::\n:::\n\n::: {.cell hash='loop_cache/html/unnamed-chunk-10_20b6525567b894f045c48a3e8fbf869c'}\n\n```{.r .cell-code}\ny_df <- data.frame(d = 21:30, e = 11:20, f = 1:10)\ny_df\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n    d  e  f\n1  21 11  1\n2  22 12  2\n3  23 13  3\n4  24 14  4\n5  25 15  5\n6  26 16  6\n7  27 17  7\n8  28 18  8\n9  29 19  9\n10 30 20 10\n```\n:::\n\n```{.r .cell-code}\n# 将y_df中的每列逐一与x_df中对应的列中的每个值相乘\nmap2(x_df, y_df, \\(x, y) x*y)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n$a\n [1]  21  44  69  96 125 156 189 224 261 300\n\n$b\n [1] 121 144 169 196 225 256 289 324 361 400\n\n$c\n [1]  21  44  69  96 125 156 189 224 261 300\n```\n:::\n\n```{.r .cell-code}\n# 输出数据框\nmap2_df(x_df, y_df, \\(x, y) x*y)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 10 × 3\n       a     b     c\n   <int> <int> <int>\n 1    21   121    21\n 2    44   144    44\n 3    69   169    69\n 4    96   196    96\n 5   125   225   125\n 6   156   256   156\n 7   189   289   189\n 8   224   324   224\n 9   261   361   261\n10   300   400   300\n```\n:::\n:::\n\n\n### `pmap()`\n\n应用**多元函数**到**多个序列**的每组元素上，可以实现对数据框逐行迭代\n\n![](images/截屏2024-01-23%2017.23.05.png)\n\n\n::: {.cell hash='loop_cache/html/unnamed-chunk-11_af255fed3b6f66b69872c0fa925e87b8'}\n\n```{.r .cell-code}\nz <- list(4, 5, 6)\npmap(\n  list(x, y, z),\n  function(first, second, third) first * (second + third)\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n$a\n [1]  5 10 15 20 25 30 35 40 45 50\n\n$b\n [1]  77  84  91  98 105 112 119 126 133 140\n\n$c\n [1] 189 198 207 216 225 234 243 252 261 270\n```\n:::\n:::\n\n\n也可以应用于数据框，实现对数据框逐行迭代：\n\n\n::: {.cell hash='loop_cache/html/unnamed-chunk-12_8c67ac58e16bf1bc6de5008e2725243a'}\n\n```{.r .cell-code}\nx_df\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n    a  b  c\n1   1 11 21\n2   2 12 22\n3   3 13 23\n4   4 14 24\n5   5 15 25\n6   6 16 26\n7   7 17 27\n8   8 18 28\n9   9 19 29\n10 10 20 30\n```\n:::\n\n```{.r .cell-code}\npmap_dbl(\n  x_df,\n  ~ ..1 * (..2 + ..3)\n) # 这里用带后缀的形式（pmap_dbl）返回数值型向量（见下文）\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1]  32  68 108 152 200 252 308 368 432 500\n```\n:::\n:::\n\n\n### 给`map`函数添加后缀\n\n`map`系列函数的运算结果默认是**列表型**的，但是`map`系列函数都有后缀形式，以决定循环迭代之后返回的数据类型，这是 `purrr` 比 `apply`函数族更先进和便利的一大优势。常用后缀如下（这里以`map()`为例，`map2()`和`pmap()`也有与之对应的后缀）：\n\n-   `map_dbl(.x, .f)`: 返回数值型向量\n\n    ![](images/截屏2024-01-23%2017.24.24.png){width=\"161\"}\n\n    【案例】在[上面的map()案例](#sec-map_function)中，求均值返回的结果是数值型，所以更好的做法是将返回结果指定为数值型向量，只需在`map`后加上`_dbl`的后缀：\n\n\n    ::: {.cell hash='loop_cache/html/unnamed-chunk-13_c4b11e4d825766a0c376301becbea299'}\n    \n    ```{.r .cell-code}\n    map_dbl(x_df, mean)\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    ```\n       a    b    c \n     5.5 15.5 25.5 \n    ```\n    :::\n    :::\n\n\n-   `map_int(.x, .f)`: 返回整数型向量\n\n    ![](images/截屏2024-01-23%2017.25.29.png){width=\"151\"}\n\n-   `map_lgl(.x, .f)`: 返回逻辑型向量\n\n    ![](images/截屏2024-01-23%2017.25.57.png){width=\"155\"}\n\n-   `map_chr(.x, .f)`: 返回字符型向量\n\n    ![](images/截屏2024-01-23%2017.23.56.png){width=\"155\"}\n\n-   `map_dfr(.x, .f)`: 返回数据框列表，再 `bind_rows` 按行合并为一个数据框\n\n    【案例】批量读取具有相同列名的数据文件并合并成一个数据框\n\n\n    ::: {.cell hash='loop_cache/html/unnamed-chunk-14_04c74d04ff91cf62055794fa55e791aa'}\n    \n    ```{.r .cell-code}\n    files = list.files(\"datas/\", pattern = \"xlsx\", full.names = TRUE)\n    df = map_dfr(files, read_xlsx)    # 批量读取+按行堆叠合并\n    ```\n    :::\n\n\n    `map_dfr(files, read_xlsx)` 依次将 `read_xlsx()` 函数应用到各个文件路径上，即依次读取数据，返回结果是数据框，同时“dfr”表示再做按行合并，一步到位。若需要设置 `read_xlsx()` 的其它参数，只需在后面设置即可。\n\n-   `map_dfc(.x, .f)`: 返回数据框列表，再 `bind_cols` 按列合并为一个数据框\n\n### **`walk()`系列**\n\n**将函数依次作用到序列上，不返回结果。**有些批量操作是没有或不关心返回结果的，例如批量保存到文件：`save()`, `write_csv()` 、`saveRDS()`等。**`walk()`系列**同样包括了`walk()`、`walk2`和`pwalk()`。\n\n![](images/截屏2024-01-24%2009.48.23.png){width=\"131\"}\n\n【例一】将mpg数据按“manufacturer”分组，每个“manufacturer”的数据分别保存为单独数据文件。\n\n\n::: {.cell hash='loop_cache/html/unnamed-chunk-15_26cfaeed1b4354334e109c68671a5062'}\n\n```{.r .cell-code}\n# 读取ggplot2包自带mpg数据集（该数据为tibble型）\ndf <- ggplot2::mpg\nhead(df)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 6 × 11\n  manufacturer model displ  year   cyl trans      drv     cty   hwy fl    class \n  <chr>        <chr> <dbl> <int> <int> <chr>      <chr> <int> <int> <chr> <chr> \n1 audi         a4      1.8  1999     4 auto(l5)   f        18    29 p     compa…\n2 audi         a4      1.8  1999     4 manual(m5) f        21    29 p     compa…\n3 audi         a4      2    2008     4 manual(m6) f        20    31 p     compa…\n4 audi         a4      2    2008     4 auto(av)   f        21    30 p     compa…\n5 audi         a4      2.8  1999     6 auto(l5)   f        16    26 p     compa…\n6 audi         a4      2.8  1999     6 manual(m5) f        18    26 p     compa…\n```\n:::\n\n```{.r .cell-code}\n# 通过group_nest将mpg数据按“manufacturer”分组，每个“manufacturer”的数据分别保存为单独数据\nlibrary(dplyr)\ndf <- group_nest(df, manufacturer) \ndf\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 15 × 2\n   manufacturer                data\n   <chr>        <list<tibble[,10]>>\n 1 audi                   [18 × 10]\n 2 chevrolet              [19 × 10]\n 3 dodge                  [37 × 10]\n 4 ford                   [25 × 10]\n 5 honda                   [9 × 10]\n 6 hyundai                [14 × 10]\n 7 jeep                    [8 × 10]\n 8 land rover              [4 × 10]\n 9 lincoln                 [3 × 10]\n10 mercury                 [4 × 10]\n11 nissan                 [13 × 10]\n12 pontiac                 [5 × 10]\n13 subaru                 [14 × 10]\n14 toyota                 [34 × 10]\n15 volkswagen             [27 × 10]\n```\n:::\n\n```{.r .cell-code}\n# 批量输出这些数据\npwalk(df, ~ write.csv(..2, paste0(\"output/r_basic/\", ..1, \".csv\")))\n```\n:::\n\n\n![](images/截屏2024-01-24%2010.01.53.png){width=\"179\"}\n\n【例二】这个例子来自[读取非标准10X格式文件](/single_cell/sc_supplementary/read_sc_data.qmd)，要实现在\"output/r_basic/GSE184880_RAW\"中批量建立文件夹的目的。\n\n首先是构建文件夹的目录和名字，这一部分的目的参照[读取非标准10X格式文件](/single_cell/sc_supplementary/read_sc_data.qmd#Read_non-standard_10x_files)。\n\n\n::: {.cell hash='loop_cache/html/unnamed-chunk-16_ce7d392c3da6bde9935b64b292647217'}\n\n```{.r .cell-code}\n# 列出\nfiles <- list.files(\"data/sc_supplementary/GSE184880_RAW\")\nfiles[1:10]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] \"GSM5599220_Norm1\"                 \"GSM5599220_Norm1.barcodes.tsv.gz\"\n [3] \"GSM5599220_Norm1.genes.tsv.gz\"    \"GSM5599220_Norm1.matrix.mtx.gz\"  \n [5] \"GSM5599221_Norm2\"                 \"GSM5599221_Norm2.barcodes.tsv.gz\"\n [7] \"GSM5599221_Norm2.genes.tsv.gz\"    \"GSM5599221_Norm2.matrix.mtx.gz\"  \n [9] \"GSM5599222_Norm3\"                 \"GSM5599222_Norm3.barcodes.tsv.gz\"\n```\n:::\n\n```{.r .cell-code}\ndirnames <- gsub(pattern = \".barcodes.tsv.gz|.genes.tsv.gz|.matrix.mtx.gz\", \n                 replacement = \"\", \n                 x = files) %>%  \n  unique() %>% \n  paste0(\"output/r_basic/GSE184880_RAW/\", .) \ndirnames\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] \"output/r_basic/GSE184880_RAW/GSM5599220_Norm1\"  \n [2] \"output/r_basic/GSE184880_RAW/GSM5599221_Norm2\"  \n [3] \"output/r_basic/GSE184880_RAW/GSM5599222_Norm3\"  \n [4] \"output/r_basic/GSE184880_RAW/GSM5599223_Norm4\"  \n [5] \"output/r_basic/GSE184880_RAW/GSM5599224_Norm5\"  \n [6] \"output/r_basic/GSE184880_RAW/GSM5599225_Cancer1\"\n [7] \"output/r_basic/GSE184880_RAW/GSM5599226_Cancer2\"\n [8] \"output/r_basic/GSE184880_RAW/GSM5599227_Cancer3\"\n [9] \"output/r_basic/GSE184880_RAW/GSM5599228_Cancer4\"\n[10] \"output/r_basic/GSE184880_RAW/GSM5599229_Cancer5\"\n[11] \"output/r_basic/GSE184880_RAW/GSM5599230_Cancer6\"\n[12] \"output/r_basic/GSE184880_RAW/GSM5599231_Cancer7\"\n```\n:::\n\n```{.r .cell-code}\n# 在“output/r_basic”目标位置先建立一个“GSE184880_RAW”用于存放一会儿构建的文件夹\ndir.create(\"output/r_basic/GSE184880_RAW\")\n```\n:::\n\n\n通过`pwalk()`根据文件夹的名称“dirnames”建立文件夹。⚠️注意`pwalk()`只能应用于列表对象，所以这里通过`list()`进行了转化：\n\n\n::: {.cell hash='loop_cache/html/unnamed-chunk-17_54c3ad0d73d865f5d8d635dc4321f22f'}\n\n```{.r .cell-code}\npwalk(list(dirnames), dir.create)\n```\n:::\n\n\n![建立好的文件夹](images/截屏2024-01-24%2010.40.53.png){width=\"423\"}\n\n::: callout-tip\n更多关于`purr`包的应用，参考：[*【R语言】优雅的循环迭代：purrr包*](https://zhuanlan.zhihu.com/p/168772624)*、*<https://purrr.tidyverse.org>。\n:::\n\n::: {.callout-tip collapse=\"true\"}\n###### `apply`家族 vs. `map`家族函数\n\nThere are two primary differences between the base `apply` family and the purrr `map` family: `purrr` functions are **named more consistently**, and more fully explore the space of input and output variants.\n\n-   `purrr` functions consistently use `.` as prefix to avoid [inadvertently matching arguments](https://adv-r.hadley.nz/functionals.html#argument-names) of the `purrr` function, instead of the function that you’re trying to call. Base functions use a variety of techniques including upper case (e.g. `lapply(X, FUN, ...)`) or require anonymous functions (e.g. `Map()`).\n\n-   All `map` functions are type stable: you can predict the type of the output using little information about the inputs. In contrast, the base functions `sapply()` and `mapply()` automatically simplify making the return value hard to predict.\n\n-   **The map functions all start with the data, followed by the function**, **then any additional constant argument**. Most base apply functions also follow this pattern, but `mapply()` starts with the function, and `Map()` has no way to supply additional constant arguments.\n\n-   purrr functions provide all combinations of input and output variants, and include variants specifically for the common two argument case.\n\n**`apply`家族和`map`家族函数对照表：**\n\n+-------------------------------+---------------------------------------+----------------------------------------------------------------------------+---------------------------------------------------------------------------------------------------+\n| Output                        | Input                                 | Base R                                                                     | purrr                                                                                             |\n+===============================+=======================================+============================================================================+===================================================================================================+\n| List                          | 1 vector                              | `lapply()`                                                                 | `map()`                                                                                           |\n+-------------------------------+---------------------------------------+----------------------------------------------------------------------------+---------------------------------------------------------------------------------------------------+\n| List                          | 2 vectors                             | `mapply()`, `Map()`                                                        | `map2()`                                                                                          |\n+-------------------------------+---------------------------------------+----------------------------------------------------------------------------+---------------------------------------------------------------------------------------------------+\n| List                          | \\>2 vectors                           | `mapply()`, `Map()`                                                        | `pmap()`                                                                                          |\n+-------------------------------+---------------------------------------+----------------------------------------------------------------------------+---------------------------------------------------------------------------------------------------+\n| Atomic vector of desired type | 1 vector                              | `vapply()`                                                                 | `map_lgl()` (logical)                                                                             |\n|                               |                                       |                                                                            |                                                                                                   |\n|                               |                                       |                                                                            | `map_int()` (integer)                                                                             |\n|                               |                                       |                                                                            |                                                                                                   |\n|                               |                                       |                                                                            | `map_dbl()` (double)                                                                              |\n|                               |                                       |                                                                            |                                                                                                   |\n|                               |                                       |                                                                            | `map_chr()` (character)                                                                           |\n|                               |                                       |                                                                            |                                                                                                   |\n|                               |                                       |                                                                            | `map_raw()` (raw)                                                                                 |\n+-------------------------------+---------------------------------------+----------------------------------------------------------------------------+---------------------------------------------------------------------------------------------------+\n| Atomic vector of desired type | 2 vectors                             | `mapply()`, `Map()`, then `is.*()` to check type                           | `map2_lgl()` (logical)                                                                            |\n|                               |                                       |                                                                            |                                                                                                   |\n|                               |                                       |                                                                            | `map2_int()` (integer)                                                                            |\n|                               |                                       |                                                                            |                                                                                                   |\n|                               |                                       |                                                                            | `map2_dbl()` (double)                                                                             |\n|                               |                                       |                                                                            |                                                                                                   |\n|                               |                                       |                                                                            | `map2_chr()` (character)                                                                          |\n|                               |                                       |                                                                            |                                                                                                   |\n|                               |                                       |                                                                            | `map2_raw()` (raw)                                                                                |\n+-------------------------------+---------------------------------------+----------------------------------------------------------------------------+---------------------------------------------------------------------------------------------------+\n| Atomic vector of desired type | \\>2 vectors                           | `mapply()`, `Map()`, then `is.*()` to check type                           | `map2_lgl()` (logical)                                                                            |\n|                               |                                       |                                                                            |                                                                                                   |\n|                               |                                       |                                                                            | `map2_int()` (integer)                                                                            |\n|                               |                                       |                                                                            |                                                                                                   |\n|                               |                                       |                                                                            | `map2_dbl()` (double)                                                                             |\n|                               |                                       |                                                                            |                                                                                                   |\n|                               |                                       |                                                                            | `map2_chr()` (character)                                                                          |\n|                               |                                       |                                                                            |                                                                                                   |\n|                               |                                       |                                                                            | `map2_raw()` (raw)                                                                                |\n+-------------------------------+---------------------------------------+----------------------------------------------------------------------------+---------------------------------------------------------------------------------------------------+\n| Side effect only              | 1 vector                              | loops                                                                      | `walk()`                                                                                          |\n+-------------------------------+---------------------------------------+----------------------------------------------------------------------------+---------------------------------------------------------------------------------------------------+\n| Side effect only              | 2 vectors                             | loops                                                                      | `walk2()`                                                                                         |\n+-------------------------------+---------------------------------------+----------------------------------------------------------------------------+---------------------------------------------------------------------------------------------------+\n| Side effect only              | \\>2 vectors                           | loops                                                                      | `pwalk()`                                                                                         |\n+-------------------------------+---------------------------------------+----------------------------------------------------------------------------+---------------------------------------------------------------------------------------------------+\n| Data frame (`rbind`outputs)   | 1 vector                              | `lapply()` then `rbind()`                                                  | `map_dfr()`                                                                                       |\n+-------------------------------+---------------------------------------+----------------------------------------------------------------------------+---------------------------------------------------------------------------------------------------+\n| Data frame (`rbind`outputs)   | 2 vectors                             | `mapply()`/`Map()` then`rbind()`                                           | `map2_dfr()`                                                                                      |\n+-------------------------------+---------------------------------------+----------------------------------------------------------------------------+---------------------------------------------------------------------------------------------------+\n| Data frame (`rbind`outputs)   | \\>2 vectors                           | `mapply()`/`Map()` then`rbind()`                                           | `pmap_dfr()`                                                                                      |\n+-------------------------------+---------------------------------------+----------------------------------------------------------------------------+---------------------------------------------------------------------------------------------------+\n| Data frame (`cbind`outputs)   | 1 vector                              | `lapply()` then `cbind()`                                                  | `map_dfc()`                                                                                       |\n+-------------------------------+---------------------------------------+----------------------------------------------------------------------------+---------------------------------------------------------------------------------------------------+\n| Data frame (`cbind`outputs)   | 2 vectors                             | `mapply()`/`Map()` then`cbind()`                                           | `map2_dfc()`                                                                                      |\n+-------------------------------+---------------------------------------+----------------------------------------------------------------------------+---------------------------------------------------------------------------------------------------+\n| Data frame (`cbind`outputs)   | \\>2 vectors                           | `mapply()`/`Map()` then`cbind()`                                           | `pmap_dfc()`                                                                                      |\n+-------------------------------+---------------------------------------+----------------------------------------------------------------------------+---------------------------------------------------------------------------------------------------+\n| Any                           | Vector and its names                  | `l/s/vapply(X, function(x) f(x, names(x)))` or`mapply/Map(f, x, names(x))` | `imap()`, `imap_*()` (`lgl`, `dbl`, `dfr`, and etc. just like for`map()`, `map2()`, and `pmap()`) |\n+-------------------------------+---------------------------------------+----------------------------------------------------------------------------+---------------------------------------------------------------------------------------------------+\n| Any                           | Selected elements of the vector       | `l/s/vapply(X[index], FUN, ...)`                                           | `map_if()`, `map_at()`                                                                            |\n+-------------------------------+---------------------------------------+----------------------------------------------------------------------------+---------------------------------------------------------------------------------------------------+\n| List                          | Recursively apply to list within list | `rapply()`                                                                 | `map_depth()`                                                                                     |\n+-------------------------------+---------------------------------------+----------------------------------------------------------------------------+---------------------------------------------------------------------------------------------------+\n| List                          | List only                             | `lapply()`                                                                 | `lmap()`, `lmap_at()`,`lmap_if()`                                                                 |\n+-------------------------------+---------------------------------------+----------------------------------------------------------------------------+---------------------------------------------------------------------------------------------------+\n\nSince a common use case for map functions is list extracting components, purrr provides a handful of shortcut functions for various uses of `[[`.\n\n+----------------------------+-------------------------------------------------------------------+----------------------------+\n| Input                      | base R                                                            | purrr                      |\n+============================+===================================================================+============================+\n| Extract by name            | `` lapply(x, `[[`, \"a\") ``                                        | `map(x, \"a\")`              |\n+----------------------------+-------------------------------------------------------------------+----------------------------+\n| Extract by position        | `` lapply(x, `[[`, 3) ``                                          | `map(x, 3)`                |\n+----------------------------+-------------------------------------------------------------------+----------------------------+\n| Extract deeply             | `lapply(x, \\(y) y[[1]][[\"x\"]][[3]])`                              | `map(x, list(1, \"x\", 3))`  |\n+----------------------------+-------------------------------------------------------------------+----------------------------+\n| Extract with default value | `lapply(x, function(y) tryCatch(y[[3]], error = function(e) NA))` | `map(x, 3, .default = NA)` |\n+----------------------------+-------------------------------------------------------------------+----------------------------+\n:::\n\n------------------------------------------------------------------------\n\n## 在循环语句中的其他常用函数\n\n### `assign()`函数\n\n`assign`函数能够将某个值赋值给指定名称，从而实现循环中将每次运行的结果保存到一个对象中，而不覆盖上一次运行的结果。\n\n-   `x`：变量名称/赋值对象/最后的新变量的名称\n\n-   `value`：需要赋给`x`的值\n\n下面的案例实现输出\"A\", \"B\", \"C\", \"D\"四个变量，每个变量就是一次循环的结果：\n\n\n::: {.cell hash='loop_cache/html/unnamed-chunk-18_eb8d3590f35185d99e9d51a0588eb351'}\n\n```{.r .cell-code}\nfor (x in c(\"A\", \"B\", \"C\", \"D\")){\n        y <- paste0(x, x)\n        assign(x = x, value = y)\n}\n```\n:::\n\n\n### `append`函数\n\n`append()`函数被广泛应用于将新的向量添加到现有的向量、列表或数据框中。\n\n-   将新向量添加到已有向量中：\n\n\n::: {.cell hash='loop_cache/html/unnamed-chunk-19_0dda0b58f500ac4b4b2689d659076769'}\n\n```{.r .cell-code}\nv1 <- c(1, 2, 3, 4, 5)\nv2 <- c(6, 7, 8)\n\nv3 <- append(v1, v2)\nv3\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1 2 3 4 5 6 7 8\n```\n:::\n\n```{.r .cell-code}\n#等价于\nv3 <- c(v1, v2)\n```\n:::\n\n\n-   将新列表添加到已有列表中：\n\n\n::: {.cell hash='loop_cache/html/unnamed-chunk-20_d56b85de6c7c452818f972eb03f45a51'}\n\n```{.r .cell-code}\nlist1 <- list(a = 1, b = 2, c = 3)\nlist2 <- list(d = 4, e = 5, f = 6)\nlist3 <- append(list1, list2)\nlist3\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n$a\n[1] 1\n\n$b\n[1] 2\n\n$c\n[1] 3\n\n$d\n[1] 4\n\n$e\n[1] 5\n\n$f\n[1] 6\n```\n:::\n:::\n\n\n实际应用场景：在批量读取构建Seurat对象时，通过append()函数将每次的Seurat对象添加到列表中，最终得到一个包含了所有样本的单细胞数据的列表：\n\n\n::: {.cell hash='loop_cache/html/unnamed-chunk-21_20fbce753fd7204359af5b5fe89a4bb9'}\n\n```{.r .cell-code}\nfor (file in file_list) {\n  # 拼接文件路径\n  data.path <- paste0(\"data/other_single_cell_content/GSE234933_MGH_HNSCC_gex_raw_counts/\", file)\n  # 读取RDS文件数据\n  seurat_data <- readRDS(data.path)\n  # 创建Seurat对象，并指定项目名称为文件名（去除后缀）\n  sample_name <- file_path_sans_ext(file)\n  seurat_obj <- CreateSeuratObject(counts = seurat_data,\n                                   project = sample_name,\n                                   min.features = 200,\n                                   min.cells = 3)\n  # 将Seurat对象添加到列表中\n  seurat_list <- append(seurat_list, seurat_obj)\n}\n```\n:::\n\n\n------------------------------------------------------------------------\n\n::: {.callout-note collapse=\"true\" icon=\"false\"}\n## Session Info\n\n\n::: {.cell hash='loop_cache/html/unnamed-chunk-22_70498f1d66691255bb6229c935437c4d'}\n::: {.cell-output .cell-output-stdout}\n```\nR version 4.3.2 (2023-10-31)\nPlatform: aarch64-apple-darwin20 (64-bit)\nRunning under: macOS Sonoma 14.3\n\nMatrix products: default\nBLAS:   /Library/Frameworks/R.framework/Versions/4.3-arm64/Resources/lib/libRblas.0.dylib \nLAPACK: /Library/Frameworks/R.framework/Versions/4.3-arm64/Resources/lib/libRlapack.dylib;  LAPACK version 3.11.0\n\nlocale:\n[1] en_US.UTF-8/en_US.UTF-8/en_US.UTF-8/C/en_US.UTF-8/en_US.UTF-8\n\ntime zone: Asia/Shanghai\ntzcode source: internal\n\nattached base packages:\n[1] stats     graphics  grDevices utils     datasets  methods   base     \n\nother attached packages:\n[1] dplyr_1.1.4 purrr_1.0.2\n\nloaded via a namespace (and not attached):\n [1] vctrs_0.6.5       cli_3.6.2         knitr_1.45        rlang_1.1.3      \n [5] xfun_0.41         generics_0.1.3    jsonlite_1.8.8    glue_1.7.0       \n [9] colorspace_2.1-0  htmltools_0.5.7   scales_1.3.0      fansi_1.0.6      \n[13] rmarkdown_2.25    grid_4.3.2        munsell_0.5.0     evaluate_0.23    \n[17] tibble_3.2.1      fastmap_1.1.1     yaml_2.3.8        lifecycle_1.0.4  \n[21] compiler_4.3.2    codetools_0.2-19  htmlwidgets_1.6.4 pkgconfig_2.0.3  \n[25] rstudioapi_0.15.0 digest_0.6.34     R6_2.5.1          tidyselect_1.2.0 \n[29] utf8_1.2.4        pillar_1.9.0      magrittr_2.0.3    gtable_0.3.4     \n[33] tools_4.3.2       ggplot2_3.4.4    \n```\n:::\n:::\n\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}