{
  "hash": "5d0b81a1983421e1da16dc21bfb249e8",
  "result": {
    "markdown": "---\ntitle: \"字符的处理\"\n---\n\n\n## 字符串的截取\n\n\n::: {.cell hash='character_cache/html/unnamed-chunk-1_45229fa138db46bc80aa9853d72327b4'}\n\n```{.r .cell-code}\nsubstr(\" A BC\",\n       1,#从第几个字符开始截取\n       3)#截取多少个字符\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \" A \"\n```\n:::\n\n```{.r .cell-code}\nsubstring(\" A BC\", 1, 3)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \" A \"\n```\n:::\n:::\n\n\n`substr()`对含有空格和特殊字符如下划线的支持不好，这种情况可采用`stringr`包内的字符分割函数`str_split()`来实现。下面实现从\"A_B_C\"中截取\"B\"：\n\n\n::: {.cell hash='character_cache/html/unnamed-chunk-2_88031325d4e835ae1ed594b03dd3bc2d'}\n\n```{.r .cell-code}\nlibrary(stringr)\nstr_split(\"A_B_C\",\n          \"_\",#按照什么标志切割字符\n          simplify = T)[,2] #这里把\"A_B_C\"切开后，“B\"应该位于第二个，所以通过[,2]取第二个元素\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"B\"\n```\n:::\n\n```{.r .cell-code}\nstr_sub(\"A_B_C\",\n        1,\n        2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"A_\"\n```\n:::\n:::\n\n\n## 字符串的替换（`gsub`函数）\n\n\n::: {.cell hash='character_cache/html/unnamed-chunk-3_45251d0783a23b9637ea2dbef9aeb73c'}\n\n```{.r .cell-code}\ngsub(\"B\",#需要替换的原字符\n     \"F\",#替换成什么\n     'A_B_C_b', #替换目标\n     ignore.case=F) #是否忽略大小写。默认为FALSE\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"A_F_C_b\"\n```\n:::\n\n```{.r .cell-code}\n#删掉某些字符\ngsub(\"B\",\"\",'A_B_C')\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"A__C\"\n```\n:::\n:::\n\n::: {.cell hash='character_cache/html/unnamed-chunk-4_cd8d519f5295708f5cf2cb7471ad4d83'}\n\n```{.r .cell-code}\n#使用正则表达式进行高级替换\n#多个相同字符，只替换开头的字符，在目标字符左侧加“^”\ngsub(\"^B\",\"A\",'B_B_B')\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"A_B_B\"\n```\n:::\n\n```{.r .cell-code}\n#多个相同字符，只替换结尾字符，在目标字符右侧加“$”\ngsub(\"B$\",\"A\",'B_B_B')\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"B_B_A\"\n```\n:::\n\n```{.r .cell-code}\n#把目标字符及目标字符后面的一个字符替换掉\ngsub('D.','X',\"ABCDEFG\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"ABCXFG\"\n```\n:::\n\n```{.r .cell-code}\n#把目标字符及目标字符后面的2个字符替换掉\ngsub('D..','X',\"ABCDEFG\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"ABCXG\"\n```\n:::\n\n```{.r .cell-code}\n#把D及D后面的字符全部替换掉\ngsub('D.*','X',\"ABCDEFG\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"ABCX\"\n```\n:::\n\n```{.r .cell-code}\n#替换空格，使用“\\\\s”\ngsub(\"\\\\s\",\"_\",\"A B C\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"A_B_C\"\n```\n:::\n\n```{.r .cell-code}\n#替换不同字符，使用“|”\ngsub('B|D|G','X',\"ABCDEFG\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"AXCXEFX\"\n```\n:::\n\n```{.r .cell-code}\n#模糊匹配替换\ngsub('[0-9]','X',\"1A2B3C4D5\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"XAXBXCXDX\"\n```\n:::\n\n```{.r .cell-code}\ngsub('[A-Z]','X',\"1A2B3C4D5\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"1X2X3X4X5\"\n```\n:::\n:::\n\n::: {.cell hash='character_cache/html/unnamed-chunk-5_2d158394edc98fe66da7b32c75ab4ad9'}\n\n```{.r .cell-code}\n#大小写转换\ntoupper(\"abc\") #转换成大写\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"ABC\"\n```\n:::\n\n```{.r .cell-code}\ntolower(\"ABC\") #转换成小写\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"abc\"\n```\n:::\n:::\n\n\n## 字符的连接\n\n\n::: {.cell hash='character_cache/html/unnamed-chunk-6_4411f2be37a5d7cb8006d36c783a0c8a'}\n\n```{.r .cell-code}\npaste(\"hello\", \"world\", \"!\", sep = \" \")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"hello world !\"\n```\n:::\n\n```{.r .cell-code}\npaste(\"x\",1:3,sep=\"M\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"xM1\" \"xM2\" \"xM3\"\n```\n:::\n:::\n\n\n### `unite()`函数的使用\n\n构建案例数据\n\n\n::: {.cell hash='character_cache/html/unnamed-chunk-7_c4fdcd66ab00b01caa94cc74409bdf94'}\n\n```{.r .cell-code}\na1 <- rep(1,5) # 重复“1” 5次\na2 <- rep(2,5)\na3 <- rep(3,5)\nA <- data.frame(a1,a2,a3)\nA\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  a1 a2 a3\n1  1  2  3\n2  1  2  3\n3  1  2  3\n4  1  2  3\n5  1  2  3\n```\n:::\n:::\n\n\n现在想对生成的数据框A里面的a1,a2和a3列进行合并，形成新\"a123\"列，其中a1与a2用\"\\~\"连接，a2与a3列用\"/\"连接。\n\n首先对数据A的列a1,a2合并为新列a12，用\"\\~\"连接。\n\n\n::: {.cell hash='character_cache/html/unnamed-chunk-8_65796a6c81d295573248befefb529b5a'}\n\n```{.r .cell-code}\nlibrary(tidyr)\nA1 <- unite(A,#目标数据集\n            \"a12\",#新列的名称\n            a1,a2,#需要合并的列名(若用“:”连接则表示合并两列及之间的所有列)\n            sep = '~',#指定连接符\n            remove=F)#是否移除原始列\n\n#或者\nA1 <- A %>% unite(\"a12\",a1,a2,sep = '~',remove=F)\nA1\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  a12 a1 a2 a3\n1 1~2  1  2  3\n2 1~2  1  2  3\n3 1~2  1  2  3\n4 1~2  1  2  3\n5 1~2  1  2  3\n```\n:::\n:::\n\n\n然后对A1里面的a12列与a3列用\"/\"连接，形成新列\"a123\"\n\n\n::: {.cell hash='character_cache/html/unnamed-chunk-9_208374a902174dd246b656c7de2ff96a'}\n\n```{.r .cell-code}\nA2 <- unite(A1,\"a123\",a12,a3,sep = '/',remove=F)\nA2\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   a123 a12 a1 a2 a3\n1 1~2/3 1~2  1  2  3\n2 1~2/3 1~2  1  2  3\n3 1~2/3 1~2  1  2  3\n4 1~2/3 1~2  1  2  3\n5 1~2/3 1~2  1  2  3\n```\n:::\n\n```{.r .cell-code}\n#也可以用管道传参一步搞定\nA2 <- A %>% \n  unite(a12,a1,a2,sep = '~',remove=F) %>% \n  unite(a123,a12,a3,sep = '/',remove=F)\nA2\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   a123 a12 a1 a2 a3\n1 1~2/3 1~2  1  2  3\n2 1~2/3 1~2  1  2  3\n3 1~2/3 1~2  1  2  3\n4 1~2/3 1~2  1  2  3\n5 1~2/3 1~2  1  2  3\n```\n:::\n:::\n\n\n## 字符查找\n\n### **%in%指令**\n\n它会把每个字符串当成判断的最小单位，所以不能用来判断/查找\"长字符串中是否含有特定的短字符串\"\n\n\n::: {.cell hash='character_cache/html/unnamed-chunk-10_2065c8910bc6dea276efc05e2fd057ed'}\n\n```{.r .cell-code}\nplaces <- c(\"中国四川\",\"中国北京\",\"中国安徽\",\"北京天安门\")\nplaces\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"中国四川\"   \"中国北京\"   \"中国安徽\"   \"北京天安门\"\n```\n:::\n\n```{.r .cell-code}\n\"中国四川\" %in% places\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n\n```{.r .cell-code}\n\"中国\" %in% places\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] FALSE\n```\n:::\n:::\n\n\n### **`grep()`函数**\n\ngrep的全称是global search regular expression and print out the line,可以通过正则表达式搜索文本，并把匹配的行打印出来。所谓正则表达式，就是用某种模式去匹配一类字符串的一个公式，很多文本编辑器或者程序语言都支持该方式进行字符串的操作。下面我们用该函数首先查找y中是否有包含\"北京\"字样的条目，并返回其所在位置：\n\n\n::: {.cell hash='character_cache/html/unnamed-chunk-11_870f0494a5991ba544eda45b77ea7404'}\n\n```{.r .cell-code}\ngrep(\n  pattern = \"北京\", # 需要找找的字符\n  x = places, # 从哪里查找\n  ignore.case = F, # 是否忽略大小写，默认为FALSE\n  value = F, # 默认为FALSE，表示返回匹配到的字符所在的位置；TRUE则返回查找到的值\n  invert = F # 如果为TRUE，则返回未匹配到的字符的值或位置\n) \n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 2 4\n```\n:::\n:::\n\n\n查找y中包含\"北京\"的条目有哪些：\n\n\n::: {.cell hash='character_cache/html/unnamed-chunk-12_c6e5d11d7b5e5ffcd7223cc060ef0b29'}\n\n```{.r .cell-code}\ngrep(\"北京\", places, ignore.case = F, value = T, invert = F)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"中国北京\"   \"北京天安门\"\n```\n:::\n:::\n\n\n从framdata数据集中，提取NAME包含了\"TR\"的个案，形成新的TR_data数据集。\n\n生成演示数据\n\n\n::: {.cell hash='character_cache/html/unnamed-chunk-13_768d361ce18dd21a9b7b86f44137fad0'}\n\n```{.r .cell-code}\nframdata <- data.frame(ID = c(6, 8, 12, 14, 14, 15, 17, 22, 24, 23),\n                       NAME = c(\"A_CT\", \"B_CT\", \"C_CT\", \"D_CT\", \"E_TR\", \"F_TR\",\n                                \"G_TR\", \"H_TR\", \"I_TR\", \"J_TR\"),\n                       VALUE = c(14, 12, 12, 13, 7, 8, 7, 4, 6, 5))\nframdata\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   ID NAME VALUE\n1   6 A_CT    14\n2   8 B_CT    12\n3  12 C_CT    12\n4  14 D_CT    13\n5  14 E_TR     7\n6  15 F_TR     8\n7  17 G_TR     7\n8  22 H_TR     4\n9  24 I_TR     6\n10 23 J_TR     5\n```\n:::\n:::\n\n\n利用该函数返回framdata中NAME列中包含了\"TR\"的行号\n\n\n::: {.cell hash='character_cache/html/unnamed-chunk-14_a1496f7589b31c806a36819e9929a7d8'}\n\n```{.r .cell-code}\ngrep(\"TR\", framdata$NAME, ignore.case = F, value = F, invert = F)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1]  5  6  7  8  9 10\n```\n:::\n:::\n\n\n下面最终实现上述目的\n\n\n::: {.cell hash='character_cache/html/unnamed-chunk-15_77f9766242773776d156a3011e07feb8'}\n\n```{.r .cell-code}\nTR_data <- framdata[grep(\"TR\", framdata$NAME),]\nTR_data\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   ID NAME VALUE\n5  14 E_TR     7\n6  15 F_TR     8\n7  17 G_TR     7\n8  22 H_TR     4\n9  24 I_TR     6\n10 23 J_TR     5\n```\n:::\n:::\n\n\n### **`grepl()`函数**\n\n`grep()`和`grepl()`这两个函数最大的区别在于`grep()`返回找到的位置，`grepl`返回【是否】包含查找内容的逻辑向量。\n\n\n::: {.cell hash='character_cache/html/unnamed-chunk-16_89f3c643a077dce309bf437d8916d177'}\n\n```{.r .cell-code}\ngrepl(\"北京\", places)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] FALSE  TRUE FALSE  TRUE\n```\n:::\n\n```{.r .cell-code}\nany(grepl(\"北京\", places))#只要places中有包含了“北京”的项目就返回一个\"TRUE\"\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n:::\n\n\n### **`startsWith()`和`endsWith()`**\n\n用于查找开头或结尾的字符\n\n\n::: {.cell hash='character_cache/html/unnamed-chunk-17_e1224de04e4ae1d74f6d1e908851bb1c'}\n\n```{.r .cell-code}\n# 从“places”中查找以“中国”开头的对象\nstartsWith(\n  x = places, # 从哪里查找\n  prefix = \"中国\" # 查找内容\n  )\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1]  TRUE  TRUE  TRUE FALSE\n```\n:::\n\n```{.r .cell-code}\n# 用grepl()的方式：\ngrepl(pattern = \"^中国\", places)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1]  TRUE  TRUE  TRUE FALSE\n```\n:::\n\n```{.r .cell-code}\n# 从“places”中查找以“北京”结尾的对象\nendsWith(x = places, \"北京\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] FALSE  TRUE FALSE FALSE\n```\n:::\n\n```{.r .cell-code}\n# 用grepl()的方式：\ngrepl(pattern = \"北京$\", places)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] FALSE  TRUE FALSE FALSE\n```\n:::\n:::\n\n\n------------------------------------------------------------------------\n\n::: {.callout-note collapse=\"true\" icon=\"false\"}\n## Session Info\n\n\n::: {.cell hash='character_cache/html/unnamed-chunk-18_0df636e1c9ec3784cc7681d814be7e85'}\n::: {.cell-output .cell-output-stdout}\n```\nR version 4.3.2 (2023-10-31)\nPlatform: aarch64-apple-darwin20 (64-bit)\nRunning under: macOS Sonoma 14.3\n\nMatrix products: default\nBLAS:   /Library/Frameworks/R.framework/Versions/4.3-arm64/Resources/lib/libRblas.0.dylib \nLAPACK: /Library/Frameworks/R.framework/Versions/4.3-arm64/Resources/lib/libRlapack.dylib;  LAPACK version 3.11.0\n\nlocale:\n[1] en_US.UTF-8/en_US.UTF-8/en_US.UTF-8/C/en_US.UTF-8/en_US.UTF-8\n\ntime zone: Asia/Shanghai\ntzcode source: internal\n\nattached base packages:\n[1] stats     graphics  grDevices utils     datasets  methods   base     \n\nother attached packages:\n[1] tidyr_1.3.0   stringr_1.5.1\n\nloaded via a namespace (and not attached):\n [1] vctrs_0.6.5       cli_3.6.2         knitr_1.45        rlang_1.1.3      \n [5] xfun_0.41         stringi_1.8.3     purrr_1.0.2       generics_0.1.3   \n [9] jsonlite_1.8.8    glue_1.7.0        htmltools_0.5.7   fansi_1.0.6      \n[13] rmarkdown_2.25    tibble_3.2.1      evaluate_0.23     fastmap_1.1.1    \n[17] yaml_2.3.8        lifecycle_1.0.4   compiler_4.3.2    dplyr_1.1.4      \n[21] codetools_0.2-19  pkgconfig_2.0.3   htmlwidgets_1.6.4 rstudioapi_0.15.0\n[25] digest_0.6.34     R6_2.5.1          tidyselect_1.2.0  utf8_1.2.4       \n[29] pillar_1.9.0      magrittr_2.0.3    withr_3.0.0       tools_4.3.2      \n```\n:::\n:::\n\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}