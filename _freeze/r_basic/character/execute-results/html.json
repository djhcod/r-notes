{
  "hash": "c9b16e6d35a522a7717f1f3dc908eacb",
  "result": {
    "markdown": "# 字符的处理\n\n## 字符串的截取\n\n\n::: {.cell hash='character_cache/html/unnamed-chunk-1_45229fa138db46bc80aa9853d72327b4'}\n\n```{.r .cell-code}\nsubstr(\" A BC\",\n       1,#从第几个字符开始截取\n       3)#截取多少个字符\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \" A \"\n```\n:::\n\n```{.r .cell-code}\nsubstring(\" A BC\", 1, 3)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \" A \"\n```\n:::\n:::\n\n\n`substr()`对含有空格和特殊字符如下划线的支持不好，这种情况可采用stringr包内的字符分割函数str_split()来实现。下面实现从\"A_B_C\"中截取\"B\"：\n\n\n::: {.cell hash='character_cache/html/unnamed-chunk-2_88031325d4e835ae1ed594b03dd3bc2d'}\n\n```{.r .cell-code}\nlibrary(stringr)\nstr_split(\"A_B_C\",\n          \"_\",#按照什么标志切割字符\n          simplify = T)[,2] #这里把\"A_B_C\"切开后，“B\"应该位于第二个，所以通过[,2]取第二个元素\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"B\"\n```\n:::\n\n```{.r .cell-code}\nstr_sub(\"A_B_C\",\n        1,\n        2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"A_\"\n```\n:::\n:::\n\n\n## 字符串的替换（gsub函数）\n\n\n::: {.cell hash='character_cache/html/unnamed-chunk-3_45251d0783a23b9637ea2dbef9aeb73c'}\n\n```{.r .cell-code}\ngsub(\"B\",#需要替换的原字符\n     \"F\",#替换成什么\n     'A_B_C_b', #替换目标\n     ignore.case=F) #是否忽略大小写。默认为FALSE\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"A_F_C_b\"\n```\n:::\n\n```{.r .cell-code}\n#删掉某些字符\ngsub(\"B\",\"\",'A_B_C')\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"A__C\"\n```\n:::\n:::\n\n::: {.cell hash='character_cache/html/unnamed-chunk-4_cd8d519f5295708f5cf2cb7471ad4d83'}\n\n```{.r .cell-code}\n#使用正则表达式进行高级替换\n#多个相同字符，只替换开头的字符，在目标字符左侧加“^”\ngsub(\"^B\",\"A\",'B_B_B')\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"A_B_B\"\n```\n:::\n\n```{.r .cell-code}\n#多个相同字符，只替换结尾字符，在目标字符右侧加“$”\ngsub(\"B$\",\"A\",'B_B_B')\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"B_B_A\"\n```\n:::\n\n```{.r .cell-code}\n#把目标字符及目标字符后面的一个字符替换掉\ngsub('D.','X',\"ABCDEFG\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"ABCXFG\"\n```\n:::\n\n```{.r .cell-code}\n#把目标字符及目标字符后面的2个字符替换掉\ngsub('D..','X',\"ABCDEFG\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"ABCXG\"\n```\n:::\n\n```{.r .cell-code}\n#把D及D后面的字符全部替换掉\ngsub('D.*','X',\"ABCDEFG\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"ABCX\"\n```\n:::\n\n```{.r .cell-code}\n#替换空格，使用“\\\\s”\ngsub(\"\\\\s\",\"_\",\"A B C\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"A_B_C\"\n```\n:::\n\n```{.r .cell-code}\n#替换不同字符，使用“|”\ngsub('B|D|G','X',\"ABCDEFG\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"AXCXEFX\"\n```\n:::\n\n```{.r .cell-code}\n#模糊匹配替换\ngsub('[0-9]','X',\"1A2B3C4D5\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"XAXBXCXDX\"\n```\n:::\n\n```{.r .cell-code}\ngsub('[A-Z]','X',\"1A2B3C4D5\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"1X2X3X4X5\"\n```\n:::\n:::\n\n::: {.cell hash='character_cache/html/unnamed-chunk-5_2d158394edc98fe66da7b32c75ab4ad9'}\n\n```{.r .cell-code}\n#大小写转换\ntoupper(\"abc\") #转换成大写\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"ABC\"\n```\n:::\n\n```{.r .cell-code}\ntolower(\"ABC\") #转换成小写\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"abc\"\n```\n:::\n:::\n\n\n## 字符的连接\n\n\n::: {.cell hash='character_cache/html/unnamed-chunk-6_4411f2be37a5d7cb8006d36c783a0c8a'}\n\n```{.r .cell-code}\npaste(\"hello\", \"world\", \"!\", sep = \" \")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"hello world !\"\n```\n:::\n\n```{.r .cell-code}\npaste(\"x\",1:3,sep=\"M\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"xM1\" \"xM2\" \"xM3\"\n```\n:::\n:::\n\n\n### unite()函数的使用\n\n构建案例数据\n\n\n::: {.cell hash='character_cache/html/unnamed-chunk-7_c4fdcd66ab00b01caa94cc74409bdf94'}\n\n```{.r .cell-code}\na1 <- rep(1,5) # 重复“1” 5次\na2 <- rep(2,5)\na3 <- rep(3,5)\nA <- data.frame(a1,a2,a3)\nA\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  a1 a2 a3\n1  1  2  3\n2  1  2  3\n3  1  2  3\n4  1  2  3\n5  1  2  3\n```\n:::\n:::\n\n\n现在想对生成的数据框A里面的a1,a2和a3列进行合并，形成新\"a123\"列，其中a1与a2用\"\\~\"连接，a2与a3列用\"/\"连接。\n\n首先对数据A的列a1,a2合并为新列a12，用\"\\~\"连接。\n\n\n::: {.cell hash='character_cache/html/unnamed-chunk-8_65796a6c81d295573248befefb529b5a'}\n\n```{.r .cell-code}\nlibrary(tidyr)\nA1 <- unite(A,#目标数据集\n            \"a12\",#新列的名称\n            a1,a2,#需要合并的列名(若用“:”连接则表示合并两列及之间的所有列)\n            sep = '~',#指定连接符\n            remove=F)#是否移除原始列\n\n#或者\nA1 <- A %>% unite(\"a12\",a1,a2,sep = '~',remove=F)\nA1\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  a12 a1 a2 a3\n1 1~2  1  2  3\n2 1~2  1  2  3\n3 1~2  1  2  3\n4 1~2  1  2  3\n5 1~2  1  2  3\n```\n:::\n:::\n\n\n然后对A1里面的a12列与a3列用\"/\"连接，形成新列\"a123\"\n\n\n::: {.cell hash='character_cache/html/unnamed-chunk-9_208374a902174dd246b656c7de2ff96a'}\n\n```{.r .cell-code}\nA2 <- unite(A1,\"a123\",a12,a3,sep = '/',remove=F)\nA2\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   a123 a12 a1 a2 a3\n1 1~2/3 1~2  1  2  3\n2 1~2/3 1~2  1  2  3\n3 1~2/3 1~2  1  2  3\n4 1~2/3 1~2  1  2  3\n5 1~2/3 1~2  1  2  3\n```\n:::\n\n```{.r .cell-code}\n#也可以用管道传参一步搞定\nA2 <- A %>% \n  unite(a12,a1,a2,sep = '~',remove=F) %>% \n  unite(a123,a12,a3,sep = '/',remove=F)\nA2\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   a123 a12 a1 a2 a3\n1 1~2/3 1~2  1  2  3\n2 1~2/3 1~2  1  2  3\n3 1~2/3 1~2  1  2  3\n4 1~2/3 1~2  1  2  3\n5 1~2/3 1~2  1  2  3\n```\n:::\n:::\n\n\n## 字符查找\n\n### **%in%指令**\n\n它会把每个字符串当成判断的最小单位，所以不能用来判断/查找\"长字符串中是否含有特定的短字符串\"\n\n\n::: {.cell hash='character_cache/html/unnamed-chunk-10_e5662abf5fb2155d448d8efd12bd68eb'}\n\n```{.r .cell-code}\ny <- c(\"中国四川\",\"中国北京\",\"中国安徽\",\"北京天安门\")\ny\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"中国四川\"   \"中国北京\"   \"中国安徽\"   \"北京天安门\"\n```\n:::\n\n```{.r .cell-code}\n\"中国四川\" %in% y\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n\n```{.r .cell-code}\n\"中国\" %in% y\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] FALSE\n```\n:::\n:::\n\n\n### **`grep()`函数**\n\ngrep的全称是global search regular expression and print out the line,可以通过正则表达式搜索文本，并把匹配的行打印出来。所谓正则表达式，就是用某种模式去匹配一类字符串的一个公式，很多文本编辑器或者程序语言都支持该方式进行字符串的操作。下面我们用该函数首先查找y中是否有包含\"北京\"字样的条目，并返回其所在位置：\n\n\n::: {.cell hash='character_cache/html/unnamed-chunk-11_ea6c3d7c8220f8226375fd8c1641a51c'}\n\n```{.r .cell-code}\ngrep(\"北京\", #需要找找的字符\n     y,#从哪里查找\n     ignore.case=F,#是否忽略大小写，默认为FALSE\n     value=F,#默认为FALSE，表示返回匹配到的字符所在的位置；TRUE则返回查找到的值\n     invert=F)#如果为TRUE，则返回未匹配到的字符的值或位置。\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 2 4\n```\n:::\n:::\n\n\n查找y中包含\"北京\"的条目有哪些：\n\n\n::: {.cell hash='character_cache/html/unnamed-chunk-12_c989336fcf60cf9b1ff6708c9f3208f5'}\n\n```{.r .cell-code}\ngrep(\"北京\", y, ignore.case = F, value = T, invert = F)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"中国北京\"   \"北京天安门\"\n```\n:::\n:::\n\n\n从framdata数据集中，提取NAME包含了\"TR\"的个案，形成新的TR_data数据集。\n\n生成演示数据\n\n\n::: {.cell hash='character_cache/html/unnamed-chunk-13_768d361ce18dd21a9b7b86f44137fad0'}\n\n```{.r .cell-code}\nframdata <- data.frame(ID = c(6, 8, 12, 14, 14, 15, 17, 22, 24, 23),\n                       NAME = c(\"A_CT\", \"B_CT\", \"C_CT\", \"D_CT\", \"E_TR\", \"F_TR\",\n                                \"G_TR\", \"H_TR\", \"I_TR\", \"J_TR\"),\n                       VALUE = c(14, 12, 12, 13, 7, 8, 7, 4, 6, 5))\nframdata\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   ID NAME VALUE\n1   6 A_CT    14\n2   8 B_CT    12\n3  12 C_CT    12\n4  14 D_CT    13\n5  14 E_TR     7\n6  15 F_TR     8\n7  17 G_TR     7\n8  22 H_TR     4\n9  24 I_TR     6\n10 23 J_TR     5\n```\n:::\n:::\n\n\n利用该函数返回framdata中NAME列中包含了\"TR\"的行号\n\n\n::: {.cell hash='character_cache/html/unnamed-chunk-14_a1496f7589b31c806a36819e9929a7d8'}\n\n```{.r .cell-code}\ngrep(\"TR\", framdata$NAME, ignore.case = F, value = F, invert = F)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1]  5  6  7  8  9 10\n```\n:::\n:::\n\n\n下面最终实现上述目的\n\n\n::: {.cell hash='character_cache/html/unnamed-chunk-15_77f9766242773776d156a3011e07feb8'}\n\n```{.r .cell-code}\nTR_data <- framdata[grep(\"TR\", framdata$NAME),]\nTR_data\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   ID NAME VALUE\n5  14 E_TR     7\n6  15 F_TR     8\n7  17 G_TR     7\n8  22 H_TR     4\n9  24 I_TR     6\n10 23 J_TR     5\n```\n:::\n:::\n\n\n### **`grepl()`函数**\n\n`grep()`和`grepl()`这两个函数最大的区别在于`grep()`返回找到的位置，`grepl`返回【是否】包含要查找的内容的逻辑向量。\n\n\n::: {.cell hash='character_cache/html/unnamed-chunk-16_17d9b389de290504988090e4d4a4efce'}\n\n```{.r .cell-code}\ngrepl(\"北京\", y)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] FALSE  TRUE FALSE  TRUE\n```\n:::\n\n```{.r .cell-code}\nany(grepl(\"北京\", y))#只要y中有包含了“北京”的项目就返回一个\"TRUE\"\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n:::\n\n\n### \n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}