{
  "hash": "1f394aa1218c9d4d3068d904b2ec3ea9",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"基于tidyr的长/宽数据转换\"\n---\n\n\n> 参考：<https://r4ds.hadley.nz/data-tidy>\n\n[![](images/logo-02.png){width=\"175\"}](https://tidyr.tidyverse.org)\n\n[Tidyr](https://tidyr.tidyverse.org)是tidyverse的核心包之一，其目标是帮助创建整洁的数据。整洁的数据是具有以下特征的数据：\n\n-   每个变量都是一列\n\n-   每个观测值是一行\n\n-   每个值是一个单元格\n\n![整洁数据的基本特征](images/tidy-1.png){#fig-dataset_tidy width=\"553\"}\n\n# 加载包\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\nlibrary(nycflights13)\n```\n:::\n\n\n这里的案例数据显示了以三种不同方式组织的相同数据。每个数据集都有相同的四个变量：country（国家）、year（年份）、population（总人口）和cases（结核病病例数），但每个数据集以不同的方式组织这些值。\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntable1\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 6 × 4\n  country      year  cases population\n  <chr>       <dbl>  <dbl>      <dbl>\n1 Afghanistan  1999    745   19987071\n2 Afghanistan  2000   2666   20595360\n3 Brazil       1999  37737  172006362\n4 Brazil       2000  80488  174504898\n5 China        1999 212258 1272915272\n6 China        2000 213766 1280428583\n```\n\n\n:::\n\n```{.r .cell-code}\ntable2\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 12 × 4\n   country      year type            count\n   <chr>       <dbl> <chr>           <dbl>\n 1 Afghanistan  1999 cases             745\n 2 Afghanistan  1999 population   19987071\n 3 Afghanistan  2000 cases            2666\n 4 Afghanistan  2000 population   20595360\n 5 Brazil       1999 cases           37737\n 6 Brazil       1999 population  172006362\n 7 Brazil       2000 cases           80488\n 8 Brazil       2000 population  174504898\n 9 China        1999 cases          212258\n10 China        1999 population 1272915272\n11 China        2000 cases          213766\n12 China        2000 population 1280428583\n```\n\n\n:::\n\n```{.r .cell-code}\ntable3\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 6 × 3\n  country      year rate             \n  <chr>       <dbl> <chr>            \n1 Afghanistan  1999 745/19987071     \n2 Afghanistan  2000 2666/20595360    \n3 Brazil       1999 37737/172006362  \n4 Brazil       2000 80488/174504898  \n5 China        1999 212258/1272915272\n6 China        2000 213766/1280428583\n```\n\n\n:::\n:::\n\n\ntable1中的数据符合 @fig-dataset_tidy 中的整洁数据规范。\n\n# `pivot_longer()`：转换成长数据\n\n![](images/截屏2024-03-10%2012.26.37.png)\n\n这里我们以billboard数据集为例。该数据记录了 2000 年歌曲在广告牌上的排名情况：\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbillboard\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 317 × 79\n   artist     track date.entered   wk1   wk2   wk3   wk4   wk5   wk6   wk7   wk8\n   <chr>      <chr> <date>       <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl>\n 1 2 Pac      Baby… 2000-02-26      87    82    72    77    87    94    99    NA\n 2 2Ge+her    The … 2000-09-02      91    87    92    NA    NA    NA    NA    NA\n 3 3 Doors D… Kryp… 2000-04-08      81    70    68    67    66    57    54    53\n 4 3 Doors D… Loser 2000-10-21      76    76    72    69    67    65    55    59\n 5 504 Boyz   Wobb… 2000-04-15      57    34    25    17    17    31    36    49\n 6 98^0       Give… 2000-08-19      51    39    34    26    26    19     2     2\n 7 A*Teens    Danc… 2000-07-08      97    97    96    95   100    NA    NA    NA\n 8 Aaliyah    I Do… 2000-01-29      84    62    51    41    38    35    35    38\n 9 Aaliyah    Try … 2000-03-18      59    53    38    28    21    18    16    14\n10 Adams, Yo… Open… 2000-08-26      76    76    74    69    68    67    61    58\n# ℹ 307 more rows\n# ℹ 68 more variables: wk9 <dbl>, wk10 <dbl>, wk11 <dbl>, wk12 <dbl>,\n#   wk13 <dbl>, wk14 <dbl>, wk15 <dbl>, wk16 <dbl>, wk17 <dbl>, wk18 <dbl>,\n#   wk19 <dbl>, wk20 <dbl>, wk21 <dbl>, wk22 <dbl>, wk23 <dbl>, wk24 <dbl>,\n#   wk25 <dbl>, wk26 <dbl>, wk27 <dbl>, wk28 <dbl>, wk29 <dbl>, wk30 <dbl>,\n#   wk31 <dbl>, wk32 <dbl>, wk33 <dbl>, wk34 <dbl>, wk35 <dbl>, wk36 <dbl>,\n#   wk37 <dbl>, wk38 <dbl>, wk39 <dbl>, wk40 <dbl>, wk41 <dbl>, wk42 <dbl>, …\n```\n\n\n:::\n:::\n\n\n在这个数据集中，每个观测（行）都是一首歌曲。前三列（“artist”、“track”和“date.entered”）是描述歌曲的变量。在此之后的76 列（“wk1”-“wk76”）描述了该歌曲在发行后每周的排名信息（仅在进入前100名时记录名次信息）。因此，对于“wk1”-“wk76”中的数据，**所有的列名是一个变量（周数）**，每个单元格值则是另一个变量（每周的排名）。因此，这个数据集是不符合整洁数据的要求的。\n\n下面，我们通过`pivot_longer()`将该数据转换成一个**长数据**，使其符合整洁数据：\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbillboard |> \n  pivot_longer(\n    cols = starts_with(\"wk\"), \n    names_to = \"week\", \n    values_to = \"rank\"\n  )\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 24,092 × 5\n   artist track                   date.entered week   rank\n   <chr>  <chr>                   <date>       <chr> <dbl>\n 1 2 Pac  Baby Don't Cry (Keep... 2000-02-26   wk1      87\n 2 2 Pac  Baby Don't Cry (Keep... 2000-02-26   wk2      82\n 3 2 Pac  Baby Don't Cry (Keep... 2000-02-26   wk3      72\n 4 2 Pac  Baby Don't Cry (Keep... 2000-02-26   wk4      77\n 5 2 Pac  Baby Don't Cry (Keep... 2000-02-26   wk5      87\n 6 2 Pac  Baby Don't Cry (Keep... 2000-02-26   wk6      94\n 7 2 Pac  Baby Don't Cry (Keep... 2000-02-26   wk7      99\n 8 2 Pac  Baby Don't Cry (Keep... 2000-02-26   wk8      NA\n 9 2 Pac  Baby Don't Cry (Keep... 2000-02-26   wk9      NA\n10 2 Pac  Baby Don't Cry (Keep... 2000-02-26   wk10     NA\n# ℹ 24,082 more rows\n```\n\n\n:::\n:::\n\n\n-   `cols`：指定需要转换哪些列，即哪些列不是变量。此参数使用与 `select()`相同的语法（见[此前章节](/r_basic/dplyr.qmd#sec-select)），因此在这里我们可以使用 `!c(artist, track, date.entered)` 或 `starts_with(\"wk\")` 来选择“wk1”到“wk76”列。\n\n-   `names_to`：转换后的列的列名，即新变量名。这里我们将该变量命名为 “week” 。\n\n-   `values_to`：指定单元格值所代表的变量的变量名。我们将该变量命名为 “rank”。⚠️注意\"week\"和\"rank\"加了引号。\n\n现在，让我们聚焦生成的长数据。如果一首歌进入前 100 名的时间少于 76 周，会发生什么情况？以 2 Pac 的《Baby Don't Cry》为例。上面的输出结果表明，这首歌在前 100 名中只停留了 7 周，其余的周数都是缺失值。这些缺失值其实并不代表未知观测值，而是转换后的长数据集的结构迫使它们存在，因此我们可以通过设置 `values_drop_na = TRUE` 来要求 `pivot_longer()`去掉它们：\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbillboard |> \n  pivot_longer(\n    cols = starts_with(\"wk\"), \n    names_to = \"week\", \n    values_to = \"rank\",\n    values_drop_na = TRUE\n  )\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 5,307 × 5\n   artist  track                   date.entered week   rank\n   <chr>   <chr>                   <date>       <chr> <dbl>\n 1 2 Pac   Baby Don't Cry (Keep... 2000-02-26   wk1      87\n 2 2 Pac   Baby Don't Cry (Keep... 2000-02-26   wk2      82\n 3 2 Pac   Baby Don't Cry (Keep... 2000-02-26   wk3      72\n 4 2 Pac   Baby Don't Cry (Keep... 2000-02-26   wk4      77\n 5 2 Pac   Baby Don't Cry (Keep... 2000-02-26   wk5      87\n 6 2 Pac   Baby Don't Cry (Keep... 2000-02-26   wk6      94\n 7 2 Pac   Baby Don't Cry (Keep... 2000-02-26   wk7      99\n 8 2Ge+her The Hardest Part Of ... 2000-09-02   wk1      91\n 9 2Ge+her The Hardest Part Of ... 2000-09-02   wk2      87\n10 2Ge+her The Hardest Part Of ... 2000-09-02   wk3      92\n# ℹ 5,297 more rows\n```\n\n\n:::\n:::\n\n\n注意到“week”目前为字符型变量，可以通过readr包中的`parse_number()`将其转换成数值型变量（详见[此前章节](/r_basic/data_input_output.qmd#sec-定义列类别)），便于后续分析：\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbillboard_longer <- billboard |> \n  pivot_longer(\n    cols = starts_with(\"wk\"), \n    names_to = \"week\", \n    values_to = \"rank\",\n    values_drop_na = TRUE\n  ) |> \n  mutate(\n    week = parse_number(week)\n  )\nbillboard_longer\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 5,307 × 5\n   artist  track                   date.entered  week  rank\n   <chr>   <chr>                   <date>       <dbl> <dbl>\n 1 2 Pac   Baby Don't Cry (Keep... 2000-02-26       1    87\n 2 2 Pac   Baby Don't Cry (Keep... 2000-02-26       2    82\n 3 2 Pac   Baby Don't Cry (Keep... 2000-02-26       3    72\n 4 2 Pac   Baby Don't Cry (Keep... 2000-02-26       4    77\n 5 2 Pac   Baby Don't Cry (Keep... 2000-02-26       5    87\n 6 2 Pac   Baby Don't Cry (Keep... 2000-02-26       6    94\n 7 2 Pac   Baby Don't Cry (Keep... 2000-02-26       7    99\n 8 2Ge+her The Hardest Part Of ... 2000-09-02       1    91\n 9 2Ge+her The Hardest Part Of ... 2000-09-02       2    87\n10 2Ge+her The Hardest Part Of ... 2000-09-02       3    92\n# ℹ 5,297 more rows\n```\n\n\n:::\n:::\n\n\n现在，我们在一个变量中拥有了所有的周数，在另一个变量中拥有了所有的排名值，这样我们就可以很好地直观显示歌曲排名随时间的变化情况。代码如下，结果如 @fig-line_graph 所示。我们可以看到，很少有歌曲能在前 100 名中停留 20 周以上。\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbillboard_longer |> \n  ggplot(aes(x = week, \n             y = rank, \n             group = track)) + \n  geom_line(alpha = 0.25) + \n  scale_y_reverse() +\n  theme_bw()\n```\n\n::: {.cell-output-display}\n![显示歌曲排名随时间变化的折线图](tidyr_files/figure-html/fig-line_graph-1.png){#fig-line_graph width=480}\n:::\n:::\n\n\n## `pivot_longer()`的转换原理\n\n假设我们有三个病人，id 分别为 A、B 和 C，我们为每个病人测量了两次血压。这里我们用在[此前章节](/r_basic/data_input_output.qmd#sec-手动生成tibble)中已经介绍过的 `tribble()` 来创建这个数据：\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf <- tribble(\n  ~id,  ~bp1, ~bp2,\n   \"A\",  100,  120,\n   \"B\",  140,  115,\n   \"C\",  120,  125\n)\n```\n:::\n\n\n该数据集的“bp1”和“bp2”列不符合整洁数据的要求。因此，我们通过`pivot_longer()`将该数据转换成包含三个变量：id（已存在）、measurement（血压测定次数）和 value（血压值）的新数据：\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf |> \n  pivot_longer(\n    cols = bp1:bp2,\n    names_to = \"measurement\",\n    values_to = \"value\"\n  )\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 6 × 3\n  id    measurement value\n  <chr> <chr>       <dbl>\n1 A     bp1           100\n2 A     bp2           120\n3 B     bp1           140\n4 B     bp2           115\n5 C     bp1           120\n6 C     bp2           125\n```\n\n\n:::\n:::\n\n\n转换是如何进行的呢？如果我们逐列考虑，就会比较容易理解。如下图所示，在原始数据集中已经是变量的一列（id）的值需要重复，重复的次数等于需要转换的列数。这里我们需要转换的列是“bp1”和“bp2”，因此每个“id”需要重复两次。\n\n![](images/variables.png){width=\"522\"}\n\n旧列名将成为新变量的值，该变量的名称由 `names_to` 参数定义。\n\n![](images/column-names.png){width=\"516\"}\n\n单元格值也会变成一个新变量的值，其名称由 `values_to` 定义。这些值将逐行填充。\n\n![](images/cell-values.png){width=\"510\"}\n\n## 包含多个变量信息的列名\n\n更具挑战性的情况是，列名中包含了多个变量信息，而我们希望将这些信息分别存储在不同的新变量中。以 who2 数据集为例，该数据集由世界卫生组织收集，记录了肺结核诊断的相关信息：\n\n\n::: {#tbl-who2 .cell tbl-cap='肺结核病例信息-列名包含多个变量信息'}\n\n```{.r .cell-code}\nwho2\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 7,240 × 58\n   country      year sp_m_014 sp_m_1524 sp_m_2534 sp_m_3544 sp_m_4554 sp_m_5564\n   <chr>       <dbl>    <dbl>     <dbl>     <dbl>     <dbl>     <dbl>     <dbl>\n 1 Afghanistan  1980       NA        NA        NA        NA        NA        NA\n 2 Afghanistan  1981       NA        NA        NA        NA        NA        NA\n 3 Afghanistan  1982       NA        NA        NA        NA        NA        NA\n 4 Afghanistan  1983       NA        NA        NA        NA        NA        NA\n 5 Afghanistan  1984       NA        NA        NA        NA        NA        NA\n 6 Afghanistan  1985       NA        NA        NA        NA        NA        NA\n 7 Afghanistan  1986       NA        NA        NA        NA        NA        NA\n 8 Afghanistan  1987       NA        NA        NA        NA        NA        NA\n 9 Afghanistan  1988       NA        NA        NA        NA        NA        NA\n10 Afghanistan  1989       NA        NA        NA        NA        NA        NA\n# ℹ 7,230 more rows\n# ℹ 50 more variables: sp_m_65 <dbl>, sp_f_014 <dbl>, sp_f_1524 <dbl>,\n#   sp_f_2534 <dbl>, sp_f_3544 <dbl>, sp_f_4554 <dbl>, sp_f_5564 <dbl>,\n#   sp_f_65 <dbl>, sn_m_014 <dbl>, sn_m_1524 <dbl>, sn_m_2534 <dbl>,\n#   sn_m_3544 <dbl>, sn_m_4554 <dbl>, sn_m_5564 <dbl>, sn_m_65 <dbl>,\n#   sn_f_014 <dbl>, sn_f_1524 <dbl>, sn_f_2534 <dbl>, sn_f_3544 <dbl>,\n#   sn_f_4554 <dbl>, sn_f_5564 <dbl>, sn_f_65 <dbl>, ep_m_014 <dbl>, …\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# 查看3:56的列名规则\ncolnames(who2)[3:56] %>% \n  str_split(\n    pattern = \"_\", \n    simplify = T\n    ) %>% \n  apply(MARGIN = 2, unique)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[[1]]\n[1] \"sp\"  \"sn\"  \"ep\"  \"rel\"\n\n[[2]]\n[1] \"m\" \"f\"\n\n[[3]]\n[1] \"014\"  \"1524\" \"2534\" \"3544\" \"4554\" \"5564\" \"65\"  \n```\n\n\n:::\n:::\n\n\n可以看到，该数据的前两列“country”和“year”是正常的变量。剩余的56列，每一列的名称都由三个部分组成，中间用 “\\_” 分隔：\n\n-   第一部分为“sp/rel/ep”，代表采用的诊断方法；\n\n-   第二部分为“m/f” ，代表性别；\n\n-   第三部分为“014/1524/2534/3535/44/4554/5564/65”， 代表年龄范围（例如，014 代表 0-14岁）。\n\n因此，在这种情况下，who2 数据中记录了六条变量信息：国家和年份（已列出）；诊断方法、性别和年龄范围（包含在3-56列的列名中），以及该类别中的患者人数（单元格值）。为了将这六条变量信息转换到六个独立的列中，我们可以通过指定 `pivot_longer()` 中的 `names_sep` 参数，按照“\\_”分隔符将原始变量名分割成若干个字符串：\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwho2 |> \n  pivot_longer(\n    cols = !(country:year),\n    names_sep = \"_\", # 指定原始列名的分隔符\n    names_to = c(\"diagnosis\", \"gender\", \"age\"), \n    values_to = \"count\"\n  )\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 405,440 × 6\n   country      year diagnosis gender age   count\n   <chr>       <dbl> <chr>     <chr>  <chr> <dbl>\n 1 Afghanistan  1980 sp        m      014      NA\n 2 Afghanistan  1980 sp        m      1524     NA\n 3 Afghanistan  1980 sp        m      2534     NA\n 4 Afghanistan  1980 sp        m      3544     NA\n 5 Afghanistan  1980 sp        m      4554     NA\n 6 Afghanistan  1980 sp        m      5564     NA\n 7 Afghanistan  1980 sp        m      65       NA\n 8 Afghanistan  1980 sp        f      014      NA\n 9 Afghanistan  1980 sp        f      1524     NA\n10 Afghanistan  1980 sp        f      2534     NA\n# ℹ 405,430 more rows\n```\n\n\n:::\n:::\n\n\n除了用 `names_sep` ，也可以使用 `names_pattern` 参数，通过正则表达式来实现上述效果。在这个案例中的数据转换过程参考如下示意图：\n\n![](images/multiple-names.png){width=\"460\"}\n\n## 混合了变量名和变量取值的列名\n\n\n::: {#tbl-household .cell tbl-cap='家庭数据'}\n\n```{.r .cell-code}\nhousehold\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 5 × 5\n  family dob_child1 dob_child2 name_child1 name_child2\n   <int> <date>     <date>     <chr>       <chr>      \n1      1 1998-11-26 2000-01-29 Susan       Jose       \n2      2 1996-06-22 NA         Mark        <NA>       \n3      3 2002-07-11 2004-04-05 Sam         Seth       \n4      4 2004-10-10 2009-08-27 Craig       Khai       \n5      5 2000-12-05 2005-02-28 Parker      Gracie     \n```\n\n\n:::\n:::\n\n\n该数据集包含五个家庭的数据，每个家庭最多记录两个孩子的姓名（name_child1、name_child2）和出生日期（dob_child1、dob_child2）。仔细观察 @tbl-who2 和 @tbl-household 可以发现 ：@tbl-who2 中需要转换的列名均由不同变量的具体取值构成（如“sp_m_014”，我们就可以知道这一列对应的诊断方法为“sp”，性别为“m”，年龄段为0-14岁）；而 @tbl-household 的列名既有变量的具体取值，如“child1”告诉我们这是编号为1的child，也有变量的名称，如“dob”（出生日期）和“name”（姓名）。\n\n为了解决这个问题，我们同样需要根据“\\_”分隔符分割原始列名，然后向 `names_to` 提供新变量名。但由于列名混合了变量名和变量取值，我们难以一一对应新旧列名。因此，这时候我们使用特殊的\"**.value \"字符**，**让分割后的旧列名的第一个元素直接作为新变量的名称；分割后的旧列名的第二个元素（child1或child2）作为新的“child”变量的取值**：\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhousehold |> \n  pivot_longer(\n    cols = !family, \n    names_sep = \"_\", \n    names_to = c(\".value\", \"child\"), \n    values_drop_na = TRUE\n  )\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 9 × 4\n  family child  dob        name  \n   <int> <chr>  <date>     <chr> \n1      1 child1 1998-11-26 Susan \n2      1 child2 2000-01-29 Jose  \n3      2 child1 1996-06-22 Mark  \n4      3 child1 2002-07-11 Sam   \n5      3 child2 2004-04-05 Seth  \n6      4 child1 2004-10-10 Craig \n7      4 child2 2009-08-27 Khai  \n8      5 child1 2000-12-05 Parker\n9      5 child2 2005-02-28 Gracie\n```\n\n\n:::\n:::\n\n\n使用 `names_to = c(\".value\", \"num\")` 进行数据转换会将列名分成两部分：第一部分决定输出的列名（x 或 y），第二部分决定 num 列的值。见下面的示意图：\n\n![](images/names-and-values.png)\n\n# `pivot_wider()`：转换成宽数据\n\n![](images/截屏2024-03-10%2012.26.43.png)\n\n`pivot_wider()` 可以通过增加列数和减少行数使数据集变宽。例如在重复测量数据中，一般而言我们会将每次观测作为一个个案，这时候一个对象多个时间点的观测数据分布在多行。这样的数据即为长数据，便于进行各种统计分析。但是如果你想了解每个对象的观测情况，就可以通过`pivot_wider()` 来将一个对象的多次观测结果合并到一行，即转换为宽数据。这种情况的实际应用场景较少，因此下面我们只简单演示了一个转换宽数据的基本语法，相关详细解释参考[该链接](https://r4ds.hadley.nz/data-tidy#widening-data)。\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncms_patient_experience\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 500 × 5\n   org_pac_id org_nm                           measure_cd measure_title prf_rate\n   <chr>      <chr>                            <chr>      <chr>            <dbl>\n 1 0446157747 USC CARE MEDICAL GROUP INC       CAHPS_GRP… CAHPS for MI…       63\n 2 0446157747 USC CARE MEDICAL GROUP INC       CAHPS_GRP… CAHPS for MI…       87\n 3 0446157747 USC CARE MEDICAL GROUP INC       CAHPS_GRP… CAHPS for MI…       86\n 4 0446157747 USC CARE MEDICAL GROUP INC       CAHPS_GRP… CAHPS for MI…       57\n 5 0446157747 USC CARE MEDICAL GROUP INC       CAHPS_GRP… CAHPS for MI…       85\n 6 0446157747 USC CARE MEDICAL GROUP INC       CAHPS_GRP… CAHPS for MI…       24\n 7 0446162697 ASSOCIATION OF UNIVERSITY PHYSI… CAHPS_GRP… CAHPS for MI…       59\n 8 0446162697 ASSOCIATION OF UNIVERSITY PHYSI… CAHPS_GRP… CAHPS for MI…       85\n 9 0446162697 ASSOCIATION OF UNIVERSITY PHYSI… CAHPS_GRP… CAHPS for MI…       83\n10 0446162697 ASSOCIATION OF UNIVERSITY PHYSI… CAHPS_GRP… CAHPS for MI…       63\n# ℹ 490 more rows\n```\n\n\n:::\n\n```{.r .cell-code}\ncms_patient_experience |> \n  pivot_wider(\n    id_cols = starts_with(\"org\"), # 哪一列/几列定义了行的唯一标识\n    names_from = measure_cd, # 从哪一列（或哪几列）获取输出列的名称\n    values_from = prf_rate # 从哪一列（或哪几列）获取单元格值\n  )\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 95 × 8\n   org_pac_id org_nm CAHPS_GRP_1 CAHPS_GRP_2 CAHPS_GRP_3 CAHPS_GRP_5 CAHPS_GRP_8\n   <chr>      <chr>        <dbl>       <dbl>       <dbl>       <dbl>       <dbl>\n 1 0446157747 USC C…          63          87          86          57          85\n 2 0446162697 ASSOC…          59          85          83          63          88\n 3 0547164295 BEAVE…          49          NA          75          44          73\n 4 0749333730 CAPE …          67          84          85          65          82\n 5 0840104360 ALLIA…          66          87          87          64          87\n 6 0840109864 REX H…          73          87          84          67          91\n 7 0840513552 SCL H…          58          83          76          58          78\n 8 0941545784 GRITM…          46          86          81          54          NA\n 9 1052612785 COMMU…          65          84          80          58          87\n10 1254237779 OUR L…          61          NA          NA          65          NA\n# ℹ 85 more rows\n# ℹ 1 more variable: CAHPS_GRP_12 <dbl>\n```\n\n\n:::\n:::\n\n\n# 拆分/合并列\n\n![](images/截屏2024-03-10%2012.25.19.png)\n\n## `unite()`：合并多列\n\n`unite(data, col, ..., sep, remove, na.rm)` 可以将多列中的字符粘贴起来构成新的一列。其中：\n\n-   `data`：目标数据集。\n\n-   `col`：新列的名称。\n\n-   `...`：需要合并的列名(若用“:”连接则表示合并两列及之间的所有列)。\n\n-   `sep`：指定连接符。\n\n-   `remove`：是否移除原始列。\n\n-   `na.rm`：如果为“True”，则在合并每个值之前将删除缺失值。\n\n\n::: {.cell}\n\n```{.r .cell-code}\nflights %>% \n  unite(\n    col = \"date\", \n    sep = \"/\", \n    year, month, day, \n    na.rm = T\n  )\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 336,776 × 17\n   date     dep_time sched_dep_time dep_delay arr_time sched_arr_time arr_delay\n   <chr>       <int>          <int>     <dbl>    <int>          <int>     <dbl>\n 1 2013/1/1      517            515         2      830            819        11\n 2 2013/1/1      533            529         4      850            830        20\n 3 2013/1/1      542            540         2      923            850        33\n 4 2013/1/1      544            545        -1     1004           1022       -18\n 5 2013/1/1      554            600        -6      812            837       -25\n 6 2013/1/1      554            558        -4      740            728        12\n 7 2013/1/1      555            600        -5      913            854        19\n 8 2013/1/1      557            600        -3      709            723       -14\n 9 2013/1/1      557            600        -3      838            846        -8\n10 2013/1/1      558            600        -2      753            745         8\n# ℹ 336,766 more rows\n# ℹ 10 more variables: carrier <chr>, flight <int>, tailnum <chr>,\n#   origin <chr>, dest <chr>, air_time <dbl>, distance <dbl>, hour <dbl>,\n#   minute <dbl>, time_hour <dttm>\n```\n\n\n:::\n:::\n\n\n也可以用 `str_c()` 或 `str_glue()` （见[基于tidyr的字符串处理-拼接字符串](/r_basic/stringr.qmd#sec-拼接字符串)）实现同样的效果：\n\n\n::: {.cell}\n\n```{.r .cell-code}\nflights %>% \n  mutate(\n    date = str_c(year, month, day, sep = \"/\"),\n    .before = year\n  )\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 336,776 × 20\n   date      year month   day dep_time sched_dep_time dep_delay arr_time\n   <chr>    <int> <int> <int>    <int>          <int>     <dbl>    <int>\n 1 2013/1/1  2013     1     1      517            515         2      830\n 2 2013/1/1  2013     1     1      533            529         4      850\n 3 2013/1/1  2013     1     1      542            540         2      923\n 4 2013/1/1  2013     1     1      544            545        -1     1004\n 5 2013/1/1  2013     1     1      554            600        -6      812\n 6 2013/1/1  2013     1     1      554            558        -4      740\n 7 2013/1/1  2013     1     1      555            600        -5      913\n 8 2013/1/1  2013     1     1      557            600        -3      709\n 9 2013/1/1  2013     1     1      557            600        -3      838\n10 2013/1/1  2013     1     1      558            600        -2      753\n# ℹ 336,766 more rows\n# ℹ 12 more variables: sched_arr_time <int>, arr_delay <dbl>, carrier <chr>,\n#   flight <int>, tailnum <chr>, origin <chr>, dest <chr>, air_time <dbl>,\n#   distance <dbl>, hour <dbl>, minute <dbl>, time_hour <dttm>\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nflights %>% \n  mutate(\n    date = str_glue(\"{year}/{month}/{day}\"),\n    .before = year\n  )\n```\n:::\n\n\n## 拆分列\n\n在 `tidyr` 中，`separate_wider_position()` 、 `separate_wider_delim()` 以及 `separate_wider_regex()` 可以将某一列根据分割符（`separate_wider_delim()`）、固定宽度（`separate_wider_position()`）或正则表达式（`separate_wider_regex()`）拆分为多列。把这些函数中的“wider”替换成“longer”就构成了另外三个类似函数，用于将某一列根据分割符、固定宽度或正则表达式拆分为多行（不常用）。因为涉及到字串的处理以及正则表达式，我们在[基于tidyr的字符串处理-拼接字符串](/r_basic/stringr.qmd#sec-拼接字符串)中对这些函数进行了详细介绍。\n\n------------------------------------------------------------------------\n\n::: {.callout-note collapse=\"true\" icon=\"false\"}\n## Session Info\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n\n```\nR version 4.3.3 (2024-02-29)\nPlatform: aarch64-apple-darwin20 (64-bit)\nRunning under: macOS Sonoma 14.3.1\n\nMatrix products: default\nBLAS:   /Library/Frameworks/R.framework/Versions/4.3-arm64/Resources/lib/libRblas.0.dylib \nLAPACK: /Library/Frameworks/R.framework/Versions/4.3-arm64/Resources/lib/libRlapack.dylib;  LAPACK version 3.11.0\n\nlocale:\n[1] en_US.UTF-8/en_US.UTF-8/en_US.UTF-8/C/en_US.UTF-8/en_US.UTF-8\n\ntime zone: Asia/Shanghai\ntzcode source: internal\n\nattached base packages:\n[1] stats     graphics  grDevices utils     datasets  methods   base     \n\nother attached packages:\n [1] nycflights13_1.0.2 lubridate_1.9.3    forcats_1.0.0      stringr_1.5.1     \n [5] dplyr_1.1.4        purrr_1.0.2        readr_2.1.5        tidyr_1.3.1       \n [9] tibble_3.2.1       ggplot2_3.5.0      tidyverse_2.0.0   \n\nloaded via a namespace (and not attached):\n [1] gtable_0.3.4      jsonlite_1.8.8    compiler_4.3.3    tidyselect_1.2.0 \n [5] scales_1.3.0      yaml_2.3.8        fastmap_1.1.1     R6_2.5.1         \n [9] generics_0.1.3    knitr_1.45        htmlwidgets_1.6.4 munsell_0.5.0    \n[13] pillar_1.9.0      tzdb_0.4.0        rlang_1.1.3       utf8_1.2.4       \n[17] stringi_1.8.3     xfun_0.42         timechange_0.3.0  cli_3.6.2        \n[21] withr_3.0.0       magrittr_2.0.3    digest_0.6.34     grid_4.3.3       \n[25] rstudioapi_0.15.0 hms_1.1.3         lifecycle_1.0.4   vctrs_0.6.5      \n[29] evaluate_0.23     glue_1.7.0        codetools_0.2-19  fansi_1.0.6      \n[33] colorspace_2.1-0  rmarkdown_2.25    tools_4.3.3       pkgconfig_2.0.3  \n[37] htmltools_0.5.7  \n```\n\n\n:::\n:::\n\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}