{
  "hash": "879212ab64fde3205ff274a35ca98fc8",
  "result": {
    "markdown": "---\ntitle: \"数据的读取与输出\"\nexecute: \n  eval: false\n---\n\n\n## 读取CSV数据文件\n\nread.csv或read.table均可\n\n\n::: {.cell hash='data_input_output_cache/html/unnamed-chunk-1_739edf5630c4d879401c8ce76eaebb67'}\n\n```{.r .cell-code}\ncsvdata<-read.csv(\"ovary_data.csv\",#相对路径\n                  header=T,#第一行是否是列名\n                  sep=\",\",#字段分隔符。文件每行上的值由此字符分隔。read.table的默认值为sep=“”，表示分隔符为‘空白’，即一个或多个空格、制表符、换行符或回车。read.csv的默认值为sep=\",\"，表示分隔符为英文逗号\n                  stringsAsFactors=F)#是否将字符向量转换为因子\ncsvdata<-read.table(\"ovary_data.csv\",header=T,sep=\",\", \n                    row.names=\"patientID\", \n                    colClasses=c(\"character\", \"character\", \"character\",\"numeric\", \"numeric\", \"numeric\")) #指定每一列的变量类型\n```\n:::\n\n\nread.table参数含义：\n\n-   `as.is`：该参数用于确定`read.table()`函数读取字符型数据时是否转换为因子型变量。当其取值为`FALSE`时，该函数将把字符型数据转换为因子型数据，取值为`TRUE`时，仍将其保留为字符型数据。\n\n## 读取SPSS文件\n\n\n::: {.cell hash='data_input_output_cache/html/unnamed-chunk-2_f015f02792aea507f9fce7422354d596'}\n\n```{.r .cell-code}\nlibrary(foreign)\nsavdata<-read.spss(\"lweight.sav\",to.data.frame=T)#需要将.sav格式数据转换成数据框\n```\n:::\n\n\n## 读取Excel文件\n\nMacOS 首选 gdata 包（因自带perl语言）；Windows首选 xlsx 包\n\n\n::: {.cell hash='data_input_output_cache/html/unnamed-chunk-3_d91f7171eedc4c9ec2f59dc9f1c69d0e'}\n\n```{.r .cell-code}\nlibrary(gdata)\nxlsdata<-read.xls(\"ovary_data.xlsx\",\n                  sheet=1)#要读取的工作表的名称或编号\n```\n:::\n\n\n## 读取txt文件\n\n\n::: {.cell hash='data_input_output_cache/html/unnamed-chunk-4_b7ac61f600d6aa37a5e684864d8ab862'}\n\n```{.r .cell-code}\nrefGene<-read.table(\"refGene.txt\",header=F,sep = \"\\t\")\n```\n:::\n\n\n## 读取自带数据集\n\n\n::: {.cell hash='data_input_output_cache/html/unnamed-chunk-5_f870f30780b4a287db2ba3cfedbe528d'}\n\n```{.r .cell-code}\ndata(Arthritis, package=\"vcd\")\n#或\nmydata <- vcd::Arthritis\n```\n:::\n\n\n## 下载和读取压缩包\n\n### 解压.zip文件\n\n\n::: {.cell hash='data_input_output_cache/html/unnamed-chunk-6_9fbd05e07fad811418fa3e2d53eb6b1b'}\n\n```{.r .cell-code}\nunzip(\"test.zip\",#压缩包的位置及文件名\n      files = \"ferroptosis_suppressor.csv\",\n      overwrite = T)#解压后是否覆盖同名文件\n```\n:::\n\n\n### 解压.tar文件\n\n\n::: {.cell hash='data_input_output_cache/html/unnamed-chunk-7_dd4361fcad3b2ae18451f02fbc64172a'}\n\n```{.r .cell-code}\nuntar(\"test.tar\",#压缩包的位置及文件名\n      files = \"ferroptosis_suppressor.csv\")#提取指定文件，忽略则解压压缩包内的所有文件\n```\n:::\n\n\n### 下载和解压.gz或.bz2文件\n\n这两个压缩文件与前面的相比，是最与众不同的，因为这两种后缀的文件，可以称之为压缩文件，也可以直接作为一个数据文件进行读取。\n\n\n::: {.cell hash='data_input_output_cache/html/unnamed-chunk-8_03e4877e486400de09da5204f994ccc0'}\n\n```{.r .cell-code}\n#下载gz文件\ndownload.file(\"http://hgdownload.soe.ucsc.edu/goldenPath/hg38/database/refGene.txt.gz\"#下载地址\n              ,destfile=\"refGene.txt.gz\")#文件名，注意需要添加后缀名\n#直接以数据的形式读取.gz文件\nmydata<-read.table(\"refGene.txt.gz\")\n```\n:::\n\n\n## 列出指定目录中的文件\n\n\n::: {.cell hash='data_input_output_cache/html/unnamed-chunk-9_36bc2f1d4f664bf50a092fe7a83acdbe'}\n\n```{.r .cell-code}\nlist.files(\"folder_name\",#需要列出的文件所在的路径,若忽略此项则列出当前工作路径下的所有文件\n          pattern = \"\\\\.docx$\",#列出当前目录中以.docx结尾的文件（列出以G开头的文件\"^G\"）\n          full.names = T)#FALSE：仅输出文件名；TRUE(默认)：输出路径+文件名\n```\n:::\n\n\n## 生成数据框\n\n\n::: {.cell hash='data_input_output_cache/html/unnamed-chunk-10_5b04bb94ef086d382f1fc793c4bd620d'}\n\n```{.r .cell-code}\nframdata <- data.frame(y=c(6, 8, 12, 14, 14, 15, 17, 22, 24, 23),\n                       x1=c(2, 5, 4, 3, 4, 6, 7, 5, 8, 9),\n                       x2=c(14, 12, 12, 13, 7, 8, 7, 4, 6, 5))\nframdata\n\n#使用文本编辑器直接在窗口中编辑数据。macOS需要安装XQuartz（www.xquartz.org）才能运行此代码。\nframdata <- edit(framdata) \n```\n:::\n\n\n## 导出表格\n\n### 导出csv文件\n\n\n::: {.cell hash='data_input_output_cache/html/unnamed-chunk-11_96b800b8074b0f5e56811b94714255aa'}\n\n```{.r .cell-code}\nwrite.csv(mydata,\n          row.names=F,#是否输出行名称\n          \"mydata.csv\")\n```\n:::\n\n\n### 导出excel文件\n\n\n::: {.cell hash='data_input_output_cache/html/unnamed-chunk-12_70c7498e15b030370d630ba97569cd99'}\n\n```{.r .cell-code}\nlibrary(openxlsx2)\nwrite_xlsx(coxtable1,\"coxtable1.xlsx\")\n```\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}