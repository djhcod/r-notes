{
  "hash": "cb7fef6d9ff2de32f7bcb2e6f67f16fa",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"不同类型向量的处理\"\n---\n\n\n> 参考：<https://r4ds.hadley.nz/transform>\n\n本章按照数据处理中不同的变量类型分别介绍常用的一些函数。这些函数大部分来自`base`包，但是为了保持一致性和贴合实际场景，本章的语法仍遵循`tidyverse`风格。\n\n# 加载包和案例数据\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\nlibrary(nycflights13)\nlibrary(VIM)\n```\n:::\n\n\n# 逻辑向量（**logical vectors**）\n\n用 `nycflights13` 包内“flights”数据集为例，该数据集包含 2013 年从纽约市起飞的所有 336,776 次航班的信息。下面是一个简单的生成逻辑向量的例子，在“flights”中新增两列，判断航班是否在白天起飞（新列命名为“daytime”），是否准时到达（到达延误\\<20 min，新列命名为“approx_ontime”）：\n\n\n::: {.cell}\n\n```{.r .cell-code}\nflights\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 336,776 × 19\n    year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n   <int> <int> <int>    <int>          <int>     <dbl>    <int>          <int>\n 1  2013     1     1      517            515         2      830            819\n 2  2013     1     1      533            529         4      850            830\n 3  2013     1     1      542            540         2      923            850\n 4  2013     1     1      544            545        -1     1004           1022\n 5  2013     1     1      554            600        -6      812            837\n 6  2013     1     1      554            558        -4      740            728\n 7  2013     1     1      555            600        -5      913            854\n 8  2013     1     1      557            600        -3      709            723\n 9  2013     1     1      557            600        -3      838            846\n10  2013     1     1      558            600        -2      753            745\n# ℹ 336,766 more rows\n# ℹ 11 more variables: arr_delay <dbl>, carrier <chr>, flight <int>,\n#   tailnum <chr>, origin <chr>, dest <chr>, air_time <dbl>, distance <dbl>,\n#   hour <dbl>, minute <dbl>, time_hour <dttm>\n```\n\n\n:::\n\n```{.r .cell-code}\nflights |> \n  mutate(\n    daytime = dep_time > 600 & dep_time < 2000,\n    approx_ontime = abs(arr_delay) < 20,\n    .keep = \"used\"\n  )\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 336,776 × 4\n   dep_time arr_delay daytime approx_ontime\n      <int>     <dbl> <lgl>   <lgl>        \n 1      517        11 FALSE   TRUE         \n 2      533        20 FALSE   FALSE        \n 3      542        33 FALSE   FALSE        \n 4      544       -18 FALSE   TRUE         \n 5      554       -25 FALSE   FALSE        \n 6      554        12 FALSE   TRUE         \n 7      555        19 FALSE   TRUE         \n 8      557       -14 FALSE   TRUE         \n 9      557        -8 FALSE   TRUE         \n10      558         8 FALSE   TRUE         \n# ℹ 336,766 more rows\n```\n\n\n:::\n:::\n\n\n## 逻辑摘要\n\n-   `any(x)`：相当于 `|`。如果“x”中有任何“TRUE”，则返回“TRUE”。\n\n-   `all(x)`：相当于 `&`。只有当“x”中所有值均为“TRUE”时，才返回“TRUE”。\n\n例如，我们可以使用 `all()` 和 `any()` 来判断所有航班的起飞延误是否都在一个小时以内，以及是否有任何航班在到达时延误了五个小时或以上。通过使用 `group_by()`，我们可以按月来统计：\n\n\n::: {.cell}\n\n```{.r .cell-code}\nflights |> \n  group_by(year, month, day) |> \n  summarize(\n    all_delayed = all(dep_delay <= 60, na.rm = TRUE),\n    any_long_delay = any(arr_delay >= 300, na.rm = TRUE),\n    .groups = \"drop\"\n  )\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 365 × 5\n    year month   day all_delayed any_long_delay\n   <int> <int> <int> <lgl>       <lgl>         \n 1  2013     1     1 FALSE       TRUE          \n 2  2013     1     2 FALSE       TRUE          \n 3  2013     1     3 FALSE       FALSE         \n 4  2013     1     4 FALSE       FALSE         \n 5  2013     1     5 FALSE       TRUE          \n 6  2013     1     6 FALSE       FALSE         \n 7  2013     1     7 FALSE       TRUE          \n 8  2013     1     8 FALSE       FALSE         \n 9  2013     1     9 FALSE       TRUE          \n10  2013     1    10 FALSE       TRUE          \n# ℹ 355 more rows\n```\n\n\n:::\n:::\n\n\n## 逻辑向量计数\n\n在数学计算中使用逻辑向量时，“TRUE” 变为 1，“FALSE” 变为 0。因此，我们可以通过 `sum()` 和 `mean()` 来计数逻辑向量。`sum()` 可以给出 “TRUE” 的个数，而 `mean()` 可以给出 “TRUE” 的比例（因为 `mean(x)` = `sum(x)` ÷ `length(x)`）。\n\n例如，我们可以统计每个月起飞延误在一小时以内的航班比例，以及抵达时延误五小时或以上的航班数量：\n\n\n::: {.cell}\n\n```{.r .cell-code}\nflights |> \n  group_by(year, month) |> \n  summarize(\n    proportion_delayed = mean(dep_delay <= 60, na.rm = TRUE),\n    count_long_delay = sum(arr_delay >= 300, na.rm = TRUE),\n    .groups = \"drop\"\n  )\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 12 × 4\n    year month proportion_delayed count_long_delay\n   <int> <int>              <dbl>            <int>\n 1  2013     1              0.931               25\n 2  2013     2              0.930               21\n 3  2013     3              0.916               64\n 4  2013     4              0.908               50\n 5  2013     5              0.918               47\n 6  2013     6              0.872               93\n 7  2013     7              0.866              140\n 8  2013     8              0.920               40\n 9  2013     9              0.951               58\n10  2013    10              0.953               19\n11  2013    11              0.960               19\n12  2013    12              0.906               50\n```\n\n\n:::\n:::\n\n\n## 条件转换\n\n逻辑向量最重要的应用之一是用于条件转换，即对条件 x 做一件事，而对条件 y 做另一件事。可以通过 `base` 包的 `ifelse()` 函数实现。而在 `tidyverse` 中的函数为：`if_else()` 和 `case_when()`。\n\n`if_else()` 与 `ifelse()` 的使用基本相同。`if_else()` 可以通过指定 `missing` 参数来定义缺失值的表示形式，并且在确定输出类型时总是将 true、false 和 missing 考虑在内：\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- c(1:3, NA, 4, 5, NA)\nifelse(x <3, \"<3\", \"≥3\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"<3\" \"<3\" \"≥3\" NA   \"≥3\" \"≥3\" NA  \n```\n\n\n:::\n\n```{.r .cell-code}\nif_else(x <3, \"<3\", \"≥3\", missing = \"Unknown\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"<3\"      \"<3\"      \"≥3\"      \"Unknown\" \"≥3\"      \"≥3\"      \"Unknown\"\n```\n\n\n:::\n:::\n\n\n在统计分析中 `ifelse()` 和 `if_else()` 的一个十分常见的应用场景就是**对变量进行赋值或替换已有赋值**。例如我们可以根据到达延误时间（“arr_delay”）生成一个新变量“arr_2”，如果到达延误时间在30 min以内，赋值为“undelayed”，否则就为“delayed”：\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# 新根据到达延误时间\nflights %>%  \n  mutate(\n    arr_2 = if_else(arr_delay <= 30, \"undelayed\", \"delayed\"), \n    .after = dep_delay\n  ) \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 336,776 × 20\n    year month   day dep_time sched_dep_time dep_delay arr_2     arr_time\n   <int> <int> <int>    <int>          <int>     <dbl> <chr>        <int>\n 1  2013     1     1      517            515         2 undelayed      830\n 2  2013     1     1      533            529         4 undelayed      850\n 3  2013     1     1      542            540         2 delayed        923\n 4  2013     1     1      544            545        -1 undelayed     1004\n 5  2013     1     1      554            600        -6 undelayed      812\n 6  2013     1     1      554            558        -4 undelayed      740\n 7  2013     1     1      555            600        -5 undelayed      913\n 8  2013     1     1      557            600        -3 undelayed      709\n 9  2013     1     1      557            600        -3 undelayed      838\n10  2013     1     1      558            600        -2 undelayed      753\n# ℹ 336,766 more rows\n# ℹ 12 more variables: sched_arr_time <int>, arr_delay <dbl>, carrier <chr>,\n#   flight <int>, tailnum <chr>, origin <chr>, dest <chr>, air_time <dbl>,\n#   distance <dbl>, hour <dbl>, minute <dbl>, time_hour <dttm>\n```\n\n\n:::\n:::\n\n\n如果需要进行多重逻辑判断的话需要嵌套使用 `if_else()` 。如：\n\n\n::: {.cell}\n\n```{.r .cell-code}\nflights %>%\n  mutate(\n    status = if_else(\n      is.na(arr_delay), \"cancelled\",\n      if_else(\n        arr_delay < -30, \"very early\",\n        if_else(\n          arr_delay < -15, \"early\",\n          if_else(\n            arr_delay <= 15, \"on time\",\n            if_else(\n              arr_delay < 60, \"late\", \"very late\"\n            )\n          )\n        )\n      )\n    ),\n    .after = dep_delay\n  ) %>%\n  select(status) %>%\n  table()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nstatus\n cancelled      early       late    on time very early  very late \n      9430      70416      49313     159216      20084      28317 \n```\n\n\n:::\n:::\n\n\n这种情况我们可以使用 `case_when()` 来避免 `if_else()` 的反复嵌套使用，让代码更简洁易懂。case_when() 受到了 SQL 的 CASE 语句的启发，提供了一种针对不同条件执行不同计算的灵活方式。它有一个特殊的语法：`condition ~ output`。其中 `condition` 必须是逻辑向量；当 `condition` 为 “TRUE” 时，将输出 `output` 。\n\n\n::: {.cell}\n\n```{.r .cell-code}\nflights %>% \n  mutate(\n    status = case_when(\n      is.na(arr_delay)      ~ \"cancelled\",\n      arr_delay < -30       ~ \"very early\",\n      arr_delay < -15       ~ \"early\",\n      arr_delay <= 15       ~ \"on time\",\n      arr_delay < 60        ~ \"late\",\n      arr_delay < Inf       ~ \"very late\",\n    ),\n    .after = dep_delay\n  ) %>%\n  select(status) %>%\n  table()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nstatus\n cancelled      early       late    on time very early  very late \n      9430      70416      49313     159216      20084      28317 \n```\n\n\n:::\n:::\n\n\n我们还可以通过添加 `.default` 参数，来指定默认的输出结果，当某个个案不满足所有列出的条件时就输出这个默认结果。在上面的例子中，如果我们添加了 `.default = \"very late\"` ，就不需要写 `arr_delay < Inf ~ \"very late\"` 了：\n\n\n::: {.cell}\n\n```{.r .cell-code}\nflights %>% \n  mutate(\n    status = case_when(\n      is.na(arr_delay)      ~ \"cancelled\",\n      arr_delay < -30       ~ \"very early\",\n      arr_delay < -15       ~ \"early\",\n      arr_delay <= 15       ~ \"on time\",\n      arr_delay < 60        ~ \"late\",\n      .default = \"very late\"\n    ),\n    .after = dep_delay\n  ) %>%\n  select(status) %>%\n  table()\n```\n:::\n\n\n## 缺失值\n\n### 判断缺失值\n\n\n::: {.cell}\n\n```{.r .cell-code}\nis.na(c(TRUE, NA, FALSE))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE  TRUE FALSE\n```\n\n\n:::\n\n```{.r .cell-code}\nis.na(c(1, NA, 3))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE  TRUE FALSE\n```\n\n\n:::\n\n```{.r .cell-code}\nis.na(c(\"a\", NA, \"b\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE  TRUE FALSE\n```\n\n\n:::\n:::\n\n\n我们可以使用 `is.na()` 查找缺失了“dep_time”的所有行：\n\n\n::: {.cell}\n\n```{.r .cell-code}\nflights |> \n  filter(is.na(dep_time))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 8,255 × 19\n    year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n   <int> <int> <int>    <int>          <int>     <dbl>    <int>          <int>\n 1  2013     1     1       NA           1630        NA       NA           1815\n 2  2013     1     1       NA           1935        NA       NA           2240\n 3  2013     1     1       NA           1500        NA       NA           1825\n 4  2013     1     1       NA            600        NA       NA            901\n 5  2013     1     2       NA           1540        NA       NA           1747\n 6  2013     1     2       NA           1620        NA       NA           1746\n 7  2013     1     2       NA           1355        NA       NA           1459\n 8  2013     1     2       NA           1420        NA       NA           1644\n 9  2013     1     2       NA           1321        NA       NA           1536\n10  2013     1     2       NA           1545        NA       NA           1910\n# ℹ 8,245 more rows\n# ℹ 11 more variables: arr_delay <dbl>, carrier <chr>, flight <int>,\n#   tailnum <chr>, origin <chr>, dest <chr>, air_time <dbl>, distance <dbl>,\n#   hour <dbl>, minute <dbl>, time_hour <dttm>\n```\n\n\n:::\n:::\n\n\n`is.na()` 在 `arrange()` 中也很有用。用 `arrange()` 基于某列排序时默认会将该列的所有缺失值放在最后，但可以先用 `is.na()` 进行降序排序，从而让缺失值在最前面显示：\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# 按照“dep_time”排序\nflights |> \n  filter(month == 1, day == 1) |> \n  arrange(dep_time)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 842 × 19\n    year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n   <int> <int> <int>    <int>          <int>     <dbl>    <int>          <int>\n 1  2013     1     1      517            515         2      830            819\n 2  2013     1     1      533            529         4      850            830\n 3  2013     1     1      542            540         2      923            850\n 4  2013     1     1      544            545        -1     1004           1022\n 5  2013     1     1      554            600        -6      812            837\n 6  2013     1     1      554            558        -4      740            728\n 7  2013     1     1      555            600        -5      913            854\n 8  2013     1     1      557            600        -3      709            723\n 9  2013     1     1      557            600        -3      838            846\n10  2013     1     1      558            600        -2      753            745\n# ℹ 832 more rows\n# ℹ 11 more variables: arr_delay <dbl>, carrier <chr>, flight <int>,\n#   tailnum <chr>, origin <chr>, dest <chr>, air_time <dbl>, distance <dbl>,\n#   hour <dbl>, minute <dbl>, time_hour <dttm>\n```\n\n\n:::\n\n```{.r .cell-code}\n# 按照“dep_time”排序，同时将缺失值放到最前面\nflights |> \n  filter(month == 1, day == 1) |> \n  arrange(desc(is.na(dep_time)), dep_time)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 842 × 19\n    year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n   <int> <int> <int>    <int>          <int>     <dbl>    <int>          <int>\n 1  2013     1     1       NA           1630        NA       NA           1815\n 2  2013     1     1       NA           1935        NA       NA           2240\n 3  2013     1     1       NA           1500        NA       NA           1825\n 4  2013     1     1       NA            600        NA       NA            901\n 5  2013     1     1      517            515         2      830            819\n 6  2013     1     1      533            529         4      850            830\n 7  2013     1     1      542            540         2      923            850\n 8  2013     1     1      544            545        -1     1004           1022\n 9  2013     1     1      554            600        -6      812            837\n10  2013     1     1      554            558        -4      740            728\n# ℹ 832 more rows\n# ℹ 11 more variables: arr_delay <dbl>, carrier <chr>, flight <int>,\n#   tailnum <chr>, origin <chr>, dest <chr>, air_time <dbl>, distance <dbl>,\n#   hour <dbl>, minute <dbl>, time_hour <dttm>\n```\n\n\n:::\n:::\n\n\n### 删除缺失值\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# 删除缺失“dep_time”的所有行\nflights %>% \n  filter(is.na(dep_time) == FALSE) \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 328,521 × 19\n    year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n   <int> <int> <int>    <int>          <int>     <dbl>    <int>          <int>\n 1  2013     1     1      517            515         2      830            819\n 2  2013     1     1      533            529         4      850            830\n 3  2013     1     1      542            540         2      923            850\n 4  2013     1     1      544            545        -1     1004           1022\n 5  2013     1     1      554            600        -6      812            837\n 6  2013     1     1      554            558        -4      740            728\n 7  2013     1     1      555            600        -5      913            854\n 8  2013     1     1      557            600        -3      709            723\n 9  2013     1     1      557            600        -3      838            846\n10  2013     1     1      558            600        -2      753            745\n# ℹ 328,511 more rows\n# ℹ 11 more variables: arr_delay <dbl>, carrier <chr>, flight <int>,\n#   tailnum <chr>, origin <chr>, dest <chr>, air_time <dbl>, distance <dbl>,\n#   hour <dbl>, minute <dbl>, time_hour <dttm>\n```\n\n\n:::\n\n```{.r .cell-code}\n# 删除flights数据集中包含缺失值的所有行\nflights %>% \n  na.omit()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 327,346 × 19\n    year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n   <int> <int> <int>    <int>          <int>     <dbl>    <int>          <int>\n 1  2013     1     1      517            515         2      830            819\n 2  2013     1     1      533            529         4      850            830\n 3  2013     1     1      542            540         2      923            850\n 4  2013     1     1      544            545        -1     1004           1022\n 5  2013     1     1      554            600        -6      812            837\n 6  2013     1     1      554            558        -4      740            728\n 7  2013     1     1      555            600        -5      913            854\n 8  2013     1     1      557            600        -3      709            723\n 9  2013     1     1      557            600        -3      838            846\n10  2013     1     1      558            600        -2      753            745\n# ℹ 327,336 more rows\n# ℹ 11 more variables: arr_delay <dbl>, carrier <chr>, flight <int>,\n#   tailnum <chr>, origin <chr>, dest <chr>, air_time <dbl>, distance <dbl>,\n#   hour <dbl>, minute <dbl>, time_hour <dttm>\n```\n\n\n:::\n:::\n\n\n::: {.callout-tip collapse=\"true\"}\n###### VIM 包：可视化缺失模式\n\n加载案例数据：这里用 `VIM` 包内自带的 `sleep` 数据集为例进行演示。该数据集显示了两种安眠药对10名患者的影响(与对照组相比，睡眠时间的增加量)。其中就包含了很多缺失值。\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata(sleep, package=\"VIM\")\nhead(sleep)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n   BodyWgt BrainWgt NonD Dream Sleep Span Gest Pred Exp Danger\n1 6654.000   5712.0   NA    NA   3.3 38.6  645    3   5      3\n2    1.000      6.6  6.3   2.0   8.3  4.5   42    3   1      3\n3    3.385     44.5   NA    NA  12.5 14.0   60    1   1      1\n4    0.920      5.7   NA    NA  16.5   NA   25    5   2      3\n5 2547.000   4603.0  2.1   1.8   3.9 69.0  624    3   5      4\n6   10.550    179.5  9.1   0.7   9.8 27.0  180    4   4      4\n```\n\n\n:::\n\n```{.r .cell-code}\n# 为了和其他内容一致，我们将其转换成tibble\nsleep <- as_tibble(sleep)\nsleep\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 62 × 10\n    BodyWgt BrainWgt  NonD Dream Sleep  Span  Gest  Pred   Exp Danger\n      <dbl>    <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <int> <int>  <int>\n 1 6654       5712    NA    NA     3.3  38.6   645     3     5      3\n 2    1          6.6   6.3   2     8.3   4.5    42     3     1      3\n 3    3.38      44.5  NA    NA    12.5  14      60     1     1      1\n 4    0.92       5.7  NA    NA    16.5  NA      25     5     2      3\n 5 2547       4603     2.1   1.8   3.9  69     624     3     5      4\n 6   10.6      180.    9.1   0.7   9.8  27     180     4     4      4\n 7    0.023      0.3  15.8   3.9  19.7  19      35     1     1      1\n 8  160        169     5.2   1     6.2  30.4   392     4     5      4\n 9    3.3       25.6  10.9   3.6  14.5  28      63     1     2      1\n10   52.2      440     8.3   1.4   9.7  50     230     1     1      1\n# ℹ 52 more rows\n```\n\n\n:::\n:::\n\n\n**【展示缺失值的比例】**\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsleep %>%\n  aggr(\n    prop = T,\n    numbers = T,\n    sortVars = TRUE,\n    gap = 2,\n    ylab = c(\"Histogram of missing data\", \"Pattern\")\n  )\n```\n\n::: {.cell-output-display}\n![](vector_transform_files/figure-html/unnamed-chunk-15-1.png){width=672}\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\n Variables sorted by number of missings: \n Variable      Count\n     NonD 0.22580645\n    Dream 0.19354839\n    Sleep 0.06451613\n     Span 0.06451613\n     Gest 0.06451613\n  BodyWgt 0.00000000\n BrainWgt 0.00000000\n     Pred 0.00000000\n      Exp 0.00000000\n   Danger 0.00000000\n```\n\n\n:::\n:::\n\n\n-   左侧条形图以及输出的数值结果展示了单个变量的缺失比例。例如“NonD”缺失比例大于20%，从数值结果中可以看到具体为22.58%。\n\n-   右侧直方图展示各个变量的缺失模式。如第一行表示“NonD”、“Dream”和“Span” 3个变量共同缺失的比例为1.6%。“NonD”的缺失比例 = 1.6% + 3.2% + 3.2% + 14.5% = 22.5%，和左侧条形图一致。所有变量均无缺失值的个案占67.7%。\n\n**【展示缺失值的数量】**\n\n\n::: {.cell}\n\n```{.r .cell-code}\naggr_plot <- sleep %>%\n  aggr(\n    prop = F,\n    numbers = T,\n    sortVars = TRUE,\n    gap = 2,\n    ylab = c(\"Histogram of missing data\", \"Pattern\")\n  )\n```\n\n::: {.cell-output-display}\n![](vector_transform_files/figure-html/unnamed-chunk-16-1.png){width=672}\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\n Variables sorted by number of missings: \n Variable Count\n     NonD    14\n    Dream    12\n    Sleep     4\n     Span     4\n     Gest     4\n  BodyWgt     0\n BrainWgt     0\n     Pred     0\n      Exp     0\n   Danger     0\n```\n\n\n:::\n:::\n\n\n以表格的形式展示各个变量的缺失模式（同右侧图形）\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsummary(aggr_plot)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\n Missings per variable: \n Variable Count\n  BodyWgt     0\n BrainWgt     0\n     NonD    14\n    Dream    12\n    Sleep     4\n     Span     4\n     Gest     4\n     Pred     0\n      Exp     0\n   Danger     0\n\n Missings in combinations of variables: \n        Combinations Count   Percent\n 0:0:0:0:0:0:0:0:0:0    42 67.741935\n 0:0:0:0:0:0:1:0:0:0     3  4.838710\n 0:0:0:0:0:1:0:0:0:0     2  3.225806\n 0:0:0:0:0:1:1:0:0:0     1  1.612903\n 0:0:1:0:1:0:0:0:0:0     2  3.225806\n 0:0:1:1:0:0:0:0:0:0     9 14.516129\n 0:0:1:1:0:1:0:0:0:0     1  1.612903\n 0:0:1:1:1:0:0:0:0:0     2  3.225806\n```\n\n\n:::\n:::\n\n\n**【通过 `marginplot()` 分析缺失值】**\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# 分析“NonD”和“Span”的缺失关系\nsleep %>% \n  select(NonD, Span) %>% \n  marginplot()\n```\n\n::: {.cell-output-display}\n![](vector_transform_files/figure-html/unnamed-chunk-18-1.png){width=672}\n:::\n:::\n\n\n-   空心的湖蓝色圆圈表示非缺失值，红色实心圆圈表示缺失值，深红色实心圆圈表示两个变量均缺失。\n\n-   图左侧的红色箱型图显示了在保留“NonD”缺失值的情况下“Span”的分布，蓝色箱型图显示了删除“NonD”缺失值后“Span”的分布。\n\n-   图表底部的框图正好相反，反映了在保留和删除“Span”缺失值的情况下“NonD”的分布情况。\n\n-   如果数据是**完全随机缺失（MCAR : missing completely at random）**，那么红色和蓝色箱型图将十分接近\n:::\n\n# 数值向量（numeric vectors）\n\n## 转换数值向量\n\nR 中的数值有两种类型：整数（integer）或双倍精度（double）。但有些时候由于导入数据的格式问题等原因数值会以字符串的形式保存。`readr` 提供了两个将字符串解析为数字常用函数：`parse_double()` 和 `parse_number()`。`parse_number()` 涵盖了`parse_double()` 的功能，同时能够进行数值解析。`parse_number()`会解析它找到的第一个数字，然后删除第一个数字之前的所有非数字字符和第一个数字之后的所有字符，同时也会忽略千分位分隔符“,”。所以在实际场景中主要使用 `parse_number()` 。\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# 字符转数值。开头的非数值字符被忽略\nc(\"euro1,000\", \"euro2,000\") %>% \n  parse_number()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1000 2000\n```\n\n\n:::\n\n```{.r .cell-code}\n# 字符转数值。只输出找到的第一个数值\nc(\"t1000t1000\", \"t2000t2000\") %>% \n  parse_number()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1000 2000\n```\n\n\n:::\n\n```{.r .cell-code}\n# 小数点会被保留\nc(\"1,234.56\", \"t1,234.56\") %>% \n  parse_number()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1234.56 1234.56\n```\n\n\n:::\n\n```{.r .cell-code}\n# 货币转换。开头的“$”和千分位分隔符“,”被忽略\nc(\"$1,000\", \"$1,500\") %>% \n  parse_number() \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1000 1500\n```\n\n\n:::\n\n```{.r .cell-code}\n# 可以通过locale参数指定在待转换向量中千分位分隔符(grouping_mark)和小数点(decimal_mark)的表示方法\nc(\"1 234.56\") %T>% \n  parse_number() %T>% print() %>%  \n  parse_number(locale = locale(decimal_mark = \".\", grouping_mark = \" \"))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"1 234.56\"\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1234.56\n```\n\n\n:::\n:::\n\n\n## 计数 {#sec-计数}\n\n只需使用计数和一些基本算术，就能完成大量数据科学工作，因此 `dplyr` 努力通过 `count()` 使计数变得尽可能简单。这个函数非常适合在分析过程中进行快速探索和检查：\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# 统计各个目的地的航班数\nflights |> count(dest, sort = TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 105 × 2\n   dest      n\n   <chr> <int>\n 1 ORD   17283\n 2 ATL   17215\n 3 LAX   16174\n 4 BOS   15508\n 5 MCO   14082\n 6 CLT   14064\n 7 SFO   13331\n 8 FLL   12055\n 9 MIA   11728\n10 DCA    9705\n# ℹ 95 more rows\n```\n\n\n:::\n:::\n\n\n记住，如果想查看所有值，可以使用 `|> View()` 或 `|> print(n = Inf)`。\n\n::: {.callout-note appearance=\"minimal\" icon=\"false\"}\n在 `base` 包中能够实现类似效果的是 `table()` 函数：\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntable(flights$dest) %>% head()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\n  ABQ   ACK   ALB   ANC   ATL   AUS \n  254   265   439     8 17215  2439 \n```\n\n\n:::\n:::\n\n:::\n\n可以使用 `group_by()`、`summarize()` 和 `n()` \"手动 \"执行相同的计算。这在需要同时计算其他数据摘要时十分有用。例如，我们除了要统计各个目的地的航班数之外还需要统计到的各个目的地航班的平均延误时间：\n\n\n::: {.cell}\n\n```{.r .cell-code}\nflights |> \n  group_by(dest) |> \n  summarize(\n    n = n(),\n    delay = mean(arr_delay, na.rm = TRUE)\n  )\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 105 × 3\n   dest      n delay\n   <chr> <int> <dbl>\n 1 ABQ     254  4.38\n 2 ACK     265  4.85\n 3 ALB     439 14.4 \n 4 ANC       8 -2.5 \n 5 ATL   17215 11.3 \n 6 AUS    2439  6.02\n 7 AVL     275  8.00\n 8 BDL     443  7.05\n 9 BGR     375  8.03\n10 BHM     297 16.9 \n# ℹ 95 more rows\n```\n\n\n:::\n:::\n\n\n::: callout-warning\n`n()` 是一个特殊的摘要函数，不需要任何参数，而是访问 \"当前 \" group 的信息。这意味着它只能在 `dplyr` 语句，如`summarize()` 、 `mutate()` 、 `filter()` 和 `group_by()` 等函数的内部使用。\n:::\n\n### `n()` 和 `count()` 的变体\n\n#### 计数唯一值\n\n`n_distinct()` 计算一个或多个变量的唯一值的数量。例如，我们可以推荐每个目的地有多少家航空公司提供服务：\n\n\n::: {.cell}\n\n```{.r .cell-code}\nflights |> \n  group_by(dest) |> \n  summarize(carriers = n_distinct(carrier)) |> \n  arrange(desc(carriers))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 105 × 2\n   dest  carriers\n   <chr>    <int>\n 1 ATL          7\n 2 BOS          7\n 3 CLT          7\n 4 ORD          7\n 5 TPA          7\n 6 AUS          6\n 7 DCA          6\n 8 DTW          6\n 9 IAD          6\n10 MSP          6\n# ℹ 95 more rows\n```\n\n\n:::\n:::\n\n\n::: {.callout-note appearance=\"minimal\" icon=\"false\"}\n`n_distinct(flights$carrier)` 等价于：\n\n\n::: {.cell}\n\n```{.r .cell-code}\nunique(flights$carrier) %>% length()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 16\n```\n\n\n:::\n:::\n\n:::\n\n练习：查找由至少两家航空公司（“carrier”）运营的目的地（“dest”），并在每个目的地中挑选最优的一家航空公司，挑选标准为平均出发延误时间（“dep_delay”）和到达延误时间（“arr_delay”）最短的公司：\n\n\n::: {.cell}\n\n```{.r .cell-code}\nflights %>% \n  group_by(dest) %>% \n  mutate(\n    carrier_count = n_distinct(carrier)\n  ) %>% \n  filter(carrier_count >= 2) %>% \n  group_by(dest, carrier) %>% \n  summarise(\n    mean_delay = mean(arr_delay, na.rm = T) + mean(dep_delay, na.rm = T)\n  ) %>% \n  slice_min(mean_delay, n = 1) \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 76 × 3\n# Groups:   dest [76]\n   dest  carrier mean_delay\n   <chr> <chr>        <dbl>\n 1 ATL   9E            1.82\n 2 AUS   WN           -7.40\n 3 AVL   9E          -14.7 \n 4 BDL   EV           24.4 \n 5 BGR   EV           27.5 \n 6 BNA   DL          -31   \n 7 BOS   US           -2.96\n 8 BQN   B6           13.6 \n 9 BTV   9E           -7   \n10 BUF   DL          -14   \n# ℹ 66 more rows\n```\n\n\n:::\n:::\n\n\n#### 加权计数 {#sec-wt}\n\n加权计数是分组计算总和（`sum()`）。例如，统计每个航线飞机飞行的总里程数：\n\n\n::: {.cell}\n\n```{.r .cell-code}\nflights |> \n  group_by(tailnum) |> \n  summarize(miles = sum(distance))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 4,044 × 2\n   tailnum  miles\n   <chr>    <dbl>\n 1 D942DN    3418\n 2 N0EGMQ  250866\n 3 N10156  115966\n 4 N102UW   25722\n 5 N103US   24619\n 6 N104UW   25157\n 7 N10575  150194\n 8 N105UW   23618\n 9 N107US   21677\n10 N108UW   32070\n# ℹ 4,034 more rows\n```\n\n\n:::\n:::\n\n\n加权计数经常使用，因此 count() 有一个 wt 参数，可以实现同样的目的：\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# 统计每个航线飞行的次数\nflights %>% count(tailnum)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 4,044 × 2\n   tailnum     n\n   <chr>   <int>\n 1 D942DN      4\n 2 N0EGMQ    371\n 3 N10156    153\n 4 N102UW     48\n 5 N103US     46\n 6 N104UW     47\n 7 N10575    289\n 8 N105UW     45\n 9 N107US     41\n10 N108UW     60\n# ℹ 4,034 more rows\n```\n\n\n:::\n\n```{.r .cell-code}\n# 统计每个航线飞行的总里程数\nflights |> count(tailnum, wt = distance)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 4,044 × 2\n   tailnum      n\n   <chr>    <dbl>\n 1 D942DN    3418\n 2 N0EGMQ  250866\n 3 N10156  115966\n 4 N102UW   25722\n 5 N103US   24619\n 6 N104UW   25157\n 7 N10575  150194\n 8 N105UW   23618\n 9 N107US   21677\n10 N108UW   32070\n# ℹ 4,034 more rows\n```\n\n\n:::\n:::\n\n\n实际上如果指定了 `wt` 参数，就是对其分组进行 `sum(wt)` 操作。理解加权计数的作用的另一个很好的例子参考[后面的章节](/r_basic/character.qmd#sec-str_length)。\n\n#### 计数缺失值\n\n结合 `sum()` 和 `is.na()` 可以计数缺失值。例如统计每个目的地取消的航班数：\n\n\n::: {.cell}\n\n```{.r .cell-code}\nflights |> \n  group_by(dest) |> \n  summarize(n_cancelled = sum(is.na(dep_time)))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 105 × 2\n   dest  n_cancelled\n   <chr>       <int>\n 1 ABQ             0\n 2 ACK             0\n 3 ALB            20\n 4 ANC             0\n 5 ATL           317\n 6 AUS            21\n 7 AVL            12\n 8 BDL            31\n 9 BGR            15\n10 BHM            25\n# ℹ 95 more rows\n```\n\n\n:::\n:::\n\n\n## 查找最大值和最小值\n\n两个重要函数是 `pmin()` 和 `pmax()`，当给定两个或多个变量时，它们将返回**每一行**中最小或最大值：\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf <- tribble(\n  ~x, ~y,\n  1,  3,\n  5,  2,\n  7, NA,\n)\n\ndf |> \n  mutate(\n    min = pmin(x, y, na.rm = TRUE),\n    max = pmax(x, y, na.rm = TRUE)\n  )\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 3 × 4\n      x     y   min   max\n  <dbl> <dbl> <dbl> <dbl>\n1     1     3     1     3\n2     5     2     2     5\n3     7    NA     7     7\n```\n\n\n:::\n:::\n\n\n请注意， `pmin()` 和 `pmax()`不同于汇总函数 `min()` 和 `max()`，当给定两个或多个变量时，后者只**返回单一值，即所有变量**的最大值或最小值。在本例中，如果所有行的最小值和最大值都相同，就说明使用了错误的形式：\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf |> \n  mutate(\n    min = min(x, y, na.rm = TRUE),\n    max = max(x, y, na.rm = TRUE)\n  )\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 3 × 4\n      x     y   min   max\n  <dbl> <dbl> <dbl> <dbl>\n1     1     3     1     7\n2     5     2     1     7\n3     7    NA     1     7\n```\n\n\n:::\n:::\n\n\n如果要用 `min()` 和 `max()` 实现同样的目的需要如下代码：\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmin <- apply(df, MARGIN = 1, min, na.rm = TRUE)\nmax <- apply(df, MARGIN = 1, max, na.rm = TRUE)\ndf %>% \n  mutate(min, max)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 3 × 4\n      x     y   min   max\n  <dbl> <dbl> <dbl> <dbl>\n1     1     3     1     3\n2     5     2     2     5\n3     7    NA     7     7\n```\n\n\n:::\n:::\n\n\n## 数学计算\n\n### 整除和余数（modular arithmetic）\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# 返回整除结果\n1:10 %/% 3\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] 0 0 1 1 1 2 2 2 3 3\n```\n\n\n:::\n\n```{.r .cell-code}\n# 返回余数\n1:10 %% 3\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] 1 2 0 1 2 0 1 2 0 1\n```\n\n\n:::\n:::\n\n\n### 对数\n\n在 R 中，有三种对数可供选择：\n\n-   `log()`：默认以 e 为底数\n\n-   `log2()`：以 2 为底数\n\n-   `log10()`：以 10 为底数\n\n建议使用 `log2()` 或 `log10()`。`log2()` 容易解释，因为对数刻度上的差值为 1 相当于原始刻度的两倍，差值为-1 相当于减半；而 `log10()` 容易推算原始数值，例如 3 是 10\\^3 = 1000。`log()` 的倒数是 `exp()`；要计算 `log2()` 或 `log10()` 的原始数值，需要使用 `2^` 或 `10^`。\n\n### 四舍五入\n\n`round()` 函数。第二个参数控制保留的小数位数：\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# 保留两位小数\nround(123.456, 2) \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 123.46\n```\n\n\n:::\n\n```{.r .cell-code}\n# 四舍五入到最接近的十位数\nround(123.456, -1) \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 120\n```\n\n\n:::\n\n```{.r .cell-code}\n# 四舍五入到最接近的百位数\nround(123.456, -2) \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 100\n```\n\n\n:::\n:::\n\n\n如果一个小数正好位于两个整数之间，即\\*.5的形式，`round()` 这时候会返回比较奇怪的结果（例如下面的例子）。这是因为 `round()` 使用了所谓的 \"**四舍五入，半为偶数** \"或**银行家四舍五入法（Banker’s roundin）**：即对于一个.5的小数，它将被**四舍五入为离它最近的一个偶数**。这是一种很好的策略，因为它能保持在对多个数值进行四舍五入后能够不偏不倚：\\*.5 小数的一半向上舍入，一半向下舍入。\n\n\n::: {.cell}\n\n```{.r .cell-code}\nround(c(1.4, 1.5, 2.5, 3.5, 4.5, 4.6))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1 2 2 4 4 5\n```\n\n\n:::\n:::\n\n\n另外两个取整函数：\n\n-   `ceiling()`：始终向上取整\n\n-   `floor()`：始终向下取整（删除小数）\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- 123.456\n\nfloor(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 123\n```\n\n\n:::\n\n```{.r .cell-code}\nceiling(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 124\n```\n\n\n:::\n:::\n\n\n## 切割数值向量\n\n可以使用 `cut()` 将数值向量按照不同的截断值切割（又称bin）为不同的分段：\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- c(-1, NA, 0, 1, 2, 5, 10, 15, 20, 50)\ncut(x, breaks = c(0, 5, 15, 20))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] <NA>    <NA>    <NA>    (0,5]   (0,5]   (0,5]   (5,15]  (5,15]  (15,20]\n[10] <NA>   \nLevels: (0,5] (5,15] (15,20]\n```\n\n\n:::\n\n```{.r .cell-code}\ncut(x, breaks = c(-Inf, 5, 15, Inf))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] (-Inf,5]  <NA>      (-Inf,5]  (-Inf,5]  (-Inf,5]  (-Inf,5]  (5,15]   \n [8] (5,15]    (15, Inf] (15, Inf]\nLevels: (-Inf,5] (5,15] (15, Inf]\n```\n\n\n:::\n\n```{.r .cell-code}\ncut(x, breaks = c(0, 5, 15, 20), include.lowest = T)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] <NA>    <NA>    [0,5]   [0,5]   [0,5]   [0,5]   (5,15]  (5,15]  (15,20]\n[10] <NA>   \nLevels: [0,5] (5,15] (15,20]\n```\n\n\n:::\n\n```{.r .cell-code}\ncut(x, breaks = c(0, 5, 15, 20), include.lowest = T, right = F)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] <NA>    <NA>    [0,5)   [0,5)   [0,5)   [5,15)  [5,15)  [15,20] [15,20]\n[10] <NA>   \nLevels: [0,5) [5,15) [15,20]\n```\n\n\n:::\n:::\n\n\n-   `cut()` 返回的结果是一个因子型向量\n\n-   “NA”以及任何超出截断值范围的值都将变为 “NA”\n\n-   `include.lowest`：是否包括下截断值（默认为“FALSE”）\n\n-   `right`：是否包括上截断值（默认为“TRUE”）\n\n-   `labels`：给不同的分段打标签。注意，标签数应该比截断点少一个：\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    c(1, 2, 5, 10, 15, 20) %>% \n      cut(\n        breaks = c(0, 5, 10, 15, 20), \n        labels = c(\"sm\", \"md\", \"lg\", \"xl\")\n        )\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    \n    ```\n    [1] sm sm sm md lg xl\n    Levels: sm md lg xl\n    ```\n    \n    \n    :::\n    :::\n\n\n## 数值排名\n\n`dplyr` 提供了许多受 SQL 启发的排名函数，例如 `min_rank()` ，它使用典型的方法来处理并列关系: 1st, 2nd, 2nd, 4th：\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- c(1, 2, 2, 2, 3, 4, NA)\nmin_rank(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]  1  2  2  2  5  6 NA\n```\n\n\n:::\n\n```{.r .cell-code}\n# 通过 desc() 按从高到低排名\nmin_rank(desc(x))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]  6  3  3  3  2  1 NA\n```\n\n\n:::\n:::\n\n\n如果 `min_rank()` 无法满足需求，`dplyr` 还提供了很多变体排名函数：\n\n-   `row_number()` : 为向量中的每个对象生成连续数字。**`row_number()` 可以不带任何参数，这种情况下常用于生成行号。**\n\n-   `dense_rank()`：类似于 `min_rank()` ，但是生成连续排名，如：1st, 2nd, 2nd, 3th\n\n-   `percent_rank()`：`percent_rank(x)` 计算小于 x~i~ 的值的总数 ÷ (x的总数 -1)\n\n-   `cume_dist()`：`cume_dist(x)` 计算小于或等于 x~i~ 的值的总数 ÷ x的总数\n\n以上所有函数会忽略缺失值。\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf <- tibble(x)\ndf |> \n  mutate(\n    row_number = row_number(),\n    row_number_x = row_number(x),\n    min_rank = min_rank(x),\n    dense_rank = dense_rank(x),\n    percent_rank = percent_rank(x),\n    cume_dist = cume_dist(x)\n  )\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 7 × 7\n      x row_number row_number_x min_rank dense_rank percent_rank cume_dist\n  <dbl>      <int>        <int>    <int>      <int>        <dbl>     <dbl>\n1     1          1            1        1          1          0       0.167\n2     2          2            2        2          2          0.2     0.667\n3     2          3            3        2          2          0.2     0.667\n4     2          4            4        2          2          0.2     0.667\n5     3          5            5        5          3          0.8     0.833\n6     4          6            6        6          4          1       1    \n7    NA          7           NA       NA         NA         NA      NA    \n```\n\n\n:::\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}