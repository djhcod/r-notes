{
  "hash": "1362ab2212c580095194ff40cce2f18d",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"基于dplyr包的数据整理\"\n---\n\n\n> 参考：\n>\n> [*dplyr官方文档*](https://dplyr.tidyverse.org/index.html)\n>\n> [*Data transformation chapter*](https://r4ds.hadley.nz/data-transform) *in R for Data Science*\n\n![](images/logo-2.png){width=\"205\"}\n\n# 介绍\n\n`dplyr`包是`tidyverse`的核心包之一，为数据处理提供了一系列方便快捷的函数。本章将以`nycflights13`包中的flights案例数据来介绍基于dplyr包的数据处理语法。该数据集包含 2013 年从纽约市起飞的所有 336,776 次航班的信息。\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(dplyr)\n\ndata(flights, package = \"nycflights13\")\nflights\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 336,776 × 19\n    year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n   <int> <int> <int>    <int>          <int>     <dbl>    <int>          <int>\n 1  2013     1     1      517            515         2      830            819\n 2  2013     1     1      533            529         4      850            830\n 3  2013     1     1      542            540         2      923            850\n 4  2013     1     1      544            545        -1     1004           1022\n 5  2013     1     1      554            600        -6      812            837\n 6  2013     1     1      554            558        -4      740            728\n 7  2013     1     1      555            600        -5      913            854\n 8  2013     1     1      557            600        -3      709            723\n 9  2013     1     1      557            600        -3      838            846\n10  2013     1     1      558            600        -2      753            745\n# ℹ 336,766 more rows\n# ℹ 11 more variables: arr_delay <dbl>, carrier <chr>, flight <int>,\n#   tailnum <chr>, origin <chr>, dest <chr>, air_time <dbl>, distance <dbl>,\n#   hour <dbl>, minute <dbl>, time_hour <dttm>\n```\n\n\n:::\n:::\n\n\n这里的flights数据是一个 tibble，这是一种升级版的data.frame，被 tidyverse 用来避免一些data.frame的常见问题。Tibbles 和data.frame之间的一个重要的区别在于 tibbles 打印数据的方式：tibbles 是为大型数据集设计的，因此只显示前几行和适应屏幕宽度的列（如上）。可以使用 `print(flights, width = Inf)` 显示所有列，或者使用 `glimpse()`：\n\n\n::: {.cell}\n\n```{.r .cell-code}\nglimpse(flights)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nRows: 336,776\nColumns: 19\n$ year           <int> 2013, 2013, 2013, 2013, 2013, 2013, 2013, 2013, 2013, 2…\n$ month          <int> 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1…\n$ day            <int> 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1…\n$ dep_time       <int> 517, 533, 542, 544, 554, 554, 555, 557, 557, 558, 558, …\n$ sched_dep_time <int> 515, 529, 540, 545, 600, 558, 600, 600, 600, 600, 600, …\n$ dep_delay      <dbl> 2, 4, 2, -1, -6, -4, -5, -3, -3, -2, -2, -2, -2, -2, -1…\n$ arr_time       <int> 830, 850, 923, 1004, 812, 740, 913, 709, 838, 753, 849,…\n$ sched_arr_time <int> 819, 830, 850, 1022, 837, 728, 854, 723, 846, 745, 851,…\n$ arr_delay      <dbl> 11, 20, 33, -18, -25, 12, 19, -14, -8, 8, -2, -3, 7, -1…\n$ carrier        <chr> \"UA\", \"UA\", \"AA\", \"B6\", \"DL\", \"UA\", \"B6\", \"EV\", \"B6\", \"…\n$ flight         <int> 1545, 1714, 1141, 725, 461, 1696, 507, 5708, 79, 301, 4…\n$ tailnum        <chr> \"N14228\", \"N24211\", \"N619AA\", \"N804JB\", \"N668DN\", \"N394…\n$ origin         <chr> \"EWR\", \"LGA\", \"JFK\", \"JFK\", \"LGA\", \"EWR\", \"EWR\", \"LGA\",…\n$ dest           <chr> \"IAH\", \"IAH\", \"MIA\", \"BQN\", \"ATL\", \"ORD\", \"FLL\", \"IAD\",…\n$ air_time       <dbl> 227, 227, 160, 183, 116, 150, 158, 53, 140, 138, 149, 1…\n$ distance       <dbl> 1400, 1416, 1089, 1576, 762, 719, 1065, 229, 944, 733, …\n$ hour           <dbl> 5, 5, 5, 5, 6, 5, 6, 6, 6, 6, 6, 6, 6, 6, 6, 5, 6, 6, 6…\n$ minute         <dbl> 15, 29, 40, 45, 0, 58, 0, 0, 0, 0, 0, 0, 0, 0, 0, 59, 0…\n$ time_hour      <dttm> 2013-01-01 05:00:00, 2013-01-01 05:00:00, 2013-01-01 0…\n```\n\n\n:::\n:::\n\n\n在这两种视图中，变量名下方或后面都有相应的缩写，代表每个变量的类型：`<int>` 代表整数型数据，<dbl> 代表数值型数据，<chr> 代表字符型数据，<dttm> 代表日期时间型数据。这些变量非常重要，因为对列进行的操作在很大程度上取决于该列的 \"类型\"。更多关于tibble的说明参考`tibble`包的[官方文档](https://tibble.tidyverse.org/index.html)。\n\n[![](images/logo.png){width=\"157\"}](https://tibble.tidyverse.org/index.html)\n\n`dplyr`语法的共同特点：\n\n-   第一个参数始终是数据集（tibble或data.frame）的名字。\n\n-   后面的参数通常使用变量名（不带引号）来描述要对哪些列进行操作。\n\n-   输出总是一个新的tibble或data.frame。\n\n`dplyr` 的函数可以根据它们的操作对象分为四类：分别是对行进行操作的函数、对列进行操作的函数、对表进行操作的函数以及分组统计函数，同时还包括一个特殊的管道符号`%>%`。本章将介绍除对表进行操作之外的函数。\n\n# 管道操作符 {#sec-管道操作符}\n\n> 参考：[*生信菜鸟团-R tips: R管道的用法*](https://mp.weixin.qq.com/s?__biz=MzUzMTEwODk0Ng==&mid=2247512157&idx=1&sn=47466392bd7c54e17c57b232b29b551b&chksm=fa457560cd32fc76da55c346ef08917343322ecb5d24b3b591d9c65549ed1f0ca10f57f1105d&mpshare=1&scene=1&srcid=0407dIwqephXlKmnMrPSvpRb&sharer_sharetime=1680842848403&sharer_shareid=568f49cb24905bf546294e6985a632bf#rd)\n\nR中有两种管道操作符（pipe operator)，分别是R自带的来自`base`包的`|>`，和来自`magrittr`**包（上级包是**`dplyr`和`tidyverse`**）**的`%>%`。我们可以将管道操作符理解为车间里的流水线，经过前一步加工的产品才能进入后一步进一步加工，其作用是将上一步的结果直接传参给下一步的函数，从而**省略了中间的赋值步骤**，可以大量**减少中间变量**，节省内存。例如：\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# 不使用管道操作服\nx <- rnorm(10)\ny <- sort(x)\nplot(y)\n```\n\n::: {.cell-output-display}\n![](dplyr_files/figure-html/unnamed-chunk-3-1.png){width=672}\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# 管道调用\nrnorm(10) |> sort() |> plot()\n# or\n10 |> rnorm() |> sort() |> plot()\n```\n:::\n\n\n如果`x`, `y`并不会被后面的代码用到的话，那么减少这种中间变量的产生是有利于代码的整洁和降低变量冲突的风险的。\n\n如果不使用管道操作，同时要避免产生中间变量的话就需要嵌套代码，而管道操作则通过一种链式调用的方式去写嵌套调用的代码，使代码更清晰和易于理解。比如：\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# 嵌套调用\nplot(sort(rnorm(10)))\n\n# 管道调用\nrnorm(10) |> sort() |> plot()\n```\n:::\n\n\n很明显管道的调用逻辑要比嵌套调用更加清晰而符合直觉。\n\n::: callout-tip\n-   来自`magrittr`**包**的管道符`%>%`和`base`包的`|>`存在一些语法上的区别，`%>%`的功能更多（见下文）。\n\n-   在一般使用时，如果不需要`%>%`的高级功能，建议直接用从2021年的R 4.1.0开始原生支持的`|>`作为默认管道符。如果需要用到高级功能，或习惯tidyverse包的数据处理语法，则再考虑使用`%>%`。\n\n-   RStudio目前通过快捷键`Command`+`Shift`+`M`默认插入的是`%>%`符号，可以通过在设置中勾选如下选项来让该快捷键默认插入`|>`。\n\n    ![](images/截屏2024-02-02%2015.41.06.png){width=\"573\"}\n:::\n\n## 管道的基本用法\n\n管道的用法就是通过管道符`|>`或`%>%`串联起来前后的两个函数调用，先计算管道符号左边的函数调用，然后将其结果自动传递给管道符号右边函数的**第一个参数（默认）**，然后对运行这个函数，正如上面的例子中提到的一样。**如果不想把值传递给第一个参数，则可以用占位符`_`（适用于**`|>`）或**`.`（适用于`%>%`）的形式指定把前面的运算结果传递给哪个参数**。\n\n比如想在mtcars数据集的车名中寻找所有以“M”开头的车名，则可以通过如下方式寻找：\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmtcars |> rownames() |> grep(\"^M\", x = _)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1]  1  2  8  9 10 11 12 13 14 31\n```\n\n\n:::\n\n```{.r .cell-code}\n#或用%>%形式\nlibrary(magrittr) # 也可以直接加载dplyr或tidyverse包，便于后续调用其他tidyverse函数\nmtcars %>%  rownames() %>%  grep(pattern = \"^M\", x = .)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1]  1  2  8  9 10 11 12 13 14 31\n```\n\n\n:::\n:::\n\n\n解释如下：在`grep`函数那里，由于我们想在车名（这里是行名）中找到符合特定`pattern`的车名位置，因此需要把车名传给`grep`的第二个参数`x`，所以就可以`.`或`_`的形式将前面的值传给`grep`的`x`。\n\n**⚠️注意：传给其他位置的`.`必须是独立的**，不能在一个表达式（函数）中，比如如下情况，我只想寻找前10个车名中以“M”开头的车名位置：\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# 错误 ---------------\nmtcars %>% rownames %>% grep(\"^M\", x = .[1:10])\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning in grep(., \"^M\", x = .[1:10]): argument 'pattern' has length > 1 and\nonly the first element will be used\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1 2\n```\n\n\n:::\n\n```{.r .cell-code}\n# 正确 ---------------\nmtcars[1:10, ] %>% rownames %>% grep(\"^M\", x = .)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]  1  2  8  9 10\n```\n\n\n:::\n:::\n\n\n上面的错误调用中，传递给`grep`的`x`参数的是一个表达式`.[1:10]`，不是一个单独的`.`了，因此失去了调整前面值的位置的作用，它就等价于如下调用：\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# 错误  ---------------\nmtcars %>% rownames %>% grep(\"^M\", x = .[1:10])\n\n# 等价于 --------------\n# 还是把前面的值传递给第一个参数：\nmtcars %>% rownames %>% grep(., \"^M\", x = .[1:10])\n```\n:::\n\n\n## **管道的进阶用法**\n\n我们可以通过“{}”符号包裹后续函数，在“{}”内的代码，可以任意的使用多个占位符`.`去传递管道前的值。还是上面的例子：\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmtcars[1:10, ] %>%  rownames() %>%  grep(\"^M\", x = .) %>% plot()\n\n# 用“{}”的形式 ---------------\nmtcars %>% rownames %>% {grep(\"^M\", x = .[1:10])} %>% plot()\n```\n:::\n\n\n⚠️注意，`|>`不支持“{}”形式：\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# 错误：\nmtcars |> rownames() |> {grep(\"^M\", x = _[1:10])}\n```\n:::\n\n\n这也反映出`base`包`|>`功能的局限性。\n\n本质上“{}”是`magrittr`改写的一个匿名函数，只有唯一的一个参数，也就是`.` ：\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfunction(.) {\n  # any code\n}\n```\n:::\n\n\n比如想要获取mtcars的前5行前5列，然后更改行名和列名后，再返回这个数据框：\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf <- mtcars %>% .[1:5, 1:5] %>%\n  {\n    rownames(.) <- paste0(\"row\", 1:5)\n    colnames(.) <- paste0(\"col\", 1:5)\n    . # <---------- 不要忘了返回这个数据框\n  }\ndf\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     col1 col2 col3 col4 col5\nrow1 21.0    6  160  110 3.90\nrow2 21.0    6  160  110 3.90\nrow3 22.8    4  108   93 3.85\nrow4 21.4    6  258  110 3.08\nrow5 18.7    8  360  175 3.15\n```\n\n\n:::\n:::\n\n\n⚠️注意，在整个“{}”包括的语句中，如果再使用管道要注意这时的占位符.代表的是“{}”内的对象。\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmtcars %>% .[1:5, 1:5] %>%\n  {\n    rownames(.) <- paste0(\"row\", 1:5)\n    colnames(.) <- paste0(\"col\", 1:5)\n    .[1:3, ] %>% cbind(., .) # cbind里面的.不指代{}外面的值\n  }\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     col1 col2 col3 col4 col5 col1 col2 col3 col4 col5\nrow1 21.0    6  160  110 3.90 21.0    6  160  110 3.90\nrow2 21.0    6  160  110 3.90 21.0    6  160  110 3.90\nrow3 22.8    4  108   93 3.85 22.8    4  108   93 3.85\n```\n\n\n:::\n\n```{.r .cell-code}\n# 等价：\nmtcars %>% .[1:5, 1:5] %>%\n  {\n    rownames(.) <- paste0(\"row\", 1:5)\n    colnames(.) <- paste0(\"col\", 1:5)\n    .\n  } %>% \n  .[1:3, ] %>% \n  cbind(., .)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     col1 col2 col3 col4 col5 col1 col2 col3 col4 col5\nrow1 21.0    6  160  110 3.90 21.0    6  160  110 3.90\nrow2 21.0    6  160  110 3.90 21.0    6  160  110 3.90\nrow3 22.8    4  108   93 3.85 22.8    4  108   93 3.85\n```\n\n\n:::\n:::\n\n\n## 特殊管道符\n\n`magrittr`包内除了`%>%`管道符外，还提供了`%$%`、`%<>%`、`%T>%`、`%!>%`，他们的作用简述如下：\n\n### `%$%`\n\n用于传递管道左侧数据的names：\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncolnames(mtcars)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] \"mpg\"  \"cyl\"  \"disp\" \"hp\"   \"drat\" \"wt\"   \"qsec\" \"vs\"   \"am\"   \"gear\"\n[11] \"carb\"\n```\n\n\n:::\n\n```{.r .cell-code}\n# mtcars的每个元素都可以被后面的函数所使用\nmtcars %$% plot(mpg, cyl)\n```\n\n::: {.cell-output-display}\n![](dplyr_files/figure-html/unnamed-chunk-14-1.png){width=672}\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# 等价于\nmtcars %>% {plot(.[,\"mpg\"], .[, \"cyl\"])}\n```\n\n::: {.cell-output-display}\n![](dplyr_files/figure-html/unnamed-chunk-15-1.png){width=672}\n:::\n\n```{.r .cell-code}\nsum(mtcars$mpg, mtcars$cyl)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 840.9\n```\n\n\n:::\n:::\n\n\n### `%<>%`\n\n将管道的结果最终再赋值回最左侧的变量：\n\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(1234)\nx <- rnorm(5)\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] -1.2070657  0.2774292  1.0844412 -2.3456977  0.4291247\n```\n\n\n:::\n\n```{.r .cell-code}\n# x排序后加上10，最后再赋值给x\nx %<>% sort() %>% {. + 10}\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]  7.654302  8.792934 10.277429 10.429125 11.084441\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# 等价于\nx <- x %>% sort() %>% {. + 10}\n```\n:::\n\n\n### `%T>%`\n\n分支管道，传入左侧的值并运算后将原始值而不是运算结果传递给后续管道。这在多个管道中间使用`print()`、`plot()`或`summary()`这些函数返回信息时非常有用。\n\n\n::: {.cell}\n\n```{.r .cell-code}\n1:5 %>% plot() %>% sum() # 传递给sum()的是前面所有函数的运算结果，由于plot()不返回任何数值，所以sum()的结果为0\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0\n```\n\n\n:::\n\n```{.r .cell-code}\n1:5 %T>% plot() %>% sum() # 传递给sum()的是1:5\n```\n\n::: {.cell-output-display}\n![](dplyr_files/figure-html/unnamed-chunk-18-1.png){width=672}\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 15\n```\n\n\n:::\n\n```{.r .cell-code}\n# 另一个例子\nrnorm(200) %>%\n  matrix(ncol = 2) %T>%\n  plot %>% \n  colSums() # 传递给colSums()的是“rnorm(200) %>% matrix(ncol = 2)”\n```\n\n::: {.cell-output-display}\n![](dplyr_files/figure-html/unnamed-chunk-18-2.png){width=672}\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] -15.23708   7.82692\n```\n\n\n:::\n:::\n\n\n------------------------------------------------------------------------\n\n# 对行的操作\n\n## `filter()`\n\n![](images/截屏2024-02-02%2017.29.00.png){width=\"173\"}\n\n用于提取满足某（些）条件的行，基本等同于[`subset()`](/r_basic/basic_data_function.qmd#sec-筛选数据)。\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# 查找所有晚点 120 分钟（两小时）以上起飞的航班：\nfilter(flights, dep_delay > 120)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 9,723 × 19\n    year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n   <int> <int> <int>    <int>          <int>     <dbl>    <int>          <int>\n 1  2013     1     1      848           1835       853     1001           1950\n 2  2013     1     1      957            733       144     1056            853\n 3  2013     1     1     1114            900       134     1447           1222\n 4  2013     1     1     1540           1338       122     2020           1825\n 5  2013     1     1     1815           1325       290     2120           1542\n 6  2013     1     1     1842           1422       260     1958           1535\n 7  2013     1     1     1856           1645       131     2212           2005\n 8  2013     1     1     1934           1725       129     2126           1855\n 9  2013     1     1     1938           1703       155     2109           1823\n10  2013     1     1     1942           1705       157     2124           1830\n# ℹ 9,713 more rows\n# ℹ 11 more variables: arr_delay <dbl>, carrier <chr>, flight <int>,\n#   tailnum <chr>, origin <chr>, dest <chr>, air_time <dbl>, distance <dbl>,\n#   hour <dbl>, minute <dbl>, time_hour <dttm>\n```\n\n\n:::\n\n```{.r .cell-code}\n# 查找一月或二月起飞的航班\nfilter(flights, month %in% c(1, 2))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 51,955 × 19\n    year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n   <int> <int> <int>    <int>          <int>     <dbl>    <int>          <int>\n 1  2013     1     1      517            515         2      830            819\n 2  2013     1     1      533            529         4      850            830\n 3  2013     1     1      542            540         2      923            850\n 4  2013     1     1      544            545        -1     1004           1022\n 5  2013     1     1      554            600        -6      812            837\n 6  2013     1     1      554            558        -4      740            728\n 7  2013     1     1      555            600        -5      913            854\n 8  2013     1     1      557            600        -3      709            723\n 9  2013     1     1      557            600        -3      838            846\n10  2013     1     1      558            600        -2      753            745\n# ℹ 51,945 more rows\n# ℹ 11 more variables: arr_delay <dbl>, carrier <chr>, flight <int>,\n#   tailnum <chr>, origin <chr>, dest <chr>, air_time <dbl>, distance <dbl>,\n#   hour <dbl>, minute <dbl>, time_hour <dttm>\n```\n\n\n:::\n:::\n\n\n## `arrange()`\n\n排序，以某列为依据对行进行排序（在前面的[数据处理基本函数](/r_basic/basic_data_function.qmd#sec-排序)一章中已涉及该函数）。对应的功能在`base`包中是`order()`函数。如果提供的列名不止一个，则依次根据提供的列的顺序对数据进行排序。例如，下面的代码按航班出发时间排序，出发时间分布在四列中。我们首先得到最早的年份，然后在一年内得到最早的月份，依此类推。\n\n\n::: {.cell}\n\n```{.r .cell-code}\narrange(flights, year, month, day, dep_time)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 336,776 × 19\n    year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n   <int> <int> <int>    <int>          <int>     <dbl>    <int>          <int>\n 1  2013     1     1      517            515         2      830            819\n 2  2013     1     1      533            529         4      850            830\n 3  2013     1     1      542            540         2      923            850\n 4  2013     1     1      544            545        -1     1004           1022\n 5  2013     1     1      554            600        -6      812            837\n 6  2013     1     1      554            558        -4      740            728\n 7  2013     1     1      555            600        -5      913            854\n 8  2013     1     1      557            600        -3      709            723\n 9  2013     1     1      557            600        -3      838            846\n10  2013     1     1      558            600        -2      753            745\n# ℹ 336,766 more rows\n# ℹ 11 more variables: arr_delay <dbl>, carrier <chr>, flight <int>,\n#   tailnum <chr>, origin <chr>, dest <chr>, air_time <dbl>, distance <dbl>,\n#   hour <dbl>, minute <dbl>, time_hour <dttm>\n```\n\n\n:::\n:::\n\n\n可以加上`desc()`实现降序排列：\n\n\n::: {.cell}\n\n```{.r .cell-code}\narrange(flights, desc(dep_delay))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 336,776 × 19\n    year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n   <int> <int> <int>    <int>          <int>     <dbl>    <int>          <int>\n 1  2013     1     9      641            900      1301     1242           1530\n 2  2013     6    15     1432           1935      1137     1607           2120\n 3  2013     1    10     1121           1635      1126     1239           1810\n 4  2013     9    20     1139           1845      1014     1457           2210\n 5  2013     7    22      845           1600      1005     1044           1815\n 6  2013     4    10     1100           1900       960     1342           2211\n 7  2013     3    17     2321            810       911      135           1020\n 8  2013     6    27      959           1900       899     1236           2226\n 9  2013     7    22     2257            759       898      121           1026\n10  2013    12     5      756           1700       896     1058           2020\n# ℹ 336,766 more rows\n# ℹ 11 more variables: arr_delay <dbl>, carrier <chr>, flight <int>,\n#   tailnum <chr>, origin <chr>, dest <chr>, air_time <dbl>, distance <dbl>,\n#   hour <dbl>, minute <dbl>, time_hour <dttm>\n```\n\n\n:::\n:::\n\n\n## `distinct()`\n\n![](images/截屏2024-02-02%2017.29.29.png){width=\"212\"}\n\n查找数据集中所有唯一的行。\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# 移除所有完全相同的行\ndistinct(flights)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 336,776 × 19\n    year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n   <int> <int> <int>    <int>          <int>     <dbl>    <int>          <int>\n 1  2013     1     1      517            515         2      830            819\n 2  2013     1     1      533            529         4      850            830\n 3  2013     1     1      542            540         2      923            850\n 4  2013     1     1      544            545        -1     1004           1022\n 5  2013     1     1      554            600        -6      812            837\n 6  2013     1     1      554            558        -4      740            728\n 7  2013     1     1      555            600        -5      913            854\n 8  2013     1     1      557            600        -3      709            723\n 9  2013     1     1      557            600        -3      838            846\n10  2013     1     1      558            600        -2      753            745\n# ℹ 336,766 more rows\n# ℹ 11 more variables: arr_delay <dbl>, carrier <chr>, flight <int>,\n#   tailnum <chr>, origin <chr>, dest <chr>, air_time <dbl>, distance <dbl>,\n#   hour <dbl>, minute <dbl>, time_hour <dttm>\n```\n\n\n:::\n\n```{.r .cell-code}\n# 查找所有唯一的出发地和目的地配对\ndistinct(flights, origin, dest)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 224 × 2\n   origin dest \n   <chr>  <chr>\n 1 EWR    IAH  \n 2 LGA    IAH  \n 3 JFK    MIA  \n 4 JFK    BQN  \n 5 LGA    ATL  \n 6 EWR    ORD  \n 7 EWR    FLL  \n 8 LGA    IAD  \n 9 JFK    MCO  \n10 LGA    ORD  \n# ℹ 214 more rows\n```\n\n\n:::\n:::\n\n\n可以看到，如果根据某列或某几列为依据来查找非重复值，那么默认只输出这几列，我们可以通过加入`.keep_all = TRUE`参数来保留其他列。`.`表示 `.keep_all` 是函数的一个参数，而不是另一个变量的名称。\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndistinct(flights, origin, dest, .keep_all = TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 224 × 19\n    year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n   <int> <int> <int>    <int>          <int>     <dbl>    <int>          <int>\n 1  2013     1     1      517            515         2      830            819\n 2  2013     1     1      533            529         4      850            830\n 3  2013     1     1      542            540         2      923            850\n 4  2013     1     1      544            545        -1     1004           1022\n 5  2013     1     1      554            600        -6      812            837\n 6  2013     1     1      554            558        -4      740            728\n 7  2013     1     1      555            600        -5      913            854\n 8  2013     1     1      557            600        -3      709            723\n 9  2013     1     1      557            600        -3      838            846\n10  2013     1     1      558            600        -2      753            745\n# ℹ 214 more rows\n# ℹ 11 more variables: arr_delay <dbl>, carrier <chr>, flight <int>,\n#   tailnum <chr>, origin <chr>, dest <chr>, air_time <dbl>, distance <dbl>,\n#   hour <dbl>, minute <dbl>, time_hour <dttm>\n```\n\n\n:::\n:::\n\n\n可以发现所有这些不同的航班都是在 1 月 1 日，这绝非巧合：distinct() 会在数据集中找到唯一值第一次出现的那一行，并舍弃其他行。\n\n如果要得到每种出发地和目的地配对出现的次数，可以将 `distinct()` 换成 `count()`，并可使用 `sort = TRUE` 参数按出现次数降序排列。`count()`同样来自`dplyr`包，用于快速统计一个或多个变量的唯一值的出现次数。\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncount(flights, origin, dest, sort = TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 224 × 3\n   origin dest      n\n   <chr>  <chr> <int>\n 1 JFK    LAX   11262\n 2 LGA    ATL   10263\n 3 LGA    ORD    8857\n 4 JFK    SFO    8204\n 5 LGA    CLT    6168\n 6 EWR    ORD    6100\n 7 JFK    BOS    5898\n 8 LGA    MIA    5781\n 9 JFK    MCO    5464\n10 EWR    BOS    5327\n# ℹ 214 more rows\n```\n\n\n:::\n:::\n\n\n# 对列的操作\n\n## `mutate()` {#sec-mutate}\n\n![](images/截屏2024-02-02%2017.31.09.png){width=\"199\"}\n\n`mutate()`的作用是根据现有列计算并添加新列。\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# 计算延误航班在空中停留的时间（gain）以及平均速度（speed，英里/小时）：\nmutate(\n  flights,\n  gain = dep_delay - arr_delay,\n  speed = distance / air_time * 60\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 336,776 × 21\n    year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n   <int> <int> <int>    <int>          <int>     <dbl>    <int>          <int>\n 1  2013     1     1      517            515         2      830            819\n 2  2013     1     1      533            529         4      850            830\n 3  2013     1     1      542            540         2      923            850\n 4  2013     1     1      544            545        -1     1004           1022\n 5  2013     1     1      554            600        -6      812            837\n 6  2013     1     1      554            558        -4      740            728\n 7  2013     1     1      555            600        -5      913            854\n 8  2013     1     1      557            600        -3      709            723\n 9  2013     1     1      557            600        -3      838            846\n10  2013     1     1      558            600        -2      753            745\n# ℹ 336,766 more rows\n# ℹ 13 more variables: arr_delay <dbl>, carrier <chr>, flight <int>,\n#   tailnum <chr>, origin <chr>, dest <chr>, air_time <dbl>, distance <dbl>,\n#   hour <dbl>, minute <dbl>, time_hour <dttm>, gain <dbl>, speed <dbl>\n```\n\n\n:::\n:::\n\n\n默认情况下，`mutate()` 会在数据集的最右侧添加计算后的新列，因此很难看到这里发生了什么。我们可以使用 `.before` 参数将变量添加到数据集的左侧：\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmutate(\n  flights,\n  gain = dep_delay - arr_delay,\n  speed = distance / air_time * 60,\n  .before = 1 # 添加到第一列\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 336,776 × 21\n    gain speed  year month   day dep_time sched_dep_time dep_delay arr_time\n   <dbl> <dbl> <int> <int> <int>    <int>          <int>     <dbl>    <int>\n 1    -9  370.  2013     1     1      517            515         2      830\n 2   -16  374.  2013     1     1      533            529         4      850\n 3   -31  408.  2013     1     1      542            540         2      923\n 4    17  517.  2013     1     1      544            545        -1     1004\n 5    19  394.  2013     1     1      554            600        -6      812\n 6   -16  288.  2013     1     1      554            558        -4      740\n 7   -24  404.  2013     1     1      555            600        -5      913\n 8    11  259.  2013     1     1      557            600        -3      709\n 9     5  405.  2013     1     1      557            600        -3      838\n10   -10  319.  2013     1     1      558            600        -2      753\n# ℹ 336,766 more rows\n# ℹ 12 more variables: sched_arr_time <int>, arr_delay <dbl>, carrier <chr>,\n#   flight <int>, tailnum <chr>, origin <chr>, dest <chr>, air_time <dbl>,\n#   distance <dbl>, hour <dbl>, minute <dbl>, time_hour <dttm>\n```\n\n\n:::\n:::\n\n\n也可以使用 `.after` 指定新变量应该在哪个变量后添加，在 `.before` 和 `.after` 中，都可以使用变量名和列数两种方法指定新变量出现的位置。例如，我们可以在 “day” 之后添加新变量：\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmutate(\n  flights,\n  gain = dep_delay - arr_delay,\n  speed = distance / air_time * 60,\n  .after = day # 在 “day” 之后添加新变量\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 336,776 × 21\n    year month   day  gain speed dep_time sched_dep_time dep_delay arr_time\n   <int> <int> <int> <dbl> <dbl>    <int>          <int>     <dbl>    <int>\n 1  2013     1     1    -9  370.      517            515         2      830\n 2  2013     1     1   -16  374.      533            529         4      850\n 3  2013     1     1   -31  408.      542            540         2      923\n 4  2013     1     1    17  517.      544            545        -1     1004\n 5  2013     1     1    19  394.      554            600        -6      812\n 6  2013     1     1   -16  288.      554            558        -4      740\n 7  2013     1     1   -24  404.      555            600        -5      913\n 8  2013     1     1    11  259.      557            600        -3      709\n 9  2013     1     1     5  405.      557            600        -3      838\n10  2013     1     1   -10  319.      558            600        -2      753\n# ℹ 336,766 more rows\n# ℹ 12 more variables: sched_arr_time <int>, arr_delay <dbl>, carrier <chr>,\n#   flight <int>, tailnum <chr>, origin <chr>, dest <chr>, air_time <dbl>,\n#   distance <dbl>, hour <dbl>, minute <dbl>, time_hour <dttm>\n```\n\n\n:::\n:::\n\n\n另外，也可以使用 `.keep` 参数来控制在计算新变量后哪些变量会被保留:\n\n-   `.keep = \"all\"`：默认。保留所有变量\n\n-   `.keep = \"used\"`：保留用于计算新变量的旧变量。这可以用于检查我们的新变量是否计算正确，因为它和原始变量一起展示。\n\n-   `.keep = \"unused\"`：保留其他不用于计算新变量的旧变量。\n\n例如，下面的输出将只包含旧变量 “dep_delay”、“arr_delay”、“distance”、“air_time”，以及新变量“gain”、“speed”：\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmutate(\n  flights,\n  gain = dep_delay - arr_delay,\n  speed = distance / air_time * 60,\n  .keep = \"used\"\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 336,776 × 6\n   dep_delay arr_delay air_time distance  gain speed\n       <dbl>     <dbl>    <dbl>    <dbl> <dbl> <dbl>\n 1         2        11      227     1400    -9  370.\n 2         4        20      227     1416   -16  374.\n 3         2        33      160     1089   -31  408.\n 4        -1       -18      183     1576    17  517.\n 5        -6       -25      116      762    19  394.\n 6        -4        12      150      719   -16  288.\n 7        -5        19      158     1065   -24  404.\n 8        -3       -14       53      229    11  259.\n 9        -3        -8      140      944     5  405.\n10        -2         8      138      733   -10  319.\n# ℹ 336,766 more rows\n```\n\n\n:::\n:::\n\n\n## `select()` {#sec-select}\n\n![](images/截屏2024-02-02%2017.30.02.png){width=\"201\"}\n\n选择并输出某几列。\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# 根据列名选择某几列\nselect(flights, year, month, day)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 336,776 × 3\n    year month   day\n   <int> <int> <int>\n 1  2013     1     1\n 2  2013     1     1\n 3  2013     1     1\n 4  2013     1     1\n 5  2013     1     1\n 6  2013     1     1\n 7  2013     1     1\n 8  2013     1     1\n 9  2013     1     1\n10  2013     1     1\n# ℹ 336,766 more rows\n```\n\n\n:::\n\n```{.r .cell-code}\n# 选择“year”和“day”及其之间的所有列\nselect(flights, year:day)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 336,776 × 3\n    year month   day\n   <int> <int> <int>\n 1  2013     1     1\n 2  2013     1     1\n 3  2013     1     1\n 4  2013     1     1\n 5  2013     1     1\n 6  2013     1     1\n 7  2013     1     1\n 8  2013     1     1\n 9  2013     1     1\n10  2013     1     1\n# ℹ 336,766 more rows\n```\n\n\n:::\n\n```{.r .cell-code}\n# 选择不在“year”和“day”及其之间的所有列\nselect(flights, !year:day)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 336,776 × 16\n   dep_time sched_dep_time dep_delay arr_time sched_arr_time arr_delay carrier\n      <int>          <int>     <dbl>    <int>          <int>     <dbl> <chr>  \n 1      517            515         2      830            819        11 UA     \n 2      533            529         4      850            830        20 UA     \n 3      542            540         2      923            850        33 AA     \n 4      544            545        -1     1004           1022       -18 B6     \n 5      554            600        -6      812            837       -25 DL     \n 6      554            558        -4      740            728        12 UA     \n 7      555            600        -5      913            854        19 B6     \n 8      557            600        -3      709            723       -14 EV     \n 9      557            600        -3      838            846        -8 B6     \n10      558            600        -2      753            745         8 AA     \n# ℹ 336,766 more rows\n# ℹ 9 more variables: flight <int>, tailnum <chr>, origin <chr>, dest <chr>,\n#   air_time <dbl>, distance <dbl>, hour <dbl>, minute <dbl>, time_hour <dttm>\n```\n\n\n:::\n\n```{.r .cell-code}\n# 选择所有字符型的列\nselect(flights, where(is.character))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 336,776 × 4\n   carrier tailnum origin dest \n   <chr>   <chr>   <chr>  <chr>\n 1 UA      N14228  EWR    IAH  \n 2 UA      N24211  LGA    IAH  \n 3 AA      N619AA  JFK    MIA  \n 4 B6      N804JB  JFK    BQN  \n 5 DL      N668DN  LGA    ATL  \n 6 UA      N39463  EWR    ORD  \n 7 B6      N516JB  EWR    FLL  \n 8 EV      N829AS  LGA    IAD  \n 9 B6      N593JB  JFK    MCO  \n10 AA      N3ALAA  LGA    ORD  \n# ℹ 336,766 more rows\n```\n\n\n:::\n:::\n\n\n在select()内有许多经常可以组合使用的函数：\n\n-   `starts_with(\"abc\")`: 以特定字符开头的列名.\n\n-   `ends_with(\"xyz\")`: 以特定字符结尾的列名.\n\n-   `contains(\"ijk\")`: 包含特定字符的列名.\n\n-   `num_range(\"x\", 1:3)`: 列名`x1`, `x2` 和 `x3`.\n\n可以在选择变量的同时使用 `=` 对这些变量进行重命名。新变量名在 `=` 的左侧，旧变量名在右侧（`new_name = old_name`）：\n\n\n::: {.cell}\n\n```{.r .cell-code}\nselect(flights, tail_num = tailnum)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 336,776 × 1\n   tail_num\n   <chr>   \n 1 N14228  \n 2 N24211  \n 3 N619AA  \n 4 N804JB  \n 5 N668DN  \n 6 N39463  \n 7 N516JB  \n 8 N829AS  \n 9 N593JB  \n10 N3ALAA  \n# ℹ 336,766 more rows\n```\n\n\n:::\n:::\n\n\n## `rename()` {#sec-rename}\n\n重命名列。新变量名在 `=` 的左侧，旧变量名在右侧（`new_name = old_name`）。\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrename(\n  flights, \n  years = year, \n  months = month\n  )\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 336,776 × 19\n   years months   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n   <int>  <int> <int>    <int>          <int>     <dbl>    <int>          <int>\n 1  2013      1     1      517            515         2      830            819\n 2  2013      1     1      533            529         4      850            830\n 3  2013      1     1      542            540         2      923            850\n 4  2013      1     1      544            545        -1     1004           1022\n 5  2013      1     1      554            600        -6      812            837\n 6  2013      1     1      554            558        -4      740            728\n 7  2013      1     1      555            600        -5      913            854\n 8  2013      1     1      557            600        -3      709            723\n 9  2013      1     1      557            600        -3      838            846\n10  2013      1     1      558            600        -2      753            745\n# ℹ 336,766 more rows\n# ℹ 11 more variables: arr_delay <dbl>, carrier <chr>, flight <int>,\n#   tailnum <chr>, origin <chr>, dest <chr>, air_time <dbl>, distance <dbl>,\n#   hour <dbl>, minute <dbl>, time_hour <dttm>\n```\n\n\n:::\n:::\n\n\n::: callout-caution\n和其他`dplyr`中的函数一样，`rename`不会对原始数据进行修改，因此需要将`rename`后的数据重新赋值给新的对象或覆盖原来的对象以应用对变量名的修改。\n:::\n\n如果我们有一个提供了重命名依据的字符串向量，那么可以通过`all_of()`来基于这个字符串向量对数据集的列进行重命名：\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlookup <- c(\n  years = \"year\", \n  months = \"month\"\n  )\nrename(flights, all_of(lookup))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 336,776 × 19\n   years months   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n   <int>  <int> <int>    <int>          <int>     <dbl>    <int>          <int>\n 1  2013      1     1      517            515         2      830            819\n 2  2013      1     1      533            529         4      850            830\n 3  2013      1     1      542            540         2      923            850\n 4  2013      1     1      544            545        -1     1004           1022\n 5  2013      1     1      554            600        -6      812            837\n 6  2013      1     1      554            558        -4      740            728\n 7  2013      1     1      555            600        -5      913            854\n 8  2013      1     1      557            600        -3      709            723\n 9  2013      1     1      557            600        -3      838            846\n10  2013      1     1      558            600        -2      753            745\n# ℹ 336,766 more rows\n# ℹ 11 more variables: arr_delay <dbl>, carrier <chr>, flight <int>,\n#   tailnum <chr>, origin <chr>, dest <chr>, air_time <dbl>, distance <dbl>,\n#   hour <dbl>, minute <dbl>, time_hour <dttm>\n```\n\n\n:::\n:::\n\n\n如果提供重命名依据的字符串向量中有的变量是原数据集中不存在的，那么可以用 `any_of()`代替 `all_of()` 来实现：\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlookup <- c(\n  years = \"year\", \n  months = \"month\",\n  new = \"unknown\"\n  )\nrename(flights, any_of(lookup))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 336,776 × 19\n   years months   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n   <int>  <int> <int>    <int>          <int>     <dbl>    <int>          <int>\n 1  2013      1     1      517            515         2      830            819\n 2  2013      1     1      533            529         4      850            830\n 3  2013      1     1      542            540         2      923            850\n 4  2013      1     1      544            545        -1     1004           1022\n 5  2013      1     1      554            600        -6      812            837\n 6  2013      1     1      554            558        -4      740            728\n 7  2013      1     1      555            600        -5      913            854\n 8  2013      1     1      557            600        -3      709            723\n 9  2013      1     1      557            600        -3      838            846\n10  2013      1     1      558            600        -2      753            745\n# ℹ 336,766 more rows\n# ℹ 11 more variables: arr_delay <dbl>, carrier <chr>, flight <int>,\n#   tailnum <chr>, origin <chr>, dest <chr>, air_time <dbl>, distance <dbl>,\n#   hour <dbl>, minute <dbl>, time_hour <dttm>\n```\n\n\n:::\n:::\n\n\n### `rename_with()`\n\n根据函数批量重命名列。\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# 将所有列名变为大写\nrename_with(flights, toupper)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 336,776 × 19\n    YEAR MONTH   DAY DEP_TIME SCHED_DEP_TIME DEP_DELAY ARR_TIME SCHED_ARR_TIME\n   <int> <int> <int>    <int>          <int>     <dbl>    <int>          <int>\n 1  2013     1     1      517            515         2      830            819\n 2  2013     1     1      533            529         4      850            830\n 3  2013     1     1      542            540         2      923            850\n 4  2013     1     1      544            545        -1     1004           1022\n 5  2013     1     1      554            600        -6      812            837\n 6  2013     1     1      554            558        -4      740            728\n 7  2013     1     1      555            600        -5      913            854\n 8  2013     1     1      557            600        -3      709            723\n 9  2013     1     1      557            600        -3      838            846\n10  2013     1     1      558            600        -2      753            745\n# ℹ 336,766 more rows\n# ℹ 11 more variables: ARR_DELAY <dbl>, CARRIER <chr>, FLIGHT <int>,\n#   TAILNUM <chr>, ORIGIN <chr>, DEST <chr>, AIR_TIME <dbl>, DISTANCE <dbl>,\n#   HOUR <dbl>, MINUTE <dbl>, TIME_HOUR <dttm>\n```\n\n\n:::\n\n```{.r .cell-code}\n# 将所有以“dep_\"开头的列名转换为大写\nrename_with(flights, toupper, .cols = starts_with(\"dep_\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 336,776 × 19\n    year month   day DEP_TIME sched_dep_time DEP_DELAY arr_time sched_arr_time\n   <int> <int> <int>    <int>          <int>     <dbl>    <int>          <int>\n 1  2013     1     1      517            515         2      830            819\n 2  2013     1     1      533            529         4      850            830\n 3  2013     1     1      542            540         2      923            850\n 4  2013     1     1      544            545        -1     1004           1022\n 5  2013     1     1      554            600        -6      812            837\n 6  2013     1     1      554            558        -4      740            728\n 7  2013     1     1      555            600        -5      913            854\n 8  2013     1     1      557            600        -3      709            723\n 9  2013     1     1      557            600        -3      838            846\n10  2013     1     1      558            600        -2      753            745\n# ℹ 336,766 more rows\n# ℹ 11 more variables: arr_delay <dbl>, carrier <chr>, flight <int>,\n#   tailnum <chr>, origin <chr>, dest <chr>, air_time <dbl>, distance <dbl>,\n#   hour <dbl>, minute <dbl>, time_hour <dttm>\n```\n\n\n:::\n\n```{.r .cell-code}\n# 将列名中所有的\"_\"替换成“.”，并将所有列名转换成大写\nrename_with(\n  flights, \n  function(x) {\n    gsub(pattern = \"_\", replacement = \".\", x = x) %>% \n    toupper()\n}\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 336,776 × 19\n    YEAR MONTH   DAY DEP.TIME SCHED.DEP.TIME DEP.DELAY ARR.TIME SCHED.ARR.TIME\n   <int> <int> <int>    <int>          <int>     <dbl>    <int>          <int>\n 1  2013     1     1      517            515         2      830            819\n 2  2013     1     1      533            529         4      850            830\n 3  2013     1     1      542            540         2      923            850\n 4  2013     1     1      544            545        -1     1004           1022\n 5  2013     1     1      554            600        -6      812            837\n 6  2013     1     1      554            558        -4      740            728\n 7  2013     1     1      555            600        -5      913            854\n 8  2013     1     1      557            600        -3      709            723\n 9  2013     1     1      557            600        -3      838            846\n10  2013     1     1      558            600        -2      753            745\n# ℹ 336,766 more rows\n# ℹ 11 more variables: ARR.DELAY <dbl>, CARRIER <chr>, FLIGHT <int>,\n#   TAILNUM <chr>, ORIGIN <chr>, DEST <chr>, AIR.TIME <dbl>, DISTANCE <dbl>,\n#   HOUR <dbl>, MINUTE <dbl>, TIME.HOUR <dttm>\n```\n\n\n:::\n\n```{.r .cell-code}\n# 匿名函数形式\nrename_with(flights, ~ gsub(pattern = \"_\", replacement = \".\", x= .x) %>% toupper())\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 336,776 × 19\n    YEAR MONTH   DAY DEP.TIME SCHED.DEP.TIME DEP.DELAY ARR.TIME SCHED.ARR.TIME\n   <int> <int> <int>    <int>          <int>     <dbl>    <int>          <int>\n 1  2013     1     1      517            515         2      830            819\n 2  2013     1     1      533            529         4      850            830\n 3  2013     1     1      542            540         2      923            850\n 4  2013     1     1      544            545        -1     1004           1022\n 5  2013     1     1      554            600        -6      812            837\n 6  2013     1     1      554            558        -4      740            728\n 7  2013     1     1      555            600        -5      913            854\n 8  2013     1     1      557            600        -3      709            723\n 9  2013     1     1      557            600        -3      838            846\n10  2013     1     1      558            600        -2      753            745\n# ℹ 336,766 more rows\n# ℹ 11 more variables: ARR.DELAY <dbl>, CARRIER <chr>, FLIGHT <int>,\n#   TAILNUM <chr>, ORIGIN <chr>, DEST <chr>, AIR.TIME <dbl>, DISTANCE <dbl>,\n#   HOUR <dbl>, MINUTE <dbl>, TIME.HOUR <dttm>\n```\n\n\n:::\n:::\n\n\n## `relocate()`\n\n调整列的顺序。\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# 将“day”和“year”放到最前面\nrelocate(flights, day, year)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 336,776 × 19\n     day  year month dep_time sched_dep_time dep_delay arr_time sched_arr_time\n   <int> <int> <int>    <int>          <int>     <dbl>    <int>          <int>\n 1     1  2013     1      517            515         2      830            819\n 2     1  2013     1      533            529         4      850            830\n 3     1  2013     1      542            540         2      923            850\n 4     1  2013     1      544            545        -1     1004           1022\n 5     1  2013     1      554            600        -6      812            837\n 6     1  2013     1      554            558        -4      740            728\n 7     1  2013     1      555            600        -5      913            854\n 8     1  2013     1      557            600        -3      709            723\n 9     1  2013     1      557            600        -3      838            846\n10     1  2013     1      558            600        -2      753            745\n# ℹ 336,766 more rows\n# ℹ 11 more variables: arr_delay <dbl>, carrier <chr>, flight <int>,\n#   tailnum <chr>, origin <chr>, dest <chr>, air_time <dbl>, distance <dbl>,\n#   hour <dbl>, minute <dbl>, time_hour <dttm>\n```\n\n\n:::\n:::\n\n\n也可以和上面的\\[mutate()\\]一样通过`.before` 和 `.after` 参数指定放置位置：\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# 将“year”和“dep_time”及其之间的列放到“sched_dep_time”之后\nrelocate(flights, year:dep_time, .after = sched_dep_time)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 336,776 × 19\n   sched_dep_time  year month   day dep_time dep_delay arr_time sched_arr_time\n            <int> <int> <int> <int>    <int>     <dbl>    <int>          <int>\n 1            515  2013     1     1      517         2      830            819\n 2            529  2013     1     1      533         4      850            830\n 3            540  2013     1     1      542         2      923            850\n 4            545  2013     1     1      544        -1     1004           1022\n 5            600  2013     1     1      554        -6      812            837\n 6            558  2013     1     1      554        -4      740            728\n 7            600  2013     1     1      555        -5      913            854\n 8            600  2013     1     1      557        -3      709            723\n 9            600  2013     1     1      557        -3      838            846\n10            600  2013     1     1      558        -2      753            745\n# ℹ 336,766 more rows\n# ℹ 11 more variables: arr_delay <dbl>, carrier <chr>, flight <int>,\n#   tailnum <chr>, origin <chr>, dest <chr>, air_time <dbl>, distance <dbl>,\n#   hour <dbl>, minute <dbl>, time_hour <dttm>\n```\n\n\n:::\n\n```{.r .cell-code}\n# 将所有以“dep_”开头的列放到“sched_dep_time”之前\nrelocate(flights, starts_with(\"dep_\"), .before = sched_dep_time)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 336,776 × 19\n    year month   day dep_time dep_delay sched_dep_time arr_time sched_arr_time\n   <int> <int> <int>    <int>     <dbl>          <int>    <int>          <int>\n 1  2013     1     1      517         2            515      830            819\n 2  2013     1     1      533         4            529      850            830\n 3  2013     1     1      542         2            540      923            850\n 4  2013     1     1      544        -1            545     1004           1022\n 5  2013     1     1      554        -6            600      812            837\n 6  2013     1     1      554        -4            558      740            728\n 7  2013     1     1      555        -5            600      913            854\n 8  2013     1     1      557        -3            600      709            723\n 9  2013     1     1      557        -3            600      838            846\n10  2013     1     1      558        -2            600      753            745\n# ℹ 336,766 more rows\n# ℹ 11 more variables: arr_delay <dbl>, carrier <chr>, flight <int>,\n#   tailnum <chr>, origin <chr>, dest <chr>, air_time <dbl>, distance <dbl>,\n#   hour <dbl>, minute <dbl>, time_hour <dttm>\n```\n\n\n:::\n:::\n\n\n# 分组统计\n\n## `group_by()`\n\n![](images/截屏2024-02-02%2017.26.52.png){width=\"240\"}\n\n根据某一列或几列将数据分组，便于后续的分组统计/运算。\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngroup_by(flights, month)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 336,776 × 19\n# Groups:   month [12]\n    year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time\n   <int> <int> <int>    <int>          <int>     <dbl>    <int>          <int>\n 1  2013     1     1      517            515         2      830            819\n 2  2013     1     1      533            529         4      850            830\n 3  2013     1     1      542            540         2      923            850\n 4  2013     1     1      544            545        -1     1004           1022\n 5  2013     1     1      554            600        -6      812            837\n 6  2013     1     1      554            558        -4      740            728\n 7  2013     1     1      555            600        -5      913            854\n 8  2013     1     1      557            600        -3      709            723\n 9  2013     1     1      557            600        -3      838            846\n10  2013     1     1      558            600        -2      753            745\n# ℹ 336,766 more rows\n# ℹ 11 more variables: arr_delay <dbl>, carrier <chr>, flight <int>,\n#   tailnum <chr>, origin <chr>, dest <chr>, air_time <dbl>, distance <dbl>,\n#   hour <dbl>, minute <dbl>, time_hour <dttm>\n```\n\n\n:::\n:::\n\n\n`group_by()`本身不会改变数据，除了在输出结果中出现了`# Groups: month [12]`，提示我们该数据集进行了分组。这意味着随后的操作将按不同的月份分别进行。`group_by()`向数据添加了这个分组特性（称为类），从而改变了接下来对数据应用的函数的行为。\n\n## `summarize()`\n\n分组汇总数据。根据某列或某几列的数据汇总一个包含了统计数据的新表。\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# 计算每月的平均起飞延误时间\ngroup_by(flights, month) |> \n  summarise(avg_delay = mean(dep_delay))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 12 × 2\n   month avg_delay\n   <int>     <dbl>\n 1     1        NA\n 2     2        NA\n 3     3        NA\n 4     4        NA\n 5     5        NA\n 6     6        NA\n 7     7        NA\n 8     8        NA\n 9     9        NA\n10    10        NA\n11    11        NA\n12    12        NA\n```\n\n\n:::\n:::\n\n\n可以看到，这里出现了问题，所有的结果都是“NA”。这是因为一些航班在延误时间（dep_delay）列中有缺失数据，所以当我们计算包括这些缺失值的平均值时，得到了一个NA结果。所以需要在mean()中设置参数 `na.rm = TRUE` 来忽略所有缺失值：\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# 计算每月的平均起飞延误时间\ngroup_by(flights, month) |> \n  summarise(avg_delay = mean(dep_delay, na.rm = TRUE))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 12 × 2\n   month avg_delay\n   <int>     <dbl>\n 1     1     10.0 \n 2     2     10.8 \n 3     3     13.2 \n 4     4     13.9 \n 5     5     13.0 \n 6     6     20.8 \n 7     7     21.7 \n 8     8     12.6 \n 9     9      6.72\n10    10      6.24\n11    11      5.44\n12    12     16.6 \n```\n\n\n:::\n:::\n\n\n可以在单次对summarize()的调用中创建任意数量的数据汇总。但其中一个非常有用的汇总函数是`n()`，它返回每个组中行数：\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# 计算每月的平均起飞延误时间和延误航班数量\nflights |> \n  group_by(month) |> \n  summarize(\n    avg_delay = mean(dep_delay, na.rm = TRUE), \n    n = n()\n  )\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 12 × 3\n   month avg_delay     n\n   <int>     <dbl> <int>\n 1     1     10.0  27004\n 2     2     10.8  24951\n 3     3     13.2  28834\n 4     4     13.9  28330\n 5     5     13.0  28796\n 6     6     20.8  28243\n 7     7     21.7  29425\n 8     8     12.6  29327\n 9     9      6.72 27574\n10    10      6.24 28889\n11    11      5.44 27268\n12    12     16.6  28135\n```\n\n\n:::\n:::\n\n\n## `slice_`系列函数\n\n分组提取数据。\n\n-   `df |> slice_head(n = 1)` 从每一组中取前n行数据.\n\n-   `df |> slice_tail(n = 1)` 从每一组中取后n行数据.\n\n-   `df |> slice_min(x, n = 1)` 从每一组中取`x`列的值最小的n行数据.\n\n-   `df |> slice_max(x, n = 1)` 从每一组中取`x`列的值最大的n行数据.\n\n-   `df |> slice_sample(n = 1)` 从每一组中随机取n行数据.\n\n其中的`n`参数指定需要提取的行数，同时，也可以用`prop`参数指定从每组中提取多少比例的行。例如，`prop = 0.1` 表示从每组中提取10%的行。\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# 找出到达每个目的地的延误最严重的航班\nflights %>%\n  group_by(dest) %>% \n  slice_max(order_by = arr_delay, n = 1) %>%\n  relocate(dest, arr_delay) %T>% \n  print() %>%\n  nrow()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 108 × 19\n# Groups:   dest [105]\n   dest  arr_delay  year month   day dep_time sched_dep_time dep_delay arr_time\n   <chr>     <dbl> <int> <int> <int>    <int>          <int>     <dbl>    <int>\n 1 ABQ         153  2013     7    22     2145           2007        98      132\n 2 ACK         221  2013     7    23     1139            800       219     1250\n 3 ALB         328  2013     1    25      123           2000       323      229\n 4 ANC          39  2013     8    17     1740           1625        75     2042\n 5 ATL         895  2013     7    22     2257            759       898      121\n 6 AUS         349  2013     7    10     2056           1505       351     2347\n 7 AVL         228  2013     8    13     1156            832       204     1417\n 8 BDL         266  2013     2    21     1728           1316       252     1839\n 9 BGR         238  2013    12     1     1504           1056       248     1628\n10 BHM         291  2013     4    10       25           1900       325      136\n# ℹ 98 more rows\n# ℹ 10 more variables: sched_arr_time <int>, carrier <chr>, flight <int>,\n#   tailnum <chr>, origin <chr>, air_time <dbl>, distance <dbl>, hour <dbl>,\n#   minute <dbl>, time_hour <dttm>\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 108\n```\n\n\n:::\n\n```{.r .cell-code}\nnrow(flights)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 336776\n```\n\n\n:::\n:::\n\n\n上面的例子中，`relocate()`函数后用到了分支管道\\[%T\\>%\\]，先通过`print()`把分组统计的结果打印出来，然后通过`nrow()`返回分组统计数据的行数。结果发现有108行，和原来数据的105行不符合，这是因为有的目的地可能有几架次并列延误最严重的航班。例如，第22行和23行的航班信息：\n\n\n::: {.cell}\n\n```{.r .cell-code}\nflights |> \n  group_by(dest) |> \n  slice_max(order_by = arr_delay, n = 1) |> \n  relocate(dest, arr_delay) |> \n  _[22:23,]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 2 × 19\n# Groups:   dest [1]\n  dest  arr_delay  year month   day dep_time sched_dep_time dep_delay arr_time\n  <chr>     <dbl> <int> <int> <int>    <int>          <int>     <dbl>    <int>\n1 CHS         331  2013     3     8     1202            751       251     1530\n2 CHS         331  2013     9     2     1906           1359       307     2134\n# ℹ 10 more variables: sched_arr_time <int>, carrier <chr>, flight <int>,\n#   tailnum <chr>, origin <chr>, air_time <dbl>, distance <dbl>, hour <dbl>,\n#   minute <dbl>, time_hour <dttm>\n```\n\n\n:::\n:::\n\n\n## 多变量分组统计\n\n例如分别统计每个日期（年+月+日）的航班数量：\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndaily <- flights |>  \n  group_by(year, month, day)\n\ndaily |> \n  summarize(flights = n())\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 365 × 4\n# Groups:   year, month [12]\n    year month   day flights\n   <int> <int> <int>   <int>\n 1  2013     1     1     842\n 2  2013     1     2     943\n 3  2013     1     3     914\n 4  2013     1     4     915\n 5  2013     1     5     720\n 6  2013     1     6     832\n 7  2013     1     7     933\n 8  2013     1     8     899\n 9  2013     1     9     902\n10  2013     1    10     932\n# ℹ 355 more rows\n```\n\n\n:::\n:::\n\n\n需要注意到结果中的第二行提示我们 `summarise()` 后的数据按照“year”和“month”进行了`group`处理。这是因为`summarise()` 在处理超过一个分组的数据时，输出的结果默认去除最后一个分组依据。这一行为可以通过设定`.groups`参数进行修改：\n\n-   `.groups = \"drop_last\"`：默认。`summarise()`后丢掉最后一个分组依据。\n\n-   `.groups = \"drop\"`：`summarise()`后取消分组。\n\n-   `.groups = \"keep\"`：`summarise()`后保留原分组。\n\n\n::: {.cell}\n\n```{.r .cell-code}\nflights |>  \n  group_by(year, month, day) |> \n  summarize(\n    flights = n(),\n    .groups = \"keep\"\n    ) \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 365 × 4\n# Groups:   year, month, day [365]\n    year month   day flights\n   <int> <int> <int>   <int>\n 1  2013     1     1     842\n 2  2013     1     2     943\n 3  2013     1     3     914\n 4  2013     1     4     915\n 5  2013     1     5     720\n 6  2013     1     6     832\n 7  2013     1     7     933\n 8  2013     1     8     899\n 9  2013     1     9     902\n10  2013     1    10     932\n# ℹ 355 more rows\n```\n\n\n:::\n:::\n\n\n## `ungroup()`\n\n取消分组。\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndaily |> \n  ungroup() |>\n  summarize(\n    avg_delay = mean(dep_delay, na.rm = TRUE), \n    flights = n()\n  )\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1 × 2\n  avg_delay flights\n      <dbl>   <int>\n1      12.6  336776\n```\n\n\n:::\n:::\n\n\n## `.by`\n\n[![](images/截屏2024-02-02%2017.05.04.png){width=\"147\"}](https://lifecycle.r-lib.org/articles/stages.html#experimental)\n\ndplyr从1.1.0版本开始包括了一个新的实验性语法，用于直接在统计函数中指定分组依据，即 `.by` 参数。`group_by()` 和 `ungroup()` 不会消失，但现在也可以使用 `.by` 参数来在单个操作中进行分组：\n\n\n::: {.cell}\n\n```{.r .cell-code}\nflights |> \n  summarize(\n    avg_delay = mean(dep_delay, na.rm = TRUE), \n    flights = n(),\n    .by = month # 按“month”分组统计\n  ) |> \n  arrange(month)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 12 × 3\n   month avg_delay flights\n   <int>     <dbl>   <int>\n 1     1     10.0    27004\n 2     2     10.8    24951\n 3     3     13.2    28834\n 4     4     13.9    28330\n 5     5     13.0    28796\n 6     6     20.8    28243\n 7     7     21.7    29425\n 8     8     12.6    29327\n 9     9      6.72   27574\n10    10      6.24   28889\n11    11      5.44   27268\n12    12     16.6    28135\n```\n\n\n:::\n\n```{.r .cell-code}\n# 等价于:\nflights |> \n  group_by(month) |> \n  summarise(\n    avg_delay = mean(dep_delay, na.rm = TRUE), \n    flights = n()\n    )\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 12 × 3\n   month avg_delay flights\n   <int>     <dbl>   <int>\n 1     1     10.0    27004\n 2     2     10.8    24951\n 3     3     13.2    28834\n 4     4     13.9    28330\n 5     5     13.0    28796\n 6     6     20.8    28243\n 7     7     21.7    29425\n 8     8     12.6    29327\n 9     9      6.72   27574\n10    10      6.24   28889\n11    11      5.44   27268\n12    12     16.6    28135\n```\n\n\n:::\n\n```{.r .cell-code}\n# 支持指定多个分组依据\nflights |> \n  summarize(\n    avg_delay = mean(dep_delay, na.rm = TRUE), \n    flights = n(),\n    .by = c(origin, dest)\n  ) |> \n  arrange(origin, dest)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 224 × 4\n   origin dest  avg_delay flights\n   <chr>  <chr>     <dbl>   <int>\n 1 EWR    ALB       23.6      439\n 2 EWR    ANC       12.9        8\n 3 EWR    ATL       15.5     5022\n 4 EWR    AUS       11.5      968\n 5 EWR    AVL        8.62     265\n 6 EWR    BDL       17.7      443\n 7 EWR    BNA       17.7     2336\n 8 EWR    BOS       12.5     5327\n 9 EWR    BQN       23.9      297\n10 EWR    BTV       17.8      931\n# ℹ 214 more rows\n```\n\n\n:::\n\n```{.r .cell-code}\n# 等价于：\nflights |> \n  group_by(origin, dest) |> \n  summarize(\n    avg_delay = mean(dep_delay, na.rm = TRUE), \n    flights = n()\n  ) |> \n  ungroup()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 224 × 4\n   origin dest  avg_delay flights\n   <chr>  <chr>     <dbl>   <int>\n 1 EWR    ALB       23.6      439\n 2 EWR    ANC       12.9        8\n 3 EWR    ATL       15.5     5022\n 4 EWR    AUS       11.5      968\n 5 EWR    AVL        8.62     265\n 6 EWR    BDL       17.7      443\n 7 EWR    BNA       17.7     2336\n 8 EWR    BOS       12.5     5327\n 9 EWR    BQN       23.9      297\n10 EWR    BTV       17.8      931\n# ℹ 214 more rows\n```\n\n\n:::\n:::\n\n\n------------------------------------------------------------------------\n\n::: {.callout-note collapse=\"true\" icon=\"false\"}\n## Session Info\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n\n```\nR version 4.3.2 (2023-10-31)\nPlatform: aarch64-apple-darwin20 (64-bit)\nRunning under: macOS Sonoma 14.3\n\nMatrix products: default\nBLAS:   /Library/Frameworks/R.framework/Versions/4.3-arm64/Resources/lib/libRblas.0.dylib \nLAPACK: /Library/Frameworks/R.framework/Versions/4.3-arm64/Resources/lib/libRlapack.dylib;  LAPACK version 3.11.0\n\nlocale:\n[1] en_US.UTF-8/en_US.UTF-8/en_US.UTF-8/C/en_US.UTF-8/en_US.UTF-8\n\ntime zone: Asia/Shanghai\ntzcode source: internal\n\nattached base packages:\n[1] stats     graphics  grDevices utils     datasets  methods   base     \n\nother attached packages:\n[1] magrittr_2.0.3 dplyr_1.1.4   \n\nloaded via a namespace (and not attached):\n [1] digest_0.6.34     utf8_1.2.4        R6_2.5.1          codetools_0.2-19 \n [5] fastmap_1.1.1     tidyselect_1.2.0  xfun_0.41         glue_1.7.0       \n [9] tibble_3.2.1      knitr_1.45        pkgconfig_2.0.3   htmltools_0.5.7  \n[13] generics_0.1.3    rmarkdown_2.25    lifecycle_1.0.4   cli_3.6.2        \n[17] fansi_1.0.6       vctrs_0.6.5       withr_3.0.0       compiler_4.3.2   \n[21] rstudioapi_0.15.0 tools_4.3.2       pillar_1.9.0      evaluate_0.23    \n[25] yaml_2.3.8        rlang_1.1.3       jsonlite_1.8.8    htmlwidgets_1.6.4\n```\n\n\n:::\n:::\n\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}