{
  "hash": "acb656565655f030122888b5ce492f40",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"基于stringr的字符串处理\"\n---\n\n\n> 参考：<https://r4ds.hadley.nz/strings>\n\n[![](images/logo-2-01.png){width=\"145\"}](https://stringr.tidyverse.org)\n\n本章主要介绍基于 [`stringr` 包](https://stringr.tidyverse.org)的字符串和字符向量的处理。我们需要记住 `stringr` 中用于字符串处理的函数大多都以 `str_` 开头，这样我们在 RStudio 通过键入 `str_` 就能方便的浏览并选择我们需要的函数：\n\n![](images/stringr-autocomplete.png){width=\"643\"}\n\n和字符处理密切相关的一个内容是**正则表达式（regular expressions）**，由于这一部分内容较多，我们将在[下一章](/r_basic/regular_expressions.qmd)介绍。\n\n# 加载包\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\nlibrary(babynames)\n```\n:::\n\n\n本章用到的案例数据集“babynames”记录了美国婴儿的姓名分布数据。\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbabynames\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1,924,665 × 5\n    year sex   name          n   prop\n   <dbl> <chr> <chr>     <int>  <dbl>\n 1  1880 F     Mary       7065 0.0724\n 2  1880 F     Anna       2604 0.0267\n 3  1880 F     Emma       2003 0.0205\n 4  1880 F     Elizabeth  1939 0.0199\n 5  1880 F     Minnie     1746 0.0179\n 6  1880 F     Margaret   1578 0.0162\n 7  1880 F     Ida        1472 0.0151\n 8  1880 F     Alice      1414 0.0145\n 9  1880 F     Bertha     1320 0.0135\n10  1880 F     Sarah      1288 0.0132\n# ℹ 1,924,655 more rows\n```\n\n\n:::\n:::\n\n\n# 查找字符\n\n下面是 `stringr` 包中用于查找字符的函数，它们接受**字符向量**输入，常常和**正则表达式**配合使用：\n\n![](images/截屏2024-03-07%2017.24.08.png){width=\"474\"}\n\n## `str_dect()` 和 `str_starts()`\n\n`str_dect(string, pattern)` 查找 `string` 中是否有包含目标字符 `pattern` 的对象，**返回一个逻辑向量**。`str_starts(string, pattern)` 查找 `string` 中是否有**开头**为目标字符 `pattern` 的对象。\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnames <- babynames$name[1:10]\nnames\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] \"Mary\"      \"Anna\"      \"Emma\"      \"Elizabeth\" \"Minnie\"    \"Margaret\" \n [7] \"Ida\"       \"Alice\"     \"Bertha\"    \"Sarah\"    \n```\n\n\n:::\n\n```{.r .cell-code}\n# 查找“names”中是否有以“M”开头的对象\nstr_detect(names, \"^M\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1]  TRUE FALSE FALSE FALSE  TRUE  TRUE FALSE FALSE FALSE FALSE\n```\n\n\n:::\n\n```{.r .cell-code}\n# 也可以用str_starts()\nstr_starts(names, \"M\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1]  TRUE FALSE FALSE FALSE  TRUE  TRUE FALSE FALSE FALSE FALSE\n```\n\n\n:::\n:::\n\n\n【练习】统计每年有多少名婴儿的名字中包含了“x”，并用折线图可视化这些婴儿每年的占比情况：\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbabynames %>%  \n  mutate(x_count = str_detect(name, \"x\") * n) %>% \n  group_by(year) %>% \n  summarise(prop_x = sum(x_count) / sum(n)) %>% \n  ggplot(aes(x = year, y = prop_x)) + \n  geom_line() +\n  theme_bw()\n```\n\n::: {.cell-output-display}\n![](stringr_files/figure-html/unnamed-chunk-4-1.png){width=672}\n:::\n:::\n\n\n## `str_which()`\n\n`str_which(string, pattern)` 查找 `string` 中是否有包含目标字符 `pattern` 的对象，**返回匹配到的对象的位置**。\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstr_which(names, \"^M\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1 5 6\n```\n\n\n:::\n:::\n\n\n::: callout-tip\n`stringr` 包的字符查找函数中的 `pattern` 是要区分大小写的，也意味着这些函数在查找时会区分大小写。\n\n上述函数都可以添加一个 `negate = TRUE` 参数，表示查找没有包含目标字符的对象，如：\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstr_detect(names, \"^M\", negate = TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] FALSE  TRUE  TRUE  TRUE FALSE FALSE  TRUE  TRUE  TRUE  TRUE\n```\n\n\n:::\n\n```{.r .cell-code}\nstr_which(names, \"^M\", negate = TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]  2  3  4  7  8  9 10\n```\n\n\n:::\n:::\n\n:::\n\n## `str_view()`\n\n![](images/截屏2024-03-10%2010.44.21.png){width=\"463\"}\n\n`str_view(string, pattern)` 是一个比较特殊的字符查找函数，它返回的结果以HTML渲染样式来返回 `string` 中所有匹配的字符，并且**会将其中的 `pattern` 以“\\<\\>”标记出来**：\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstr_view(names, \"^M\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] │ <M>ary\n[5] │ <M>innie\n[6] │ <M>argaret\n```\n\n\n:::\n:::\n\n\n::: {.callout-tip collapse=\"true\"}\n## `base` 包中的字符查找函数\n\n### **`%in%`**\n\n查找字符向量中是否有**任何**目标字符串。它会把每个字符串当成判断的最小单位，即**完全匹配**，所以不能用来判断/查找\"长字符串中是否含有特定的短字符串\"。例如：\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplaces <- c(\"中国四川\",\"中国北京\",\"中国安徽\",\"北京天安门\")\n\"中国四川\" %in% places\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n\n```{.r .cell-code}\n\"中国\" %in% places\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE\n```\n\n\n:::\n:::\n\n\n### **`grep()`函数**\n\ngrep 的全称是“global search regular expression and print out the line”，类似于 `stringr` 包中的 `str_which()` ，返回匹配到的目标字符的位置。当添加了 `value = TRUE` 参数时，类似于 `str_subset()` 函数（见[下文](#sec-str_sub)），返回包含目标字符的所有对象。\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngrep(\n  pattern = \"^M\", # 需要找找的字符\n  x = names, # 从哪里查找\n  ignore.case = F, # 是否忽略大小写，默认为FALSE\n  value = F, # 默认为FALSE，表示返回匹配到的字符所在的位置；TRUE则返回查找到的值\n  invert = F # 如果为TRUE，则返回未匹配到的字符的值或位置\n) \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1 5 6\n```\n\n\n:::\n:::\n\n\n### **`grepl()`**\n\n`grepl()` 类似于 `stringr` 包中的 `str_detect()` ，返回是否匹配到目标字符的逻辑向量：\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngrepl(\n  pattern = \"^M\",\n  x = names\n    )\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1]  TRUE FALSE FALSE FALSE  TRUE  TRUE FALSE FALSE FALSE FALSE\n```\n\n\n:::\n:::\n\n:::\n\n# 截取字符\n\n![](images/截屏2024-03-07%2018.08.32.png){width=\"459\"}\n\n## `str_sub()` {#sec-str_sub}\n\n`str_sub(string，start，end)` 用于提取指定长度和位置的字符串，其中 `start` 和 `end` 是截取字符串应该开始和结束的位置。返回的字符串的长度 = `end` - `start` + 1。`base` 包中与之对应的函数是 `substr()` 。\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfruit_list <- c(\"A_p ple\", \" Banana\", \"Pear\", NA)\nstr_sub(fruit_list, 1, 3)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"A_p\" \" Ba\" \"Pea\" NA   \n```\n\n\n:::\n\n```{.r .cell-code}\n# 负号表示距末尾多少个字符截取：\nstr_sub(fruit_list, -3, -1)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"ple\" \"ana\" \"ear\" NA   \n```\n\n\n:::\n:::\n\n\n`str_sub()` 在其后方添加赋值后还可以实现对特定位置字符的替换，见[下文](#sec-替换字符)。\n\n## `str_subset()`\n\n`str_subset(string, pattern)` 返回 `string` 中包含 `pattern` 的所有对象。功能类似于添加了 `value = TRUE` 参数时的 `grep()` 函数。\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# 返回“names”中开头为“M”的对象\nstr_subset(names, \"^M\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Mary\"     \"Minnie\"   \"Margaret\"\n```\n\n\n:::\n:::\n\n\n# 替换字符 {#sec-替换字符}\n\n![](images/截屏2024-03-07%2018.37.53.png){width=\"499\"}\n\n## `str_sub() <- value`\n\n用 `str_sub() <- value` 可以实现对特定位置字符的替换。例如将“fruit_list”中的第1-3位字符替换成“\\*\\*\\*”：\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstr_sub(fruit_list, 1, 3) <- \"***\"\nfruit_list\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"*** ple\" \"***nana\" \"***r\"    NA       \n```\n\n\n:::\n:::\n\n\n## `str_replace()`\n\n-   `str_replace(string, pattern, replacement)` 将 `string` 中的**第一个** `pattern` 替换成 `replacement` 。\n\n-   `str_replace_all(string, pattern, replacement)` 将 `string` 中的**所有** `pattern` 替换成 `replacement` 。\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfruit_list <- c(\"A_p p le\", \" B anana\", \"Pear \", NA)\n\n# 将“fruit_list”中的第一个空格替换成“#”\nstr_replace(fruit_list, pattern = \" \", replacement = \"#\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"A_p#p le\" \"#B anana\" \"Pear#\"    NA        \n```\n\n\n:::\n\n```{.r .cell-code}\n# 将“fruit_list”中的所有空格替换成“#”\nstr_replace_all(fruit_list, pattern = \" \", replacement = \"#\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"A_p#p#le\" \"#B#anana\" \"Pear#\"    NA        \n```\n\n\n:::\n:::\n\n\n## `str_remove()`\n\n-   `str_remove(string, pattern)` 将 `string` 中的**第一个** `pattern` 删除。\n\n-   `str_remove_all(string, pattern)` 将 `string` 中的**所有** `pattern` 删除。\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# 删除“fruit_list”中的第一个空格\nstr_remove(fruit_list, pattern = \" \")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"A_pp le\" \"B anana\" \"Pear\"    NA       \n```\n\n\n:::\n\n```{.r .cell-code}\n# 删除“fruit_list”中的所有空格\nstr_remove_all(fruit_list, pattern = \" \")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"A_pple\" \"Banana\" \"Pear\"   NA      \n```\n\n\n:::\n:::\n\n\n::: {.callout-tip collapse=\"true\"}\n## base 包中的字符替换函数\n\n在 base 包中与 `str_replace_all()` 和 `str_remove_all()` 对应的函数是 `gsub()` ：\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngsub(x = fruit_list, pattern = \" \", replacement = \"#\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"A_p#p#le\" \"#B#anana\" \"Pear#\"    NA        \n```\n\n\n:::\n:::\n\n:::\n\n## 转换大小写\n\n![](images/截屏2024-03-07%2017.12.05.png){width=\"429\"}\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstr_to_upper(c(\"abc\", \"def\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"ABC\" \"DEF\"\n```\n\n\n:::\n\n```{.r .cell-code}\nstr_to_lower(c(\"ABC\", \"DEF\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"abc\" \"def\"\n```\n\n\n:::\n\n```{.r .cell-code}\nstr_to_title(c(\"ABC\", \"DEF\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Abc\" \"Def\"\n```\n\n\n:::\n:::\n\n\n`base` 包中与之对应的函数是 `toupper()` 和 `tolower()` 。\n\n# 拼接字符 {#sec-拼接字符串}\n\n![](images/截屏2024-03-07%2019.18%20拷贝.jpg){width=\"422\"}\n\n## `str_c()`\n\n`str_c()` 和 `str_glue()` 用于拼接字符。`str_c()` 与 `base` 包的 `paste0()` 的用法非常相似，但前者遵循 tidyverse 规则，不会对缺失值进行处理，能够更好的与 `mutate()` 配合使用：\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf <- tibble(name = c(\"Flora\", \"David\", \"Terra\", NA, \"Eric\", NA))\ndf  %>%  mutate(greeting = str_c(\"Hi \", name, \"!\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 6 × 2\n  name  greeting \n  <chr> <chr>    \n1 Flora Hi Flora!\n2 David Hi David!\n3 Terra Hi Terra!\n4 <NA>  <NA>     \n5 Eric  Hi Eric! \n6 <NA>  <NA>     \n```\n\n\n:::\n\n```{.r .cell-code}\n# 用paste0()的效果\ndf %>% mutate(greeting = paste0(\"Hi \", name, \"!\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 6 × 2\n  name  greeting \n  <chr> <chr>    \n1 Flora Hi Flora!\n2 David Hi David!\n3 Terra Hi Terra!\n4 <NA>  Hi NA!   \n5 Eric  Hi Eric! \n6 <NA>  Hi NA!   \n```\n\n\n:::\n:::\n\n\n::: callout-caution\n从上面的例子中可以发现，`str_c()` 和 `paste0()` 的一个最重要的区别是 **`str_c()` 会忽略缺失值，而 `paste0()` 会将缺失值也作为一个字符处理。**\n:::\n\n如果希望在遇到缺失值时以其他字符替换显示，可以使用 `coalesce(x, \"y\")` ，它会将x中的所有缺失值替换成“y”。根据需要，可以在 `str_c()` 内部或外部使用它：\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# 演示coalesc()的作用\ncoalesce(df$name, \"you\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Flora\" \"David\" \"Terra\" \"you\"   \"Eric\"  \"you\"  \n```\n\n\n:::\n\n```{.r .cell-code}\ndf |> \n  mutate(\n    greeting1 = str_c(\"Hi \", coalesce(name, \"you\"), \"!\"),\n    greeting2 = coalesce(str_c(\"Hi \", name, \"!\"), \"Hi someone!\"), \n    .keep = \"used\"\n  )\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 6 × 3\n  name  greeting1 greeting2  \n  <chr> <chr>     <chr>      \n1 Flora Hi Flora! Hi Flora!  \n2 David Hi David! Hi David!  \n3 Terra Hi Terra! Hi Terra!  \n4 <NA>  Hi you!   Hi someone!\n5 Eric  Hi Eric!  Hi Eric!   \n6 <NA>  Hi you!   Hi someone!\n```\n\n\n:::\n:::\n\n\n可以通过添加 `sep` 参数，以固定的分隔符分隔多个字符向量，类似于 `paste()` 中的 `sep` 参数（两者对待缺失值的行为不一样）：\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf <- df %>%\n  mutate(\n    age = c(11, 16, 20, 18, NA, 22),\n    height = c(116, 170, NA, 180, NA, 177)\n  )\n\ndf %>% \n  mutate(\n    combine = str_c(coalesce(name, \"unknown\"), age, height, sep = \"-\")\n  )\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 6 × 4\n  name    age height combine       \n  <chr> <dbl>  <dbl> <chr>         \n1 Flora    11    116 Flora-11-116  \n2 David    16    170 David-16-170  \n3 Terra    20     NA <NA>          \n4 <NA>     18    180 unknown-18-180\n5 Eric     NA     NA <NA>          \n6 <NA>     22    177 unknown-22-177\n```\n\n\n:::\n\n```{.r .cell-code}\n# 用paste()替换str_c()\ndf %>% \n  mutate(\n    combine = paste(coalesce(name, \"unknown\"), age, height, sep = \"-\")\n  )\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 6 × 4\n  name    age height combine       \n  <chr> <dbl>  <dbl> <chr>         \n1 Flora    11    116 Flora-11-116  \n2 David    16    170 David-16-170  \n3 Terra    20     NA Terra-20-NA   \n4 <NA>     18    180 unknown-18-180\n5 Eric     NA     NA Eric-NA-NA    \n6 <NA>     22    177 unknown-22-177\n```\n\n\n:::\n:::\n\n\n如果给 `str_c()` 只提供了**一个字符向量**，这个时候如果需要将该向量内的字符以固定的分隔符**合并为一个字符**，则需要指定 `collapse` 参数。这种情况可以和 `summarize()` 配合使用，并且一般会使用另一个字符连接函数 `str_flatten()` （见）。\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstr_c(coalesce(df$name, \"unknown\"), collapse = \"-\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Flora-David-Terra-unknown-Eric-unknown\"\n```\n\n\n:::\n\n```{.r .cell-code}\npaste(df$name, collapse = \"-\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Flora-David-Terra-NA-Eric-NA\"\n```\n\n\n:::\n:::\n\n\n## `str_glue()` 和 `str_glu_data()`\n\n如果你需要将很多字符串向量和多个固定字符粘贴起来，如果这时候仍然用 `str_c()` 会让代码看上去比较混乱和难以理解。这种情况我们可以使用 `str_glue()` 来简化代码。 `str_glue()` 将需要调用的字符向量放到“{}”内，括号外可以输入任意自定义字符。\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf %>%\n  mutate(\n    greeting = str_glue(\n      \"My name is {name}, \",\n      \"my age is {age}, \",\n      \"my height is {height/100} meters.\",\n      .na = \"**\"\n    )\n  )\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 6 × 4\n  name    age height greeting                                                 \n  <chr> <dbl>  <dbl> <glue>                                                   \n1 Flora    11    116 My name is Flora, my age is 11, my height is 1.16 meters.\n2 David    16    170 My name is David, my age is 16, my height is 1.7 meters. \n3 Terra    20     NA My name is Terra, my age is 20, my height is ** meters.  \n4 <NA>     18    180 My name is **, my age is 18, my height is 1.8 meters.    \n5 Eric     NA     NA My name is Eric, my age is **, my height is ** meters.   \n6 <NA>     22    177 My name is **, my age is 22, my height is 1.77 meters.   \n```\n\n\n:::\n:::\n\n\n::: callout-caution\n`str_glue()` 默认情况下会将缺失值转换为字符串 \"NA\"，这一点与 `str_c()` 不一致。可以通过添加 `.na` 参数指定将缺失值替换成什么。\n:::\n\n### `str_glue_data()`\n\n如果你想脱离 `mutate()`，在一个表格中简单的通过连接几列来**返回一个字符向量**，那么用 `str_glue_data()` 可能更合适。其语法为：`str_glue_data(.x, ..., .sep, .na = \"NA\")` 。\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncars <- head(mtcars)\ncars\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n                   mpg cyl disp  hp drat    wt  qsec vs am gear carb\nMazda RX4         21.0   6  160 110 3.90 2.620 16.46  0  1    4    4\nMazda RX4 Wag     21.0   6  160 110 3.90 2.875 17.02  0  1    4    4\nDatsun 710        22.8   4  108  93 3.85 2.320 18.61  1  1    4    1\nHornet 4 Drive    21.4   6  258 110 3.08 3.215 19.44  1  0    3    1\nHornet Sportabout 18.7   8  360 175 3.15 3.440 17.02  0  0    3    2\nValiant           18.1   6  225 105 2.76 3.460 20.22  1  0    3    1\n```\n\n\n:::\n\n```{.r .cell-code}\nstr_glue_data(cars, \"{rownames(cars)} has {hp} hp\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nMazda RX4 has 110 hp\nMazda RX4 Wag has 110 hp\nDatsun 710 has 93 hp\nHornet 4 Drive has 110 hp\nHornet Sportabout has 175 hp\nValiant has 105 hp\n```\n\n\n:::\n\n```{.r .cell-code}\n# 在mutate()外使用str_glue()实现同样的目的需要反复调用数据集名称\nstr_glue(\"{rownames(cars)} has {cars$hp} hp\") \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nMazda RX4 has 110 hp\nMazda RX4 Wag has 110 hp\nDatsun 710 has 93 hp\nHornet 4 Drive has 110 hp\nHornet Sportabout has 175 hp\nValiant has 105 hp\n```\n\n\n:::\n:::\n\n\n## `str_flatten()`\n\n`str_c()` 和 `str_glue()` 可以很好地与 `mutate()` 配合使用，因为它们的输出与输入长度相同。如果想要一个能与 `summarize()` 完美配合的函数，即总是返回单个字符串的函数，就可以用 `str_flatten()` ：它接收单个字符向量，并以固定的分隔符将向量中的每个元素合并为一个字符。\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstr_flatten(c(\"x\", \"y\", \"z\"), collapse = \", \", last = \", and \")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"x, y, and z\"\n```\n\n\n:::\n:::\n\n\n例如，统计每个人喜欢的水果，把每个人喜欢的水果用逗号连接起来：\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf <- tribble(\n  ~ name, ~ fruit,\n  \"Carmen\", \"banana\",\n  \"Carmen\", \"apple\",\n  \"Marvin\", \"nectarine\",\n  \"Terence\", \"cantaloupe\",\n  \"Terence\", \"papaya\",\n  \"Terence\", \"mandarin\"\n)\n\ndf |>\n  group_by(name) |> \n  summarize(fruits = str_flatten(fruit, collapse = \", \"))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 3 × 2\n  name    fruits                      \n  <chr>   <chr>                       \n1 Carmen  banana, apple               \n2 Marvin  nectarine                   \n3 Terence cantaloupe, papaya, mandarin\n```\n\n\n:::\n\n```{.r .cell-code}\n# 也可以用str_c()并指定collapse参数\ndf |>\n  group_by(name) |> \n  summarize(fruits = str_c(fruit, collapse = \", \"))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 3 × 2\n  name    fruits                      \n  <chr>   <chr>                       \n1 Carmen  banana, apple               \n2 Marvin  nectarine                   \n3 Terence cantaloupe, papaya, mandarin\n```\n\n\n:::\n:::\n\n\n# 分割字符\n\n![](images/截屏2024-03-07%2020.03.28.png){width=\"521\"}\n\n`str_split(string, pattern, simplify, i)` 可以根据某个**分割符**将字符向量中的每一个对象分割成n列。其中：\n\n-   `string`：待分割的字符向量。其中每个对象包含的分割符数量可以是不同的。\n\n-   `pattern`：指定分割符。\n\n-   `simplify`：默认“FALSE”，返回一个字符向量列表。设置为“TRUE”时（常用），则返回字符矩阵（character matrix）。\n\n可以在 `str_split()` 外通过添加 `[x, y]` 来提取拆分后的指定列或行的字符。\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf <- tibble(\n  fruits = c(\n    \"apples-oranges-pears-bananas\",\n    \"pineapples-mangos-guavas\"\n    )\n  )\n\nstr_split(df$fruits, \"-\", simplify = T) \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1]         [,2]      [,3]     [,4]     \n[1,] \"apples\"     \"oranges\" \"pears\"  \"bananas\"\n[2,] \"pineapples\" \"mangos\"  \"guavas\" \"\"       \n```\n\n\n:::\n\n```{.r .cell-code}\nstr_split(df$fruits, \"-\", simplify = T)[,2] \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"oranges\" \"mangos\" \n```\n\n\n:::\n\n```{.r .cell-code}\ndf %>% \n  mutate(\n    \"2nd_fruit\" = str_split(fruits, \"-\", simplify = T)[,2] \n  )\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 2 × 2\n  fruits                       `2nd_fruit`\n  <chr>                        <chr>      \n1 apples-oranges-pears-bananas oranges    \n2 pineapples-mangos-guavas     mangos     \n```\n\n\n:::\n:::\n\n\n## 字符列的分割 {#sec-字符列的分割}\n\n![](images/clipboard-4083897435.png)\n\n`separate_wider_position()` 、 `separate_wider_delim()` 以及 `separate_wider_regex()` 用于将某一列根据分割符（`separate_wider_delim()`）、固定宽度（`separate_wider_position()`）或正则表达式（`separate_wider_regex()`）拆分为多列。这些函数包括在 [`tidyr` 包](/r_basic/tidyr.qmd)中，因为它们的操作对象是数据框（列），而不是单个字符向量。把这些函数中的“wider”替换成“longer”就构成了另外三个类似函数，用于将某一列根据分割符、固定宽度或正则表达式拆分为多行（不常用）。\n\n### `separate_wider_delim()`\n\n将数据框中的某列根据某个符号（`delim`）拆分成几列：\n\n\n::: {#tbl-separate_wider_delim .cell tbl-cap='字符列的分割案例'}\n\n```{.r .cell-code}\ndf3 <- tibble(x = c(\"a10-1-2022\", \"b10-2-2011\", \"e15-1-2015\"))\ndf3\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 3 × 1\n  x         \n  <chr>     \n1 a10-1-2022\n2 b10-2-2011\n3 e15-1-2015\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ndf3 |> \n  separate_wider_delim(\n    x,\n    delim = \"-\",\n    names = c(\"code\", \"edition\", \"year\"),\n    cols_remove = F # 不要移除原始列\n  )\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 3 × 4\n  code  edition year  x         \n  <chr> <chr>   <chr> <chr>     \n1 a10   1       2022  a10-1-2022\n2 b10   2       2011  b10-2-2011\n3 e15   1       2015  e15-1-2015\n```\n\n\n:::\n:::\n\n\n::: {.callout-tip collapse=\"true\"}\n###### 这个效果是否用上面的 `str_split()` 也可以实现？\n\n如果用上面的 `str_split()` 实现同样目的的话需要如下代码：\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf3 %>% \n  mutate(\n    code = str_split(x, pattern = \"-\", simplify = T)[,1],\n    edition = str_split(x, pattern = \"-\", simplify = T)[,2],\n    year = str_split(x, pattern = \"-\", simplify = T)[,3]\n  )\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 3 × 4\n  x          code  edition year \n  <chr>      <chr> <chr>   <chr>\n1 a10-1-2022 a10   1       2022 \n2 b10-2-2011 b10   2       2011 \n3 e15-1-2015 e15   1       2015 \n```\n\n\n:::\n:::\n\n:::\n\n如果拆分后某几列的数据不需要，可以将其指定为“NA”，这样在输出结果中指定为“NA”的列将不会显示：\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf3 |> \n  separate_wider_delim(\n    x,\n    delim = \"-\",\n    names = c(\"code\", NA, \"year\")\n  )\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 3 × 2\n  code  year \n  <chr> <chr>\n1 a10   2022 \n2 b10   2011 \n3 e15   2015 \n```\n\n\n:::\n:::\n\n\n在上面的 @tbl-separate_wider_delim 中，待分割列有**固定的分隔符**分隔我们想要提取的变量，这种情况用 `separate_wider_delim()` 可以便捷的分割这些变量。但是在下面的 @tbl-separate_wider_delim_regex 中待分割列中的变量间由不同的分隔符分隔，这个时候我们可以**通过正则表达式来定义分隔符**。`delim` 参数支持通过 `regex()` 包装的[正则表达式](/r_basic/regular_expressions.qmd)：\n\n\n::: {#tbl-separate_wider_delim_regex .cell tbl-cap='在separate_wider_delim()中应用正则表达式'}\n\n```{.r .cell-code}\ndf4 <- tibble(x = c(\"a10-1_2022 January\", \"b10-2_2011 February\", \"e15-1_2015 March\"))\ndf4\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 3 × 1\n  x                  \n  <chr>              \n1 a10-1_2022 January \n2 b10-2_2011 February\n3 e15-1_2015 March   \n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ndf4 |> \n  separate_wider_delim(\n    x,\n    delim = regex(\"-|_|\\\\s\"), # 或者写成 \"-|_| \"\n    names = c(\"code\", \"edition\", \"year\", \"month\"),\n    cols_remove = F \n  )\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 3 × 5\n  code  edition year  month    x                  \n  <chr> <chr>   <chr> <chr>    <chr>              \n1 a10   1       2022  January  a10-1_2022 January \n2 b10   2       2011  February b10-2_2011 February\n3 e15   1       2015  March    e15-1_2015 March   \n```\n\n\n:::\n:::\n\n\n### `separate_wider_regex()`\n\n**根据正则表达式拆分列**：\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf_age <- tribble(\n  ~str,\n  \"<Sheryl>-F_34\",\n  \"<Kisha>-F_45\", \n  \"<Brandon>-N_33\",\n  \"<Sharon>-F_38\", \n  \"<Penny>-F_58\",\n  \"<Justin>-M_41\", \n  \"<Patricia>-F_84\", \n)\n\n# 给予赋值的对象会被写入新列，其他字符会被删除\ndf_age |> \n  separate_wider_regex(\n    str,\n    patterns = c(\n      \"<\", \n      name = \".+\", \n      \">-\", \n      gender = \".\",\n      \"_\",\n      age = \".+\"\n    )\n  )\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 7 × 3\n  name     gender age  \n  <chr>    <chr>  <chr>\n1 Sheryl   F      34   \n2 Kisha    F      45   \n3 Brandon  N      33   \n4 Sharon   F      38   \n5 Penny    F      58   \n6 Justin   M      41   \n7 Patricia F      84   \n```\n\n\n:::\n:::\n\n\n### `separate_wider_position()`\n\n拆分指定长度的字符构成新列：\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf4 <- tibble(x = c(\"202215TX\", \"202122LA\", \"202325CA\")) \ndf4 |> \n  separate_wider_position(\n    x,\n    widths = c(year = 4, age = 2, state = 2)\n  )\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 3 × 3\n  year  age   state\n  <chr> <chr> <chr>\n1 2022  15    TX   \n2 2021  22    LA   \n3 2023  25    CA   \n```\n\n\n:::\n:::\n\n\n::: {.callout-tip collapse=\"true\"}\n### `separate_longer_delim()`\n\n将tibble中的某个字符列根据某个符号（`delim`）拆分成几行：\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf1 <- tibble(x = c(\"a,b,c\", \"d,e\", \"f\"))\ndf1\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 3 × 1\n  x    \n  <chr>\n1 a,b,c\n2 d,e  \n3 f    \n```\n\n\n:::\n\n```{.r .cell-code}\ndf1 |> \n  separate_longer_delim(x, delim = \",\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 6 × 1\n  x    \n  <chr>\n1 a    \n2 b    \n3 c    \n4 d    \n5 e    \n6 f    \n```\n\n\n:::\n:::\n\n:::\n\n### 拆分错误调试\n\n在使用 `separate_wider_delim()` 时，如果需要拆分的字符串中某些字符根据指定分割符拆封后片段数不足，则会发生报错：\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf <- tibble(x = c(\"1-1-1\", \"1-1-2\", \"1-3\", \"1-3-2\", \"1\"))\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ndf |> \n  separate_wider_delim(\n    x,\n    delim = \"-\",\n    names = c(\"x\", \"y\", \"z\")\n  )\n```\n:::\n\n\n``` md\nError in `separate_wider_delim()`:\n! Expected 3 pieces in each element of `x`.\n! 2 values were too short.\nℹ Use `too_few = \"debug\"` to diagnose the problem.\nℹ Use `too_few = \"align_start\"/\"align_end\"` to silence this message.\nRun `rlang::last_trace()` to see where the error occurred.\n```\n\n对于这种情况，可以手动检查数据问题，但是在实际应用中需要转换的字符列可能非常长，我们难以知道到底在哪一行出现了问题。这个时候，我们可以按照错误提示所说的那样，通过添加 `too_few = \"debug\"` 参数来进入调试模式：\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndebug <- df |> \n  separate_wider_delim(\n    x,\n    delim = \"-\",\n    names = c(\"x\", \"y\", \"z\"),\n    too_few = \"debug\"\n  )\ndebug\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 5 × 6\n  x     y     z     x_ok  x_pieces x_remainder\n  <chr> <chr> <chr> <lgl>    <int> <chr>      \n1 1-1-1 1     1     TRUE         3 \"\"         \n2 1-1-2 1     2     TRUE         3 \"\"         \n3 1-3   3     <NA>  FALSE        2 \"\"         \n4 1-3-2 3     2     TRUE         3 \"\"         \n5 1     <NA>  <NA>  FALSE        1 \"\"         \n```\n\n\n:::\n:::\n\n\n使用调试模式时，输出的结果会多出三列：“x_ok”、“x_pieces” 和 “x_remainder”（前缀“x”是输入的变量名）：\n\n-   “x_ok”列：“TRUE”代表这一行能够被成功分割；而“FALSE”代表这一行分割失败。\n\n-   “x_pieces”列：告诉我们这一行能够被分割成多少片段。\n\n-   “x_remainder”列：在指定了 `too_many` 参数时有用。它告诉我们每一行多出来的具体字符（见下文）。\n\n因此，利用“x_ok”我们可以方便的找出转换失败的行：\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndebug |> filter(!x_ok)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 2 × 6\n  x     y     z     x_ok  x_pieces x_remainder\n  <chr> <chr> <chr> <lgl>    <int> <chr>      \n1 1-3   3     <NA>  FALSE        2 \"\"         \n2 1     <NA>  <NA>  FALSE        1 \"\"         \n```\n\n\n:::\n:::\n\n\n在发现了这些错误之处后，可以在原始数据中修复这些问题，然后重新运行 `separate_wider_delim()` ，并确保删除 `too_few = \"debug\"`。\n\n在其他情况下，我们可能想用 “NA” 填补缺失的部分。这就是 `too_few = \"align_start\"` 和 `too_few = \"align_end\"` 的作用，它们可以控制 “NA” 填充的位置（一般用 `\"align_start\"`）：\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf |> \n  separate_wider_delim(\n    x,\n    delim = \"-\",\n    names = c(\"x\", \"y\", \"z\"),\n    too_few = \"align_start\"\n  )\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 5 × 3\n  x     y     z    \n  <chr> <chr> <chr>\n1 1     1     1    \n2 1     1     2    \n3 1     3     <NA> \n4 1     3     2    \n5 1     <NA>  <NA> \n```\n\n\n:::\n:::\n\n\n在上面这个案例中我们指定了 `too_few` 参数，它告诉程序如何处理分割后片段数少于 `name` 中所定义的新列数的情况，是debug还是用“NA”填充。另一种情况是指定 `too_many` 参数，它告诉程序如何处理分割后片段数超出 `name` 中所定义的新列数的情况，是debug（`too_many = \"debug\"`）、舍弃（`too_many = \"drop\"`），还是合并（`too_many = \"merge\"`）多出来的片段。下面是一个案例：\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf <- tibble(x = c(\"1-1-1\", \"1-1-2\", \"1-3-5-6\", \"1-3-2\", \"1-3-5-7-9\"))\n\ndebug <- df |> \n  separate_wider_delim(\n    x,\n    delim = \"-\",\n    names = c(\"x\", \"y\", \"z\"),\n    too_many = \"debug\"\n  )\ndebug\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 5 × 6\n  x         y     z     x_ok  x_pieces x_remainder\n  <chr>     <chr> <chr> <lgl>    <int> <chr>      \n1 1-1-1     1     1     TRUE         3 \"\"         \n2 1-1-2     1     2     TRUE         3 \"\"         \n3 1-3-5-6   3     5     FALSE        4 \"-6\"       \n4 1-3-2     3     2     TRUE         3 \"\"         \n5 1-3-5-7-9 3     5     FALSE        5 \"-7-9\"     \n```\n\n\n:::\n:::\n\n\n我们同样可以通过“x_ok”列寻找转换失败的行。在定义 `too_many` 的情况下，“x_remainder”就会发挥它的作用，这一列告诉我们每一行超出来的具体字符。\n\n接下来我们可以决定如何处理超出来的片段：\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# 删除超出的片段\ndf |> \n  separate_wider_delim(\n    x,\n    delim = \"-\",\n    names = c(\"x\", \"y\", \"z\"),\n    too_many = \"drop\"\n  )\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 5 × 3\n  x     y     z    \n  <chr> <chr> <chr>\n1 1     1     1    \n2 1     1     2    \n3 1     3     5    \n4 1     3     2    \n5 1     3     5    \n```\n\n\n:::\n\n```{.r .cell-code}\n# 合并超出的片段\ndf |> \n  separate_wider_delim(\n    x,\n    delim = \"-\",\n    names = c(\"x\", \"y\", \"z\"),\n    too_many = \"merge\"\n  )\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 5 × 3\n  x     y     z    \n  <chr> <chr> <chr>\n1 1     1     1    \n2 1     1     2    \n3 1     3     5-6  \n4 1     3     2    \n5 1     3     5-7-9\n```\n\n\n:::\n:::\n\n\n# 计算字符长度\n\n![](images/截屏2024-03-07%2018.30.01.png){width=\"440\"}\n\n`str_length()` 可以返回字符串中每一个字符的长度（空格算一个字符）：\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstr_length(c(\"a\", \"R for data science\", NA))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]  1 18 NA\n```\n\n\n:::\n:::\n\n\n下面我们用“babynames”数据集，来演示如何利用 `str_length()` + `count()`，来统计婴儿名字长度的分布情况，然后使用 `Filter()` 来查看最长的名字：\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbabynames\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1,924,665 × 5\n    year sex   name          n   prop\n   <dbl> <chr> <chr>     <int>  <dbl>\n 1  1880 F     Mary       7065 0.0724\n 2  1880 F     Anna       2604 0.0267\n 3  1880 F     Emma       2003 0.0205\n 4  1880 F     Elizabeth  1939 0.0199\n 5  1880 F     Minnie     1746 0.0179\n 6  1880 F     Margaret   1578 0.0162\n 7  1880 F     Ida        1472 0.0151\n 8  1880 F     Alice      1414 0.0145\n 9  1880 F     Bertha     1320 0.0135\n10  1880 F     Sarah      1288 0.0132\n# ℹ 1,924,655 more rows\n```\n\n\n:::\n\n```{.r .cell-code}\nbabynames |>\n  count(length = str_length(name), wt = n)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 14 × 2\n   length        n\n    <int>    <int>\n 1      2   338150\n 2      3  8589596\n 3      4 48506739\n 4      5 87011607\n 5      6 90749404\n 6      7 72120767\n 7      8 25404066\n 8      9 11926551\n 9     10  1306159\n10     11  2135827\n11     12    16295\n12     13    10845\n13     14     3681\n14     15      830\n```\n\n\n:::\n:::\n\n\n::: {.callout-caution collapse=\"true\"}\n###### 注意 `count()` 中的 `wt`[（加权）参数](/r_basic/vector_transform.qmd#sec-wt)\n\n如果不指定该参数，那么 `count()` 返回的计算结果将是各个长度的名字在该表格中的计数（行数），但是该表格不是一个婴儿一行，而是在 “n” 列中提供了每一个姓名下的婴儿总数，所以需要用这个数字来对计数进行加权。\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# 和上表对比\nbabynames |>\n  count(length = str_length(name))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 14 × 2\n   length      n\n    <int>  <int>\n 1      2   4660\n 2      3  41274\n 3      4 177838\n 4      5 404291\n 5      6 546519\n 6      7 424360\n 7      8 213803\n 8      9  78946\n 9     10  23437\n10     11   6461\n11     12   1610\n12     13    946\n13     14    390\n14     15    130\n```\n\n\n:::\n:::\n\n:::\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# 查看最长的名字\nbabynames |> \n  filter(str_length(name) == max(str_length(name))) |> \n  count(name, wt = n, sort = TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 34 × 2\n   name                n\n   <chr>           <int>\n 1 Franciscojavier   123\n 2 Christopherjohn   118\n 3 Johnchristopher   118\n 4 Christopherjame   108\n 5 Christophermich    52\n 6 Ryanchristopher    45\n 7 Mariadelosangel    28\n 8 Jonathanmichael    25\n 9 Christianjoseph    22\n10 Christopherjose    22\n# ℹ 24 more rows\n```\n\n\n:::\n:::\n\n\n------------------------------------------------------------------------\n\n::: {.callout-note collapse=\"true\" icon=\"false\"}\n## Session Info\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n\n```\nR version 4.3.3 (2024-02-29)\nPlatform: aarch64-apple-darwin20 (64-bit)\nRunning under: macOS Sonoma 14.4\n\nMatrix products: default\nBLAS:   /Library/Frameworks/R.framework/Versions/4.3-arm64/Resources/lib/libRblas.0.dylib \nLAPACK: /Library/Frameworks/R.framework/Versions/4.3-arm64/Resources/lib/libRlapack.dylib;  LAPACK version 3.11.0\n\nlocale:\n[1] en_US.UTF-8/en_US.UTF-8/en_US.UTF-8/C/en_US.UTF-8/en_US.UTF-8\n\ntime zone: Asia/Shanghai\ntzcode source: internal\n\nattached base packages:\n[1] stats     graphics  grDevices utils     datasets  methods   base     \n\nother attached packages:\n [1] babynames_1.0.1 lubridate_1.9.3 forcats_1.0.0   stringr_1.5.1  \n [5] dplyr_1.1.4     purrr_1.0.2     readr_2.1.5     tidyr_1.3.1    \n [9] tibble_3.2.1    ggplot2_3.5.0   tidyverse_2.0.0\n\nloaded via a namespace (and not attached):\n [1] gtable_0.3.4      jsonlite_1.8.8    crayon_1.5.2      compiler_4.3.3   \n [5] tidyselect_1.2.0  scales_1.3.0      yaml_2.3.8        fastmap_1.1.1    \n [9] R6_2.5.1          labeling_0.4.3    generics_0.1.3    knitr_1.45       \n[13] htmlwidgets_1.6.4 munsell_0.5.0     pillar_1.9.0      tzdb_0.4.0       \n[17] rlang_1.1.3       utf8_1.2.4        stringi_1.8.3     xfun_0.42        \n[21] timechange_0.3.0  cli_3.6.2         withr_3.0.0       magrittr_2.0.3   \n[25] digest_0.6.34     grid_4.3.3        rstudioapi_0.15.0 hms_1.1.3        \n[29] lifecycle_1.0.4   vctrs_0.6.5       evaluate_0.23     glue_1.7.0       \n[33] farver_2.1.1      codetools_0.2-19  fansi_1.0.6       colorspace_2.1-0 \n[37] rmarkdown_2.25    tools_4.3.3       pkgconfig_2.0.3   htmltools_0.5.7  \n```\n\n\n:::\n:::\n\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}