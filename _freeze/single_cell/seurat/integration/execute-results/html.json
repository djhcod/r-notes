{
  "hash": "53528370b23e70a7a44a4440e53c4839",
  "result": {
    "markdown": "# 整合（integration） {#sec-Single-cell_data_integration}\n\n> 原文：[*Introduction to scRNA-seq integration*](https://satijalab.org/seurat/articles/integration_introduction)\n>\n> 原文发布日期：2023年10月31日\n\n::: callout-tip\n本篇主要介绍来自不同样本类型的单细胞数据的整合。对于如何整合不同测序技术的单细胞数据集，参考Seurat官方文档：[*Integrative analysis in Seurat v5*](https://satijalab.org/seurat/articles/seurat5_integration)。\n:::\n\nIntegration of single-cell sequencing datasets, for example across experimental batches, donors, or conditions, is often an important step in scRNA-seq workflows. Integrative analysis can help to **match shared cell types and states across datasets**, which can boost statistical power, and most importantly, facilitate accurate comparative analysis across datasets. In previous versions of Seurat we introduced methods for integrative analysis, including our 'anchor-based' integration workflow. Many labs have also published powerful and pioneering methods, including [Harmony](https://portals.broadinstitute.org/harmony/) and [scVI](https://docs.scvi-tools.org/en/stable/index.html), for integrative analysis.\n\n数据整合的目标：\n\nThe following tutorial is designed to give you an overview of the kinds of comparative analyses on complex cell types that are possible using the Seurat integration procedure. Here, we address a few key goals:\n\n-   Identify **cell subpopulations** that are present in both datasets\n\n-   Obtain **cell type markers** that are conserved in both control and stimulated cells\n\n-   **Compare the datasets** to find cell-type specific responses to stimulation\n\n## 数据读取和分层\n\n::: {.callout-note collapse=\"true\" appearance=\"minimal\" icon=\"false\"}\n### 在线读取（可能需要全局代理）\n\n\n::: {.cell hash='integration_cache/html/unnamed-chunk-1_4259f900996d24c302bead7d4bd5c2b3'}\n\n````{.cell-code}\n```{{r}}\n#| eval: false\nlibrary(Seurat)\nlibrary(SeuratData)\nInstallData(\"ifnb\")\nifnb <- LoadData(\"ifnb\")\n```\n````\n:::\n\n:::\n\n从本地下载好的数据读取：\n\n\n::: {.cell hash='integration_cache/html/unnamed-chunk-2_76f2aa1541f13daa997395432581125e'}\n\n```{.r .cell-code}\nlibrary(Seurat)\nifnb <- readRDS(\"data/seurat_official/pbmc_ifnb.rds\")\nifnb\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nAn object of class Seurat \n14053 features across 13999 samples within 1 assay \nActive assay: RNA (14053 features, 0 variable features)\n 2 layers present: counts, data\n```\n:::\n\n```{.r .cell-code}\nhead(ifnb@meta.data, 5)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n                  orig.ident nCount_RNA nFeature_RNA stim seurat_annotations\nAAACATACATTTCC.1 IMMUNE_CTRL       3017          877 CTRL          CD14 Mono\nAAACATACCAGAAA.1 IMMUNE_CTRL       2481          713 CTRL          CD14 Mono\nAAACATACCTCGCT.1 IMMUNE_CTRL       3420          850 CTRL          CD14 Mono\nAAACATACCTGGTA.1 IMMUNE_CTRL       3156         1109 CTRL                pDC\nAAACATACGATGAA.1 IMMUNE_CTRL       1868          634 CTRL       CD4 Memory T\n```\n:::\n\n```{.r .cell-code}\ntable(ifnb$stim)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\nCTRL STIM \n6548 7451 \n```\n:::\n:::\n\n\n![](images/截屏2023-11-27%2012.49.37.png)\n\nThe object contains data from human PBMC from two conditions, **interferon-stimulated** and **control** cells (stored in the `stim` column in the object metadata). We will aim to integrate the two conditions together, so that we can jointly identify cell subpopulations across datasets, and then explore how each group differs across conditions\n\nIn previous versions of Seurat, we would require the data to be represented as two different Seurat objects. **In Seurat v5, we keep all the data in one object, but simply split it into multiple 'layers'**. To learn more about layers, check out our [Seurat object interaction vignette](https://satijalab.org/seurat/articles/interaction_vignette).\n\n::: callout-important\nSeurat v5 assays store data in **layers**. These layers can store:\n\n-   raw, un-normalized counts (`layer='counts'`)\n\n-   normalized data (`layer='data'`)\n\n-   z-scored/variance-stabilized data (`layer='scale.data'`).\n:::\n\n**split the RNA measurements into two layers one for control cells, one for stimulated cells:**\n\n\n::: {.cell hash='integration_cache/html/unnamed-chunk-3_cdf052a9c3657bcf3f255f18204908cd'}\n\n```{.r .cell-code}\nlibrary(Seurat)\nifnb[[\"RNA\"]] <- split(ifnb[[\"RNA\"]], \n                       f = ifnb$stim) # 按照meta.data中的“stim”列进行分割\nifnb\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nAn object of class Seurat \n14053 features across 13999 samples within 1 assay \nActive assay: RNA (14053 features, 0 variable features)\n 4 layers present: counts.CTRL, counts.STIM, data.CTRL, data.STIM\n```\n:::\n:::\n\n\n现在可以发现`ifnb`被分为了4个layer，此前是2个layer（`counts`和`data`）：\n\n![](images/截屏2023-11-27%2011.55.48.png)\n\n## 不进行整合的情况下的数据处理\n\n进行标准的数据处理流程：\n\n\n::: {.cell hash='integration_cache/html/unnamed-chunk-4_217249d68077f9b90661a1346f559aed'}\n\n```{.r .cell-code}\nifnb <- NormalizeData(ifnb)\nifnb <- FindVariableFeatures(ifnb)\nifnb <- ScaleData(ifnb)\nifnb <- RunPCA(ifnb)\nifnb <- FindNeighbors(ifnb, dims = 1:30, reduction = \"pca\")\nifnb <- FindClusters(ifnb, \n                     resolution = 2, \n                     cluster.name = \"unintegrated_clusters\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nModularity Optimizer version 1.3.0 by Ludo Waltman and Nees Jan van Eck\n\nNumber of nodes: 13999\nNumber of edges: 555146\n\nRunning Louvain algorithm...\nMaximum modularity in 10 random starts: 0.8153\nNumber of communities: 26\nElapsed time: 1 seconds\n```\n:::\n\n```{.r .cell-code}\nifnb <- RunUMAP(ifnb, \n                dims = 1:30, \n                reduction = \"pca\", \n                reduction.name = \"umap.unintegrated\")\n```\n:::\n\n\n分别按照**样本分组（\"stim\"**）**和**细胞聚类情况（\"seurat_clusters\"**）**着色绘制UMAP图：\n\n\n::: {.cell hash='integration_cache/html/fig-未整合_01ef1bf20181b2d65d4ac058a26a015b'}\n\n```{.r .cell-code}\nDimPlot(ifnb, \n        reduction = \"umap.unintegrated\", \n        group.by = c(\"stim\", \"seurat_clusters\"))\n```\n\n::: {.cell-output-display}\n![未整合时的细胞分群情况（左：按照刺激条件着色；右：按照细胞聚类情况着色）](integration_files/figure-html/fig-未整合-1.png){#fig-未整合 width=960}\n:::\n:::\n\n\n可以发现：The resulting clusters are defined **both by cell type** **and stimulation condition**, which creates challenges for downstream analysis.\n\n## 进行数据整合\n\nWe now aim to integrate data from the two conditions, so that cells from the same cell type/subpopulation will cluster together.\n\nWe often refer to this procedure as intergration/alignment. When aligning two genome sequences together, identification of shared/homologous regions can help to interpret differences between the sequences as well. Similarly for scRNA-seq integration, our goal is **not to remove biological differences across conditions**, **but to learn shared cell types/states in an initial step-specifically** because that will enable us to compare control stimulated and control profiles for these individual cell types.\n\nThe Seurat v5 integration procedure aims to return a single dimensional reduction that captures the shared sources of variance across multiple layers, so that cells in a similar biological state will cluster. The method returns a dimensional reduction (i.e. `integrated.cca`) which can be used for visualization and unsupervised clustering analysis. For evaluating performance, we can use cell type labels that are pre-loaded in the `seurat_annotations` metadata column.\n\n\n::: {.cell hash='integration_cache/html/unnamed-chunk-6_8034ebad4e50827b35b3521ee2994d38'}\n\n```{.r .cell-code}\n# 整合，比较耗时间，进度条会一直显示0%直至运算完成\nifnb_integrated <- IntegrateLayers(ifnb, \n                                   method = CCAIntegration, \n                                   orig.reduction = \"pca\", \n                                   new.reduction = \"integrated.cca\", # 整合后新的降维数据的名称\n                                   verbose = FALSE)\n```\n:::\n\n\n可以看到经过整合的Seurat对象的降维（\"reduction\"）中多出了整合后的降维（\"integrated.cca\"）：\n\n![](images/截屏2023-11-28%2009.57.11.png)\n\n目前的RNA assay的counts和data数据仍然按照“CTRL”和“STIM”被分成了4个layer。因此，我们通过JoinLayers进一步合并这些layers：\n\n\n::: {.cell hash='integration_cache/html/unnamed-chunk-7_2122bb36fe223110327dbd4efb42c8cd'}\n\n```{.r .cell-code}\n# 目前RNA assay包含的layers\nLayers(ifnb_integrated[[\"RNA\"]])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"counts.CTRL\" \"counts.STIM\" \"data.CTRL\"   \"data.STIM\"   \"scale.data\" \n```\n:::\n\n```{.r .cell-code}\n# 合并RNA assay的layers\nifnb_integrated[[\"RNA\"]] <- JoinLayers(ifnb_integrated[[\"RNA\"]])\n# 再次检查RNA assay包含的layers\nLayers(ifnb_integrated[[\"RNA\"]])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"data\"       \"counts\"     \"scale.data\"\n```\n:::\n:::\n\n\n可以看到，目前的RNA assay只包含三个layers：data\"、\"counts\"、\"scale.data\"。\n\n::: callout-warning\nOnce integrative analysis is complete, you can rejoin the layers - which collapses the individual datasets together and recreates the original `counts` and `data` layers. **You will need to do this before performing any differential expression analysis**. However, you can always resplit the layers in case you would like to reperform integrative analysis.\n:::\n\n### 整合后重新聚类、降维\n\n\n::: {.cell hash='integration_cache/html/fig-整合后_c2898705b6f8768d8a83a237e02af729'}\n\n```{.r .cell-code}\n# 重新聚类\nifnb_integrated <- FindNeighbors(ifnb_integrated, \n                                 reduction = \"integrated.cca\", #更改降维来源为\"integrated.cca\"\n                                 dims = 1:30)\nifnb_integrated <- FindClusters(ifnb_integrated, resolution = 1)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nModularity Optimizer version 1.3.0 by Ludo Waltman and Nees Jan van Eck\n\nNumber of nodes: 13999\nNumber of edges: 590406\n\nRunning Louvain algorithm...\nMaximum modularity in 10 random starts: 0.8448\nNumber of communities: 18\nElapsed time: 1 seconds\n```\n:::\n\n```{.r .cell-code}\n# 重新降维\nifnb_integrated <- RunUMAP(ifnb_integrated, \n                           dims = 1:30, \n                           reduction = \"integrated.cca\") #更改降维来源为\"integrated.cca\"\n\n# Visualization：\nDimPlot(ifnb_integrated, \n        reduction = \"umap\", \n        group.by = c(\"stim\", \"seurat_annotations\"))\n```\n\n::: {.cell-output-display}\n![整合后的细胞分群情况（左：按照刺激条件着色；右：按照细胞聚类情况着色）](integration_files/figure-html/fig-整合后-1.png){#fig-整合后 width=960}\n:::\n:::\n\n\n可以看到和 @fig-未整合 相比，在整合后，细胞就只按照细胞类型进行聚类了。\n\n也可以按照刺激条件（\"stim\"）绘制分面图，分别展示刺激组和对照组的细胞分群情况：\n\n\n::: {.cell hash='integration_cache/html/unnamed-chunk-9_be0b22749ba8a3a65257e09fcc7d5d41'}\n\n```{.r .cell-code}\nDimPlot(ifnb_integrated, reduction = \"umap\", split.by = \"stim\")\n```\n\n::: {.cell-output-display}\n![](integration_files/figure-html/unnamed-chunk-9-1.png){width=960}\n:::\n:::\n\n\n可以看到，和上面的结论一致，两种条件下的细胞分群基本一致。\n\n## 执行`SCTransform`标准化流程之后的整合\n\nAs an alternative to log-normalization, Seurat also includes support for preprocessing of scRNA-seq using the `SCTransform()` workflow（ @sec-sctransform ）. The `IntegrateLayers` function also supports SCTransform-normalized data, by setting the `normalization.method` parameter, as shown below.\n\n### 不进行整合的情况下的数据分析\n\n\n::: {.cell hash='integration_cache/html/fig-sctransform_未整合_74f63a8e30dc579164b6ca9aeebc1e97'}\n\n```{.r .cell-code}\nrm(list = ls())\n\n# 重新载入原始的Seurat对象ifnb\nlibrary(Seurat)\nifnb <- readRDS(\"data/seurat_official/pbmc_ifnb.rds\")\n\n# 同样先拆分数据集，然后进行无整合情况下的降维\nifnb[[\"RNA\"]] <- split(ifnb[[\"RNA\"]], f = ifnb$stim)\nifnb <- SCTransform(ifnb, verbose = FALSE)\nifnb <- RunPCA(ifnb)\nifnb <- RunUMAP(ifnb, dims = 1:30)\nDimPlot(ifnb, \n        reduction = \"umap\", \n        group.by = c(\"stim\", \"seurat_annotations\"))\n```\n\n::: {.cell-output-display}\n![未整合时的细胞分群情况（左：按照刺激条件着色；右：按照细胞聚类情况着色）](integration_files/figure-html/fig-sctransform_未整合-1.png){#fig-sctransform_未整合 width=960}\n:::\n:::\n\n\n可以看到，如果不进行整合，不同样本（STIM vs. STIM）的细胞类型差异很大。\n\n### 进行整合 {#sec-integration_after_sct}\n\n同样通过`IntegrateLayers`函数进行数据整合，只不过需要将默认的标准化方法由\"LogNormalize\"指定为\"SCT\"（`normalization.method = \"SCT\"`）：\n\n\n::: {.cell hash='integration_cache/html/unnamed-chunk-11_a27731d1c41cd8fca82819ab470808d2'}\n\n```{.r .cell-code}\nifnb_integrated <- IntegrateLayers(ifnb, \n                                   method = CCAIntegration, \n                                   normalization.method = \"SCT\", \n                                   verbose = F)\n# 整合后重新合并RNA的layers\nLayers(ifnb_integrated[[\"RNA\"]])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"counts.CTRL\" \"counts.STIM\" \"data.CTRL\"   \"data.STIM\"  \n```\n:::\n\n```{.r .cell-code}\nifnb_integrated[[\"RNA\"]] <- JoinLayers(ifnb_integrated[[\"RNA\"]])\nLayers(ifnb_integrated[[\"RNA\"]])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"data\"   \"counts\"\n```\n:::\n:::\n\n\n![](images/截屏2023-11-28%2009.16.10.png)\n\n可以看到经过整合的Seurat对象的降维（\"reduction\"）信息中多出了整合后的降维（\"integrated.dr\"）。\n\n### 整合后聚类\n\n\n::: {.cell hash='integration_cache/html/unnamed-chunk-12_2f3efe4fc091251dd7dee2a42cebf865'}\n\n```{.r .cell-code}\nifnb_integrated <- FindNeighbors(ifnb_integrated, \n                                 reduction = \"integrated.dr\", #更改降维来源为\"integrated.dr\"\n                                 dims = 1:30)\nifnb_integrated <- FindClusters(ifnb_integrated, \n                                resolution = 0.6)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nModularity Optimizer version 1.3.0 by Ludo Waltman and Nees Jan van Eck\n\nNumber of nodes: 13999\nNumber of edges: 527905\n\nRunning Louvain algorithm...\nMaximum modularity in 10 random starts: 0.9058\nNumber of communities: 19\nElapsed time: 1 seconds\n```\n:::\n\n```{.r .cell-code}\nifnb_integrated <- RunUMAP(ifnb_integrated, \n                           dims = 1:30, \n                           reduction = \"integrated.dr\")\nDimPlot(ifnb_integrated, \n        reduction = \"umap\", \n        group.by = c(\"stim\", \"seurat_annotations\"))\n```\n\n::: {.cell-output-display}\n![](integration_files/figure-html/unnamed-chunk-12-1.png){width=960}\n:::\n:::\n\n\n可以看到和 @fig-sctransform_未整合 相比，整合后在样本间的细胞类型基本均匀分布。\n\n### 保存整合后的Seurat对象\n\n\n::: {.cell hash='integration_cache/html/unnamed-chunk-13_4933610c119e6c9848b45d3e5beb2f07'}\n\n```{.r .cell-code}\nsaveRDS(ifnb_integrated, file = \"output/seurat_official/ifnb_integrated.rds\")\n```\n:::\n\n\n------------------------------------------------------------------------\n\n::: {.callout-note collapse=\"true\" icon=\"false\"}\n## Session Info\n\n\n::: {.cell hash='integration_cache/html/unnamed-chunk-14_9c18d6be3134307a483f97d7659009b4'}\n\n```{.r .cell-code}\nsessionInfo()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nR version 4.3.2 (2023-10-31)\nPlatform: aarch64-apple-darwin20 (64-bit)\nRunning under: macOS Sonoma 14.2.1\n\nMatrix products: default\nBLAS:   /Library/Frameworks/R.framework/Versions/4.3-arm64/Resources/lib/libRblas.0.dylib \nLAPACK: /Library/Frameworks/R.framework/Versions/4.3-arm64/Resources/lib/libRlapack.dylib;  LAPACK version 3.11.0\n\nlocale:\n[1] en_US.UTF-8/en_US.UTF-8/en_US.UTF-8/C/en_US.UTF-8/en_US.UTF-8\n\ntime zone: Asia/Shanghai\ntzcode source: internal\n\nattached base packages:\n[1] stats     graphics  grDevices utils     datasets  methods   base     \n\nother attached packages:\n[1] Seurat_5.0.1       SeuratObject_5.0.1 sp_2.1-2          \n\nloaded via a namespace (and not attached):\n  [1] RColorBrewer_1.1-3          rstudioapi_0.15.0          \n  [3] jsonlite_1.8.8              magrittr_2.0.3             \n  [5] spatstat.utils_3.0-4        farver_2.1.1               \n  [7] rmarkdown_2.25              zlibbioc_1.48.0            \n  [9] vctrs_0.6.5                 ROCR_1.0-11                \n [11] DelayedMatrixStats_1.24.0   spatstat.explore_3.2-5     \n [13] RCurl_1.98-1.14             S4Arrays_1.2.0             \n [15] htmltools_0.5.7             SparseArray_1.2.3          \n [17] sctransform_0.4.1           parallelly_1.36.0          \n [19] KernSmooth_2.23-22          htmlwidgets_1.6.4          \n [21] ica_1.0-3                   plyr_1.8.9                 \n [23] plotly_4.10.4               zoo_1.8-12                 \n [25] igraph_1.6.0                mime_0.12                  \n [27] lifecycle_1.0.4             pkgconfig_2.0.3            \n [29] Matrix_1.6-5                R6_2.5.1                   \n [31] fastmap_1.1.1               GenomeInfoDbData_1.2.11    \n [33] MatrixGenerics_1.14.0       fitdistrplus_1.1-11        \n [35] future_1.33.1               shiny_1.8.0                \n [37] digest_0.6.34               colorspace_2.1-0           \n [39] patchwork_1.2.0             S4Vectors_0.40.2           \n [41] tensor_1.5                  RSpectra_0.16-1            \n [43] irlba_2.3.5.1               GenomicRanges_1.54.1       \n [45] labeling_0.4.3              progressr_0.14.0           \n [47] fansi_1.0.6                 spatstat.sparse_3.0-3      \n [49] httr_1.4.7                  polyclip_1.10-6            \n [51] abind_1.4-5                 compiler_4.3.2             \n [53] withr_3.0.0                 fastDummies_1.7.3          \n [55] MASS_7.3-60.0.1             DelayedArray_0.28.0        \n [57] tools_4.3.2                 lmtest_0.9-40              \n [59] httpuv_1.6.13               future.apply_1.11.1        \n [61] goftest_1.2-3               glmGamPoi_1.14.0           \n [63] glue_1.7.0                  nlme_3.1-164               \n [65] promises_1.2.1              grid_4.3.2                 \n [67] Rtsne_0.17                  cluster_2.1.6              \n [69] reshape2_1.4.4              generics_0.1.3             \n [71] gtable_0.3.4                spatstat.data_3.0-4        \n [73] tidyr_1.3.0                 data.table_1.14.10         \n [75] XVector_0.42.0              utf8_1.2.4                 \n [77] BiocGenerics_0.48.1         spatstat.geom_3.2-7        \n [79] RcppAnnoy_0.0.21            ggrepel_0.9.5              \n [81] RANN_2.6.1                  pillar_1.9.0               \n [83] stringr_1.5.1               spam_2.10-0                \n [85] RcppHNSW_0.5.0              later_1.3.2                \n [87] splines_4.3.2               dplyr_1.1.4                \n [89] lattice_0.22-5              survival_3.5-7             \n [91] deldir_2.0-2                tidyselect_1.2.0           \n [93] miniUI_0.1.1.1              pbapply_1.7-2              \n [95] knitr_1.45                  gridExtra_2.3              \n [97] IRanges_2.36.0              SummarizedExperiment_1.32.0\n [99] scattermore_1.2             stats4_4.3.2               \n[101] xfun_0.41                   Biobase_2.62.0             \n[103] matrixStats_1.2.0           stringi_1.8.3              \n[105] lazyeval_0.2.2              yaml_2.3.8                 \n[107] evaluate_0.23               codetools_0.2-19           \n[109] tibble_3.2.1                cli_3.6.2                  \n[111] uwot_0.1.16                 xtable_1.8-4               \n[113] reticulate_1.34.0           munsell_0.5.0              \n[115] Rcpp_1.0.12                 GenomeInfoDb_1.38.5        \n[117] globals_0.16.2              spatstat.random_3.2-2      \n[119] png_0.1-8                   parallel_4.3.2             \n[121] ellipsis_0.3.2              ggplot2_3.4.4              \n[123] dotCall64_1.1-1             sparseMatrixStats_1.14.0   \n[125] bitops_1.0-7                listenv_0.9.0              \n[127] viridisLite_0.4.2           scales_1.3.0               \n[129] ggridges_0.5.5              crayon_1.5.2               \n[131] leiden_0.4.3.1              purrr_1.0.2                \n[133] rlang_1.1.3                 cowplot_1.1.2              \n```\n:::\n:::\n\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}