{
  "hash": "a6d96a3166a0061cdca86e78863198a1",
  "result": {
    "markdown": "# Seurat v5单细胞数据整合分析 {#sec-Integrated_analysis_of_seurat-v5}\n\n> 原文：[*Integrative analysis in Seurat v5*](https://satijalab.org/seurat/articles/seurat5_integration)\n>\n> 原文发布日期：2023年10月31日\n\nIntegration of single-cell sequencing datasets, for example across **experimental batches**, **donors**, or **conditions**, is often an important step in scRNA-seq workflows. Integrative analysis can help to **match shared cell types and states across datasets**, which can **boost statistical power**, and most importantly, **facilitate accurate comparative analysis across datasets**.\n\nIn previous versions of Seurat we introduced methods for integrative analysis, including our 'anchor-based' integration workflow. Many labs have also published powerful and pioneering methods, including [Harmony](https://github.com/immunogenomics/harmony) and [scVI](https://yoseflab.github.io/software/scvi-tools/), for integrative analysis. We recognize that while the goal of matching shared cell types across datasets may be important for many problems, users may also be concerned about which method to use, or that integration could result in a loss of biological resolution.\n\nIn Seurat v5, we introduce more flexible and streamlined infrastructure to run different integration algorithms with a single line of code. This makes it easier to explore the results of different integration methods, and to compare these results to a workflow that excludes integration steps.\n\nFor this vignette, we use a dataset of human PBMC profiled with **seven different technologies** [@ding2020], profiled as part of a systematic comparative analysis (`pbmcsca`). The data is available as part of our SeuratData package.\n\n![](images/截屏2023-11-28%2021.02.46.png){width=\"526\"}\n\n## 加载数据\n\n::: {.callout-note collapse=\"true\" appearance=\"minimal\" icon=\"false\"}\n###### 在线读取（可能需要全局代理）\n\n\n::: {.cell hash='integrative_analysis_in_seurat_v5_cache/html/unnamed-chunk-1_6f1ab726637bf7df24d2a88eccdaf400'}\n\n````{.cell-code}\n```{{r}}\n#| eval: false\nlibrary(SeuratData)\nInstallData(\"pbmcsca\")\nlibrary(Seurat)\nobj <- LoadData(\"pbmcsca\")\n```\n````\n:::\n\n:::\n\n从本地下载好的数据读取：\n\n\n::: {.cell hash='integrative_analysis_in_seurat_v5_cache/html/unnamed-chunk-2_7206c907a9ad08694a9e68e5625bdc30'}\n\n```{.r .cell-code}\nlibrary(Seurat)\nobj <- readRDS(\"data/seurat_official/pbmcsca.rds\")\nobj\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nAn object of class Seurat \n33694 features across 31021 samples within 1 assay \nActive assay: RNA (33694 features, 0 variable features)\n 2 layers present: counts, data\n```\n:::\n\n```{.r .cell-code}\ncolnames(obj)[1:8]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"pbmc1_SM2_Cell_108\" \"pbmc1_SM2_Cell_115\" \"pbmc1_SM2_Cell_133\"\n[4] \"pbmc1_SM2_Cell_142\" \"pbmc1_SM2_Cell_143\" \"pbmc1_SM2_Cell_144\"\n[7] \"pbmc1_SM2_Cell_146\" \"pbmc1_SM2_Cell_148\"\n```\n:::\n\n```{.r .cell-code}\nrownames(obj)[1:5]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"TSPAN6\"   \"TNMD\"     \"DPM1\"     \"SCYL3\"    \"C1orf112\"\n```\n:::\n\n```{.r .cell-code}\nhead(obj@meta.data, 5)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n                   orig.ident nCount_RNA nFeature_RNA nGene   nUMI\npbmc1_SM2_Cell_108      pbmc1     437125         2200  2200 437125\npbmc1_SM2_Cell_115      pbmc1     335596         2438  2438 335596\npbmc1_SM2_Cell_133      pbmc1     302204         1874  1874 302204\npbmc1_SM2_Cell_142      pbmc1     377420         2480  2480 377420\npbmc1_SM2_Cell_143      pbmc1     385514         2196  2196 385514\n                         percent.mito Cluster         CellType Experiment\npbmc1_SM2_Cell_108 0.0297434465355702       0 Cytotoxic T cell      pbmc1\npbmc1_SM2_Cell_115 0.0311521658159055       0 Cytotoxic T cell      pbmc1\npbmc1_SM2_Cell_133 0.0431128105727693       0 Cytotoxic T cell      pbmc1\npbmc1_SM2_Cell_142 0.0260323569927476       0 Cytotoxic T cell      pbmc1\npbmc1_SM2_Cell_143 0.0404759383962183       0 Cytotoxic T cell      pbmc1\n                       Method\npbmc1_SM2_Cell_108 Smart-seq2\npbmc1_SM2_Cell_115 Smart-seq2\npbmc1_SM2_Cell_133 Smart-seq2\npbmc1_SM2_Cell_142 Smart-seq2\npbmc1_SM2_Cell_143 Smart-seq2\n```\n:::\n\n```{.r .cell-code}\ntable(obj$Method)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\n  10x Chromium (v2) 10x Chromium (v2) A 10x Chromium (v2) B   10x Chromium (v3) \n               3362                3222                3222                3222 \n           CEL-Seq2            Drop-seq             inDrops            Seq-Well \n                526                6584                6584                3773 \n         Smart-seq2 \n                526 \n```\n:::\n:::\n\n\nThe object contains data from **nine different batches** (stored in the `Method` column in the object metadata), representing **seven different technologies**. We will aim to integrate the different batches together.\n\n## 数据质控\n\n过滤低质量细胞：\n\n\n::: {.cell hash='integrative_analysis_in_seurat_v5_cache/html/unnamed-chunk-3_354b741552fc5c2f25fd6c5308dc3871'}\n\n```{.r .cell-code}\nobj <- subset(obj, nFeature_RNA > 1000)\n```\n:::\n\n\n这个地方为了验证后面整合的效果对细胞类型提前进行了注释。\n\n\n::: {.cell hash='integrative_analysis_in_seurat_v5_cache/html/unnamed-chunk-4_e627a8e07b53c608d0e5c932230a68f8'}\n\n```{.r .cell-code}\ntable(obj$CellType)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\n                     B cell              CD14+ monocyte \n                       1525                        1557 \n             CD16+ monocyte                 CD4+ T cell \n                        404                        3018 \n           Cytotoxic T cell              Dendritic cell \n                       2791                         281 \n              Megakaryocyte         Natural killer cell \n                          9                         763 \nPlasmacytoid dendritic cell                  Unassigned \n                         78                           8 \n```\n:::\n:::\n\n\n## 分割数据\n\nIn previous versions of Seurat, if we want to integrate this data, we would require the data to be represented as nine different Seurat objects. When using Seurat v5 assays, we can instead keep all the data in one object, but simply split the layers:\n\n\n::: {.cell hash='integrative_analysis_in_seurat_v5_cache/html/unnamed-chunk-5_c7f13ec95e35450b05a9981b4af6dad6'}\n\n```{.r .cell-code}\nobj[[\"RNA\"]] <- split(obj[[\"RNA\"]], f = obj$Method)\nobj\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nAn object of class Seurat \n33694 features across 10434 samples within 1 assay \nActive assay: RNA (33694 features, 0 variable features)\n 18 layers present: counts.Smart-seq2, counts.CEL-Seq2, counts.10x_Chromium_v2_A, counts.10x_Chromium_v2_B, counts.10x_Chromium_v3, counts.Drop-seq, counts.Seq-Well, counts.inDrops, counts.10x_Chromium_v2, data.Smart-seq2, data.CEL-Seq2, data.10x_Chromium_v2_A, data.10x_Chromium_v2_B, data.10x_Chromium_v3, data.Drop-seq, data.Seq-Well, data.inDrops, data.10x_Chromium_v2\n```\n:::\n:::\n\n\nAfter splitting, there are now **18 layers** (**a `counts` and `data` layer for each batch**).\n\n## 未整合情况下的标准scRNA-seq分析流程\n\n### 标准化、找高变基因、归一化、降维\n\nWe can now run a standard scRNA-seq analysis (i.e. without integration). Note that since the data is split into layers, normalization and variable feature identification is performed for each batch independently (a consensus set of variable features is automatically identified).\n\n\n::: {.cell hash='integrative_analysis_in_seurat_v5_cache/html/unnamed-chunk-6_ee0c4b8c6b8ae42e647bab4bb58e5064'}\n\n```{.r .cell-code}\nobj <- NormalizeData(obj)\nobj <- FindVariableFeatures(obj)\nobj <- ScaleData(obj)\nobj <- RunPCA(obj)\nobj <- RunUMAP(obj, \n               dims = 1:30, \n               reduction = \"pca\", \n               reduction.name = \"umap.unintegrated\") # name to store dimensional reduction in the Seurat object\n```\n:::\n\n\n### 聚类、可视化\n\nWe can now visualize the results of a standard analysis without integration. Note that cells are grouping both by **cell type** and by underlying **method**. While a UMAP analysis is just a visualization of this, clustering this dataset would return predominantly batch-specific clusters. Especially if previous cell-type annotations were not available, this would make downstream analysis extremely challenging.\n\n\n::: {.cell hash='integrative_analysis_in_seurat_v5_cache/html/unnamed-chunk-7_f62adc5974b02f6a1843ca545640bd03'}\n\n```{.r .cell-code}\nobj <- FindNeighbors(obj, dims = 1:30, reduction = \"pca\")\nobj <- FindClusters(obj, resolution = 2, cluster.name = \"unintegrated_clusters\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nModularity Optimizer version 1.3.0 by Ludo Waltman and Nees Jan van Eck\n\nNumber of nodes: 10434\nNumber of edges: 412660\n\nRunning Louvain algorithm...\nMaximum modularity in 10 random starts: 0.8981\nNumber of communities: 48\nElapsed time: 0 seconds\n```\n:::\n\n```{.r .cell-code}\nDimPlot(obj, \n        reduction = \"umap.unintegrated\", \n        group.by = c(\"Method\", \"CellType\"))\n```\n\n::: {.cell-output-display}\n![](integrative_analysis_in_seurat_v5_files/figure-html/unnamed-chunk-7-1.png){width=960}\n:::\n:::\n\n\n可以看到，不同的测序技术间的细胞类型差异较大。因此需要对数据进行整合。\n\n## 数据整合 {#sec-sc_integration}\n\nSeurat v5 enables streamlined integrative analysis using the `IntegrateLayers` function. The method currently supports **five integration methods**. Each of these methods performs integration in low-dimensional space, and **returns a dimensional reduction** (i.e. `integrated.rpca`) that aims to co-embed shared cell types across batches:\n\n-   **Anchor-based CCA integration** (`method=CCAIntegration`)\n\n-   **Anchor-based RPCA integration** (`method=RPCAIntegration`)\n\n-   **Harmony** (`method=HarmonyIntegration`)\n\n-   **FastMNN** (`method= FastMNNIntegration`)\n\n-   **scVI** (`method=scVIIntegration`)\n\nNote that our anchor-based RPCA integration represents a faster and more conservative (less correction) method for integration. For interested users, we discuss this method in more detail in our [previous RPCA vignette](https://satijalab.org/seurat/articles/integration_rpca).\n\nYou can find more detail on each method, and any installation prerequisites, in Seurat's documentation (for example, `?HarmonyIntegration`). For example, harmony整合需要先安装[`harmony`](https://cran.r-project.org/web/packages/harmony/index.html)包（`install.packages(\"harmony\")`）；scVI integration requires `reticulate` which can be installed from CRAN (`install.packages(\"reticulate\")`) as well as `scvi-tools` and its dependencies installed in a conda environment. Please see scVI installation instructions [here](https://docs.scvi-tools.org/en/stable/installation.html).\n\nEach of the following lines perform a new integration using a single line of code:\n\n（这里我们选择其中的`CCAIntegration`和`HarmonyIntegration`两种方式分别对数据进行整合，整合后后的降维信息分别储存在\"integrated.cca\"和\"harmony\"中）\n\n\n::: {.cell hash='integrative_analysis_in_seurat_v5_cache/html/unnamed-chunk-8_870f16b23f8fbfe64d6a6c1c294315d2'}\n\n```{.r .cell-code}\nobj <- IntegrateLayers(\n  object = obj,\n  method = CCAIntegration,\n  orig.reduction = \"pca\",\n  new.reduction = \"integrated.cca\",\n  verbose = FALSE\n)\nnames(obj@reductions)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"pca\"               \"umap.unintegrated\" \"integrated.cca\"   \n```\n:::\n:::\n\n::: {.cell hash='integrative_analysis_in_seurat_v5_cache/html/unnamed-chunk-9_da3ab7e4cff46b9a0a813b3157d65298'}\n\n````{.cell-code}\n```{{r}}\n#| eval: false\nobj <- IntegrateLayers(\n  object = obj, \n  method = RPCAIntegration,\n  orig.reduction = \"pca\", \n  new.reduction = \"integrated.rpca\",\n  verbose = FALSE\n)\nnames(obj@reductions)\n```\n````\n:::\n\n::: {.cell hash='integrative_analysis_in_seurat_v5_cache/html/unnamed-chunk-10_a8f9a63f855f738b23629c7346ec8b5a'}\n\n```{.r .cell-code}\nobj <- IntegrateLayers(\n  object = obj, \n  method = HarmonyIntegration,\n  orig.reduction = \"pca\", \n  new.reduction = \"harmony\",\n  verbose = FALSE\n)\nnames(obj@reductions)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"pca\"               \"umap.unintegrated\" \"integrated.cca\"   \n[4] \"harmony\"          \n```\n:::\n:::\n\n::: {.cell hash='integrative_analysis_in_seurat_v5_cache/html/unnamed-chunk-11_cf941151dc0c5dff330d996c4020b0e1'}\n\n````{.cell-code}\n```{{r}}\n#| eval: false\nobj <- IntegrateLayers(\n  object = obj, \n  method = FastMNNIntegration,\n  new.reduction = \"integrated.mnn\",\n  verbose = FALSE\n)\nnames(obj@reductions)\n```\n````\n:::\n\n::: {.cell hash='integrative_analysis_in_seurat_v5_cache/html/unnamed-chunk-12_228bc0d815251cdf9f4d5fd28e2345e5'}\n\n````{.cell-code}\n```{{r}}\n#| eval: false\nobj <- IntegrateLayers(\n  object = obj, \n  method = scVIIntegration,\n  new.reduction = \"integrated.scvi\",\n  conda_env = \"../miniconda3/envs/scvi-env\", \n  verbose = FALSE\n)\nnames(obj@reductions)\n```\n````\n:::\n\n\n## 重新降维、聚类、可视化\n\n`CCAIntegration`：\n\n\n::: {.cell hash='integrative_analysis_in_seurat_v5_cache/html/unnamed-chunk-13_7ad99618a1d7bf59a8d20a163b6ea8db'}\n\n```{.r .cell-code}\nobj <- RunUMAP(obj, \n               reduction = \"integrated.cca\", \n               dims = 1:30, \n               reduction.name = \"umap.cca\")\nobj <- FindNeighbors(obj, reduction = \"integrated.cca\", dims = 1:30)\nobj <- FindClusters(obj, resolution = 2, cluster.name = \"cca_clusters\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nModularity Optimizer version 1.3.0 by Ludo Waltman and Nees Jan van Eck\n\nNumber of nodes: 10434\nNumber of edges: 617481\n\nRunning Louvain algorithm...\nMaximum modularity in 10 random starts: 0.8039\nNumber of communities: 26\nElapsed time: 1 seconds\n```\n:::\n\n```{.r .cell-code}\ncolnames(obj@meta.data)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] \"orig.ident\"            \"nCount_RNA\"            \"nFeature_RNA\"         \n [4] \"nGene\"                 \"nUMI\"                  \"percent.mito\"         \n [7] \"Cluster\"               \"CellType\"              \"Experiment\"           \n[10] \"Method\"                \"unintegrated_clusters\" \"seurat_clusters\"      \n[13] \"cca_clusters\"         \n```\n:::\n\n```{.r .cell-code}\np1 <- DimPlot(obj,\n              reduction = \"umap.cca\",\n              group.by = c(\"Method\", \"CellType\", \"cca_clusters\"),\n              combine = FALSE, \n              label.size = 2)\n```\n:::\n\n\n`HarmonyIntegration`：\n\n\n::: {.cell hash='integrative_analysis_in_seurat_v5_cache/html/unnamed-chunk-14_01fc3b1c4b38b1c22975fb2fdd91104d'}\n\n```{.r .cell-code}\nobj <- RunUMAP(obj, \n               reduction = \"harmony\", \n               dims = 1:30, \n               reduction.name = \"umap.harmony\")\nobj <- FindNeighbors(obj, reduction = \"harmony\", dims = 1:30)\nobj <- FindClusters(obj, resolution = 2, cluster.name = \"harmony_clusters\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nModularity Optimizer version 1.3.0 by Ludo Waltman and Nees Jan van Eck\n\nNumber of nodes: 10434\nNumber of edges: 459472\n\nRunning Louvain algorithm...\nMaximum modularity in 10 random starts: 0.7900\nNumber of communities: 24\nElapsed time: 0 seconds\n```\n:::\n\n```{.r .cell-code}\ncolnames(obj@meta.data)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] \"orig.ident\"            \"nCount_RNA\"            \"nFeature_RNA\"         \n [4] \"nGene\"                 \"nUMI\"                  \"percent.mito\"         \n [7] \"Cluster\"               \"CellType\"              \"Experiment\"           \n[10] \"Method\"                \"unintegrated_clusters\" \"seurat_clusters\"      \n[13] \"cca_clusters\"          \"harmony_clusters\"     \n```\n:::\n\n```{.r .cell-code}\np2 <- DimPlot(obj,\n              reduction = \"umap.harmony\",\n              group.by = c(\"Method\", \"CellType\", \"harmony_clusters\"),\n              combine = FALSE, \n              label.size = 2)\n```\n:::\n\n\n合并UMAP图：\n\n\n::: {.cell hash='integrative_analysis_in_seurat_v5_cache/html/unnamed-chunk-15_82c9fc2f5e20c55049fca5b75a9a0f44'}\n\n```{.r .cell-code}\nlibrary(patchwork)\nwrap_plots(c(p1, p2), ncol = 2, byrow = F)\n```\n\n::: {.cell-output-display}\n![](integrative_analysis_in_seurat_v5_files/figure-html/unnamed-chunk-15-1.png){width=1248}\n:::\n:::\n\n\n## 检验细胞类型marker基因的表达\n\nWe hope that by simplifying the process of performing integrative analysis, users can more carefully evaluate the biological information retained in the integrated dataset. For example, users can compare the expression of biological markers based on different clustering solutions, or visualize one method's clustering solution on different UMAP visualizations.\n\n\n::: {.cell hash='integrative_analysis_in_seurat_v5_cache/html/unnamed-chunk-16_594593a3211033131947d69b5f7be288'}\n\n```{.r .cell-code}\nlibrary(ggplot2)\np1 <- VlnPlot(obj,\n              features = \"rna_CD8A\", \n              group.by = \"unintegrated_clusters\",\n              pt.size = 0) + \n  NoLegend() + \n  ggtitle(\"CD8A - Unintegrated Clusters\")\np2 <- VlnPlot(obj, \n              \"rna_CD8A\",\n              group.by = \"cca_clusters\",\n              pt.size = 0) + \n  NoLegend() + \n  ggtitle(\"CD8A - CCA Clusters\")\np3 <- VlnPlot(obj, \n              \"rna_CD8A\",\n              group.by = \"harmony_clusters\",\n              pt.size = 0) + \n  NoLegend() + \n  ggtitle(\"CD8A - harmony Clusters\")\np1 | p2 | p3\n```\n\n::: {.cell-output-display}\n![](integrative_analysis_in_seurat_v5_files/figure-html/unnamed-chunk-16-1.png){width=1440}\n:::\n:::\n\n\n## 重新合并layers\n\nOnce integrative analysis is complete, you can rejoin the layers - which collapses the individual datasets together and recreates the original `counts` and `data` layers. **You will need to do this before performing any differential expression analysis**. However, you can always resplit the layers in case you would like to reperform integrative analysis.\n\n\n::: {.cell hash='integrative_analysis_in_seurat_v5_cache/html/unnamed-chunk-17_5624b7679f6e9c27e6d945251573698f'}\n\n```{.r .cell-code}\nobj <- JoinLayers(obj)\nobj\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nAn object of class Seurat \n33694 features across 10434 samples within 1 assay \nActive assay: RNA (33694 features, 2000 variable features)\n 3 layers present: data, counts, scale.data\n 6 dimensional reductions calculated: pca, umap.unintegrated, integrated.cca, harmony, umap.cca, umap.harmony\n```\n:::\n:::\n\n\n## 对`SCTransform`处理后的数据的整合\n\nUsers can also perform integration using sctransform-normalized data (see @sec-sctransform for more information), by first running `SCTransform` normalization, and then s**etting the `normalization.method` argument in `IntegrateLayers`**（和 @sec-integration_after_sct 中一样）。\n\n\n::: {.cell hash='integrative_analysis_in_seurat_v5_cache/html/unnamed-chunk-18_2b082aba34c9655078b8129852a34c29'}\n\n```{.r .cell-code}\nrm(list = ls())\n#重新载入数据、质控、分割\nobj <- readRDS(\"data/seurat_official/pbmcsca.rds\")\nobj <- subset(obj, nFeature_RNA > 1000)\nobj[[\"RNA\"]] <- split(obj[[\"RNA\"]], f = obj$Method)\n# 执行SCTransform\nobj <- SCTransform(obj)\n# 降维\nobj <- RunPCA(obj, npcs = 30, verbose = F)\n# 整合\n#options(future.globals.maxSize = 3e+09)\nobj <- IntegrateLayers(object = obj,\n                       method = CCAIntegration,\n                       normalization.method = \"SCT\",\n                       orig.reduction = \"pca\",\n                       new.reduction = \"integrated.cca\",\n                       verbose = F)\n# 重新降维、聚类、可视化\nobj <- RunUMAP(obj, \n               dims = 1:30, \n               reduction = \"integrated.cca\", \n               reduction.name = \"umap.cca\")\nobj <- FindNeighbors(obj, dims = 1:30, reduction = \"integrated.cca\")\nobj <- FindClusters(obj, resolution = 2, cluster.name = \"cca_clusters\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nModularity Optimizer version 1.3.0 by Ludo Waltman and Nees Jan van Eck\n\nNumber of nodes: 10434\nNumber of edges: 499367\n\nRunning Louvain algorithm...\nMaximum modularity in 10 random starts: 0.8342\nNumber of communities: 26\nElapsed time: 0 seconds\n```\n:::\n\n```{.r .cell-code}\nDimPlot(obj,\n        reduction = \"umap.cca\",\n        group.by = c(\"Method\", \"cca_clusters\"),\n        label.size = 1)\n```\n\n::: {.cell-output-display}\n![](integrative_analysis_in_seurat_v5_files/figure-html/unnamed-chunk-18-1.png){width=960}\n:::\n:::\n\n\n------------------------------------------------------------------------\n\n::: {.callout-note collapse=\"true\" icon=\"false\"}\n## Session Info\n\n\n::: {.cell hash='integrative_analysis_in_seurat_v5_cache/html/unnamed-chunk-19_a1b8c49604a32016ded3ad179a64a7db'}\n::: {.cell-output .cell-output-stdout}\n```\nR version 4.3.2 (2023-10-31)\nPlatform: aarch64-apple-darwin20 (64-bit)\nRunning under: macOS Sonoma 14.2.1\n\nMatrix products: default\nBLAS:   /Library/Frameworks/R.framework/Versions/4.3-arm64/Resources/lib/libRblas.0.dylib \nLAPACK: /Library/Frameworks/R.framework/Versions/4.3-arm64/Resources/lib/libRlapack.dylib;  LAPACK version 3.11.0\n\nlocale:\n[1] en_US.UTF-8/en_US.UTF-8/en_US.UTF-8/C/en_US.UTF-8/en_US.UTF-8\n\ntime zone: Asia/Shanghai\ntzcode source: internal\n\nattached base packages:\n[1] stats     graphics  grDevices utils     datasets  methods   base     \n\nother attached packages:\n[1] ggplot2_3.4.4      patchwork_1.2.0    Seurat_5.0.1       SeuratObject_5.0.1\n[5] sp_2.1-2          \n\nloaded via a namespace (and not attached):\n  [1] RColorBrewer_1.1-3          rstudioapi_0.15.0          \n  [3] jsonlite_1.8.8              magrittr_2.0.3             \n  [5] spatstat.utils_3.0-4        farver_2.1.1               \n  [7] rmarkdown_2.25              zlibbioc_1.48.0            \n  [9] vctrs_0.6.5                 ROCR_1.0-11                \n [11] DelayedMatrixStats_1.24.0   spatstat.explore_3.2-5     \n [13] RCurl_1.98-1.14             S4Arrays_1.2.0             \n [15] htmltools_0.5.7             SparseArray_1.2.3          \n [17] sctransform_0.4.1           parallelly_1.36.0          \n [19] KernSmooth_2.23-22          htmlwidgets_1.6.4          \n [21] ica_1.0-3                   plyr_1.8.9                 \n [23] plotly_4.10.4               zoo_1.8-12                 \n [25] igraph_1.6.0                mime_0.12                  \n [27] lifecycle_1.0.4             pkgconfig_2.0.3            \n [29] Matrix_1.6-5                R6_2.5.1                   \n [31] fastmap_1.1.1               GenomeInfoDbData_1.2.11    \n [33] MatrixGenerics_1.14.0       fitdistrplus_1.1-11        \n [35] future_1.33.1               shiny_1.8.0                \n [37] digest_0.6.34               colorspace_2.1-0           \n [39] S4Vectors_0.40.2            tensor_1.5                 \n [41] RSpectra_0.16-1             irlba_2.3.5.1              \n [43] GenomicRanges_1.54.1        labeling_0.4.3             \n [45] progressr_0.14.0            fansi_1.0.6                \n [47] spatstat.sparse_3.0-3       httr_1.4.7                 \n [49] polyclip_1.10-6             abind_1.4-5                \n [51] compiler_4.3.2              withr_3.0.0                \n [53] fastDummies_1.7.3           MASS_7.3-60.0.1            \n [55] DelayedArray_0.28.0         tools_4.3.2                \n [57] lmtest_0.9-40               httpuv_1.6.13              \n [59] future.apply_1.11.1         goftest_1.2-3              \n [61] glmGamPoi_1.14.0            glue_1.7.0                 \n [63] nlme_3.1-164                promises_1.2.1             \n [65] grid_4.3.2                  Rtsne_0.17                 \n [67] cluster_2.1.6               reshape2_1.4.4             \n [69] generics_0.1.3              gtable_0.3.4               \n [71] spatstat.data_3.0-4         tidyr_1.3.0                \n [73] data.table_1.14.10          XVector_0.42.0             \n [75] utf8_1.2.4                  BiocGenerics_0.48.1        \n [77] spatstat.geom_3.2-7         RcppAnnoy_0.0.21           \n [79] ggrepel_0.9.5               RANN_2.6.1                 \n [81] pillar_1.9.0                stringr_1.5.1              \n [83] spam_2.10-0                 RcppHNSW_0.5.0             \n [85] later_1.3.2                 splines_4.3.2              \n [87] dplyr_1.1.4                 lattice_0.22-5             \n [89] survival_3.5-7              deldir_2.0-2               \n [91] tidyselect_1.2.0            miniUI_0.1.1.1             \n [93] pbapply_1.7-2               knitr_1.45                 \n [95] gridExtra_2.3               IRanges_2.36.0             \n [97] SummarizedExperiment_1.32.0 scattermore_1.2            \n [99] stats4_4.3.2                xfun_0.41                  \n[101] Biobase_2.62.0              matrixStats_1.2.0          \n[103] stringi_1.8.3               lazyeval_0.2.2             \n[105] yaml_2.3.8                  evaluate_0.23              \n[107] codetools_0.2-19            tibble_3.2.1               \n[109] cli_3.6.2                   uwot_0.1.16                \n[111] xtable_1.8-4                reticulate_1.34.0          \n[113] munsell_0.5.0               Rcpp_1.0.12                \n[115] GenomeInfoDb_1.38.5         globals_0.16.2             \n[117] spatstat.random_3.2-2       png_0.1-8                  \n[119] parallel_4.3.2              ellipsis_0.3.2             \n[121] dotCall64_1.1-1             sparseMatrixStats_1.14.0   \n[123] bitops_1.0-7                listenv_0.9.0              \n[125] viridisLite_0.4.2           scales_1.3.0               \n[127] ggridges_0.5.5              crayon_1.5.2               \n[129] leiden_0.4.3.1              purrr_1.0.2                \n[131] rlang_1.1.3                 cowplot_1.1.2              \n```\n:::\n:::\n\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}