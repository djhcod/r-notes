{
  "hash": "c4205b951c2e1d738a778b838962ae31",
  "result": {
    "markdown": "---\ntitle: \"基于参考集的细胞注释\"\n---\n\n\n> 原文：[*Mapping and annotating query datasets*](https://satijalab.org/seurat/articles/integration_mapping)\n>\n> 原文发布日期：2023年10月31日\n\nIn this vignette, we first build an **integrated reference** and then demonstrate how to leverage this reference to annotate new **query datasets**. Generating an integrated reference follows the same workflow described in more detail in the [integration introduction](/single_cell/seurat/integration.qmd). Once generated, this reference can be used to analyze additional query datasets through tasks like cell type label transfer and projecting query cells onto reference UMAPs. Notably, this does not require correction of the underlying raw query data and can therefore be an efficient strategy if a high quality reference is available.\n\n# 构建参考数据集\n\nFor the purposes of this example, we've chosen human pancreatic islet cell datasets produced across four technologies, **CelSeq ([GSE81076](https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE81076)) CelSeq2 ([GSE85241](https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE85241)), Fluidigm C1 ([GSE86469](https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE86469)), and SMART-Seq2 (E-MTAB-5061)**. For convenience, we distribute this dataset through our `SeuratData` package. The metadata contains the technology (`tech` column) and cell type annotations (`celltype` column) for each cell in the four datasets.\n\n## 数据读取\n\n::: {.callout-note collapse=\"true\" appearance=\"minimal\" icon=\"false\"}\n### 在线读取（可能需要全局代理）\n\n\n::: {.cell hash='mapping_and_annotating_query_datasets_cache/html/unnamed-chunk-1_6de20f6101f06fc620404606c1ba0314'}\n\n````{.cell-code}\n```{{r}}\n#| eval: false\nlibrary(SeuratData)\nInstallData(\"panc8\")\nlibrary(Seurat)\npanc8 <- LoadData(\"panc8\")\n```\n````\n:::\n\n:::\n\n从本地下载好的数据读取：\n\n\n::: {.cell hash='mapping_and_annotating_query_datasets_cache/html/unnamed-chunk-2_e25660db8f4311ef1f560cd9e356673a'}\n\n```{.r .cell-code}\npanc8 <- readRDS(\"data/seurat_official/panc8.rds\")\npanc8\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nAn object of class Seurat \n34363 features across 14890 samples within 1 assay \nActive assay: RNA (34363 features, 0 variable features)\n 2 layers present: counts, data\n```\n:::\n\n```{.r .cell-code}\ncolnames(panc8)[1:5]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"D101_5\"  \"D101_7\"  \"D101_10\" \"D101_13\" \"D101_14\"\n```\n:::\n\n```{.r .cell-code}\nrownames(panc8)[1:5]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"A1BG-AS1\" \"A1BG\"     \"A1CF\"     \"A2M-AS1\"  \"A2ML1\"   \n```\n:::\n\n```{.r .cell-code}\nhead(panc8@meta.data, 5)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n        orig.ident nCount_RNA nFeature_RNA   tech replicate assigned_cluster\nD101_5        D101   4615.810         1986 celseq    celseq             <NA>\nD101_7        D101  29001.563         4209 celseq    celseq             <NA>\nD101_10       D101   6707.857         2408 celseq    celseq             <NA>\nD101_13       D101   8797.224         2964 celseq    celseq             <NA>\nD101_14       D101   5032.558         2264 celseq    celseq             <NA>\n        celltype dataset\nD101_5     gamma  celseq\nD101_7    acinar  celseq\nD101_10    alpha  celseq\nD101_13    delta  celseq\nD101_14     beta  celseq\n```\n:::\n\n```{.r .cell-code}\ntable(panc8$tech)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\n    celseq    celseq2 fluidigmc1     indrop  smartseq2 \n      1004       2285        638       8569       2394 \n```\n:::\n:::\n\n\n可以看到，该数据包含了5种单细胞转录组测序技术获得的单细胞数据。\n\nAs a demonstration, we will use a subset of technologies to construct a reference. We will then map the remaining datasets onto this reference. we will use data from **2 technologies** (celseq2和smartseq2) for the reference。\n\n\n::: {.cell hash='mapping_and_annotating_query_datasets_cache/html/unnamed-chunk-3_5962f7fc928ebb3d42b0f6664b422df2'}\n\n```{.r .cell-code}\nlibrary(Seurat)\npancreas.ref <- subset(panc8, tech %in% c(\"celseq2\", \"smartseq2\"))\n# 按照不同的测序技术将表达矩阵分为不同的layer\npancreas.ref[[\"RNA\"]] <- split(pancreas.ref[[\"RNA\"]], \n                               f = pancreas.ref$tech)\n```\n:::\n\n\n![](images/截屏2023-11-28%2011.10.36.png)\n\n## 数据预处理\n\n标准化、找高变基因、归一化、降维、聚类、可视化：\n\n\n::: {.cell hash='mapping_and_annotating_query_datasets_cache/html/unnamed-chunk-4_a775da7a71812dee8c93a2c375afb818'}\n\n```{.r .cell-code}\npancreas.ref <- NormalizeData(pancreas.ref)\npancreas.ref <- FindVariableFeatures(pancreas.ref)\npancreas.ref <- ScaleData(pancreas.ref)\npancreas.ref <- RunPCA(pancreas.ref)\npancreas.ref <- FindNeighbors(pancreas.ref, dims = 1:30)\npancreas.ref <- FindClusters(pancreas.ref)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nModularity Optimizer version 1.3.0 by Ludo Waltman and Nees Jan van Eck\n\nNumber of nodes: 4679\nNumber of edges: 174953\n\nRunning Louvain algorithm...\nMaximum modularity in 10 random starts: 0.9180\nNumber of communities: 19\nElapsed time: 0 seconds\n```\n:::\n\n```{.r .cell-code}\npancreas.ref <- RunUMAP(pancreas.ref, dims = 1:30)\nDimPlot(pancreas.ref, group.by = c(\"celltytpe\", \"tech\"))\n```\n\n::: {.cell-output-display}\n![](mapping_and_annotating_query_datasets_files/figure-html/unnamed-chunk-4-1.png){width=672}\n:::\n:::\n\n::: {.cell hash='mapping_and_annotating_query_datasets_cache/html/unnamed-chunk-5_35e4d50a2d0b695d4c5f3f2d3a232c6d'}\n\n```{.r .cell-code}\nDimPlot(pancreas.ref, split.by = \"tech\")\n```\n\n::: {.cell-output-display}\n![](mapping_and_annotating_query_datasets_files/figure-html/unnamed-chunk-5-1.png){width=960}\n:::\n:::\n\n\n可以看到，不同的测序技术间的细胞类型差异较大。因此需要对数据进行整合，方法同[此前的章节](/single_cell/seurat/integration.qmd)一致。\n\n\n::: {.cell hash='mapping_and_annotating_query_datasets_cache/html/unnamed-chunk-6_e0d4881dd9fbf4245ea54310abd6b465'}\n\n```{.r .cell-code}\npancreas.ref <- IntegrateLayers(object = pancreas.ref, \n                                method = CCAIntegration, \n                                orig.reduction = \"pca\",\n                                new.reduction = \"integrated.cca\", \n                                verbose = FALSE)\n# 重新聚类\npancreas.ref <- FindNeighbors(pancreas.ref, \n                              reduction = \"integrated.cca\",#更改降维来源为\"integrated.cca\"\n                              dims = 1:30)\npancreas.ref <- FindClusters(pancreas.ref)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nModularity Optimizer version 1.3.0 by Ludo Waltman and Nees Jan van Eck\n\nNumber of nodes: 4679\nNumber of edges: 190152\n\nRunning Louvain algorithm...\nMaximum modularity in 10 random starts: 0.8680\nNumber of communities: 15\nElapsed time: 0 seconds\n```\n:::\n\n```{.r .cell-code}\n# 重新降维\npancreas.ref <- RunUMAP(pancreas.ref, \n                        reduction = \"integrated.cca\", #更改降维来源为\"integrated.cca\"\n                        dims = 1:30)\nDimPlot(pancreas.ref, group.by = c(\"tech\", \"celltype\"))\n```\n\n::: {.cell-output-display}\n![](mapping_and_annotating_query_datasets_files/figure-html/unnamed-chunk-6-1.png){width=960}\n:::\n\n```{.r .cell-code}\nDimPlot(pancreas.ref, split.by = \"tech\")\n```\n\n::: {.cell-output-display}\n![](mapping_and_annotating_query_datasets_files/figure-html/unnamed-chunk-6-2.png){width=960}\n:::\n:::\n\n\n可以看到，和此前相比，整合后不再有不同测序技术间细胞类型的差异。\n\n# 基于参考集的细胞注释\n\nSeurat also supports the projection of reference data (or meta data) onto a query object. While many of the methods are conserved (both procedures begin by identifying anchors), there are two important distinctions between data transfer and integration:\n\n1.  In data transfer, Seurat does not correct or modify the query expression data.\n\n2.  In data transfer, Seurat has an option (set by default) to project the PCA structure of a reference onto the query, instead of learning a joint structure with CCA. We generally suggest using this option when projecting data between scRNA-seq datasets.\n\n> Seurat支持将参考数据集的注释信息（meta.data）映射到查询数据集上。基于Seurat的**数据注释映射（data transfer）**和上面的**数据整合（integration）**之间许多步骤都是类似的（例如这两个过程都是从识别锚点开始的），但它们之间有两个重要的区别:\n>\n> 1.  **在data transfer中，Seurat不矫正或修改待查询数据集的表达矩阵**。\n> 2.  在 data transfer中，Seurat有一个选项（默认设置），可以将参考基因集的PCA结构投影到查询对象上，而不是使用CCA学习联合结构。\n\nAfter finding anchors, we use the `TransferData()` function to classify the query cells based on reference data (a vector of reference cell type labels). `TransferData()` returns a matrix with **predicted IDs** and **prediction scores**, which we can add to the query metadata.\n\n这里为了演示，还是选取panc8中的两个测序技术（\"fluidigmc1\"和\"celseq\"）的数据作为查询数据集。\n\n\n::: {.cell hash='mapping_and_annotating_query_datasets_cache/html/unnamed-chunk-7_f37063cf4ca68a657a776883b9ed7e06'}\n\n```{.r .cell-code}\npancreas.query <- subset(panc8, tech %in% c(\"fluidigmc1\", \"celseq\"))\n# 标准化查询数据集\npancreas.query <- NormalizeData(pancreas.query)\n# 寻找transfer锚点\npancreas.anchors <- FindTransferAnchors(reference = pancreas.ref, \n                                        query = pancreas.query, \n                                        dims = 1:30,\n                                        reference.reduction = \"pca\")\n# 映射数据\npredictions <- TransferData(anchorset = pancreas.anchors, \n                            refdata = pancreas.ref$celltype, \n                            dims = 1:30)\ndim(predictions)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1642   15\n```\n:::\n\n```{.r .cell-code}\npredictions[1:5, 1:3]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n        predicted.id prediction.score.alpha prediction.score.endothelial\nD101_5         gamma                      0                            0\nD101_7        acinar                      0                            0\nD101_10        alpha                      1                            0\nD101_13        delta                      0                            0\nD101_14         beta                      0                            0\n```\n:::\n:::\n\n\n> 可以看到映射之后生成的`predictions`是一个数据框，将查询数据集中的每一个细胞和预测的细胞类型（predicted.id）一一对应，并给出了这种预测的分数。\n\n接下来，只需将`predictions`作为metadata添加到查询数据集：\n\n\n::: {.cell hash='mapping_and_annotating_query_datasets_cache/html/unnamed-chunk-8_6f56c4ed33546ce3778492ab2dd422e7'}\n\n```{.r .cell-code}\npancreas.query <- AddMetaData(pancreas.query, \n                              metadata = predictions)\ncolnames(pancreas.query@meta.data)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] \"orig.ident\"                          \"nCount_RNA\"                         \n [3] \"nFeature_RNA\"                        \"tech\"                               \n [5] \"replicate\"                           \"assigned_cluster\"                   \n [7] \"celltype\"                            \"dataset\"                            \n [9] \"predicted.id\"                        \"prediction.score.alpha\"             \n[11] \"prediction.score.endothelial\"        \"prediction.score.delta\"             \n[13] \"prediction.score.beta\"               \"prediction.score.ductal\"            \n[15] \"prediction.score.acinar\"             \"prediction.score.mast\"              \n[17] \"prediction.score.gamma\"              \"prediction.score.activated_stellate\"\n[19] \"prediction.score.macrophage\"         \"prediction.score.quiescent_stellate\"\n[21] \"prediction.score.epsilon\"            \"prediction.score.schwann\"           \n[23] \"prediction.score.max\"               \n```\n:::\n\n```{.r .cell-code}\ntable(pancreas.query$predicted.id)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\n            acinar activated_stellate              alpha               beta \n               262                 39                436                419 \n             delta             ductal        endothelial              gamma \n                73                330                 19                 41 \n        macrophage               mast            schwann \n                15                  2                  6 \n```\n:::\n:::\n\n\n> 现在的查询数据集中就多出了映射后的细胞注释信息。\n\nBecause we have the original label annotations from our full integrated analysis, we can evaluate how well our predicted cell type annotations match the full reference.\n\n\n::: {.cell hash='mapping_and_annotating_query_datasets_cache/html/unnamed-chunk-9_59daf3260cd915790cc68d3751cd3649'}\n\n```{.r .cell-code}\ntable(pancreas.query$predicted.id == pancreas.query$celltype)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\nFALSE  TRUE \n   63  1579 \n```\n:::\n:::\n\n\n> In this example, we find that there is a high agreement in cell type classification, with over 96%（1579/1642） of cells being labeled correctly.\n\nTo verify this further, we can examine some canonical cell type markers for specific pancreatic islet cell populations.\n\n\n::: {.cell hash='mapping_and_annotating_query_datasets_cache/html/unnamed-chunk-10_41dc34920e0a96b0394a45206f82e5e6'}\n\n```{.r .cell-code}\nVlnPlot(pancreas.query, \n        c(\"REG1A\", \"PPY\", \"SST\", \"GHRL\", \"VWF\", \"SOX10\"), \n        group.by = \"predicted.id\")\n```\n\n::: {.cell-output-display}\n![](mapping_and_annotating_query_datasets_files/figure-html/unnamed-chunk-10-1.png){width=960}\n:::\n:::\n\n\n> Note that even though some of these cell types are only represented by one or two cells (e.g. epsilon cells), we are still able to classify them correctly.\n\n## UMAP映射\n\nWe also enable projection of a query onto the reference UMAP structure. This can be achieved by computing the reference UMAP model and then calling `MapQuery()` instead of `TransferData()`.\n\n\n::: {.cell hash='mapping_and_annotating_query_datasets_cache/html/unnamed-chunk-11_1a370f75ab6359fb6b57f4f95bb635a9'}\n\n```{.r .cell-code}\npancreas.ref <- RunUMAP(pancreas.ref, \n                        dims = 1:30, \n                        reduction = \"integrated.cca\", \n                        return.model = TRUE)\npancreas.query <- MapQuery(anchorset = pancreas.anchors, \n                           query = pancreas.query, \n                           reference = pancreas.ref, \n                           refdata = list(celltype = \"celltype\"), #需要transfer的参考数据集的列\n                           reference.reduction = \"pca\", \n                           reduction.model = \"umap\")\n```\n:::\n\n\n可以看到现在的查询数据集pancreas.query中有了降维信息（reduction）。这些信息实际上是映射的参考数据集pancreas.ref的降维信息：\n\n![](images/截屏2023-11-28%2012.25.34.png)\n\n::: {.callout-tip collapse=\"true\"}\n###### What is MapQuery doing?\n\n`MapQuery()`打包了三个函数的功能: `TransferData()`, `IntegrateEmbeddings()`, and `ProjectUMAP()`. `TransferData()` is used to transfer cell type labels and impute the ADT values; `IntegrateEmbeddings()` is used to integrate reference with query by correcting the query's projected low-dimensional embeddings; and finally `ProjectUMAP()` is used to project the query data onto the UMAP structure of the reference. 所以，运行`MapQuery()`的效果和运行下面的脚本一样:\n\n\n::: {.cell hash='mapping_and_annotating_query_datasets_cache/html/unnamed-chunk-12_2812163ba90a72eacd3c443040b4f9ac'}\n\n```{.r .cell-code}\npancreas.query <- TransferData(anchorset = pancreas.anchors, \n                               reference = pancreas.ref, \n                               query = pancreas.query,\n                               refdata = list(celltype = \"celltype\"))\npancreas.query <- IntegrateEmbeddings(anchorset = pancreas.anchors, \n                                      reference = pancreas.ref, \n                                      query = pancreas.query,\n                                      new.reduction.name = \"ref.pca\")\npancreas.query <- ProjectUMAP(query = pancreas.query, \n                              query.reduction = \"ref.pca\", \n                              reference = pancreas.ref,\n                              reference.reduction = \"pca\", \n                              reduction.model = \"umap\")\n```\n:::\n\n:::\n\nWe can now visualize the query cells alongside our reference.\n\n\n::: {.cell layout-ncol=\"2\" hash='mapping_and_annotating_query_datasets_cache/html/unnamed-chunk-13_47bb9ad59c1063fa0f464ea8dcdb6a0f'}\n\n```{.r .cell-code}\nlibrary(ggplot2)\nDimPlot(pancreas.ref, \n        reduction = \"umap\", \n        group.by = \"celltype\", \n        label = TRUE, \n        label.size = 6,\n        repel = TRUE) + \n  NoLegend() + \n  ggtitle(\"Reference annotations\")\n```\n\n::: {.cell-output-display}\n![](mapping_and_annotating_query_datasets_files/figure-html/unnamed-chunk-13-1.png){width=960}\n:::\n\n```{.r .cell-code}\nDimPlot(pancreas.query, \n        reduction = \"ref.umap\", \n        group.by = \"predicted.celltype\", \n        label = TRUE,\n        label.size = 6, \n        repel = TRUE) + \n  NoLegend() + \n  ggtitle(\"Query transferred labels\")\n```\n\n::: {.cell-output-display}\n![](mapping_and_annotating_query_datasets_files/figure-html/unnamed-chunk-13-2.png){width=960}\n:::\n:::\n\n\n::: callout-tip\n本篇主要介绍了基于单细胞转录组测序（scRNA-seq）数据的参考数据集的制作和映射。Seurat现在还提供了一种'bridge integration'的方法，可以将其他单细胞组学数据（如scATAC-seq、scDNAme、CyTOF）映射到scRNA-seq参考数据集上。详见：[*Dictionary Learning for cross-modality integration*](https://satijalab.org/seurat/articles/seurat5_integration_bridge)。\n:::\n\n------------------------------------------------------------------------\n\n::: {.callout-note collapse=\"true\" icon=\"false\"}\n## Session Info\n\n\n::: {.cell hash='mapping_and_annotating_query_datasets_cache/html/unnamed-chunk-14_34ab500b2da253f23d2a455fdfa5ccf3'}\n\n```{.r .cell-code}\nsessionInfo()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nR version 4.3.2 (2023-10-31)\nPlatform: aarch64-apple-darwin20 (64-bit)\nRunning under: macOS Sonoma 14.3\n\nMatrix products: default\nBLAS:   /Library/Frameworks/R.framework/Versions/4.3-arm64/Resources/lib/libRblas.0.dylib \nLAPACK: /Library/Frameworks/R.framework/Versions/4.3-arm64/Resources/lib/libRlapack.dylib;  LAPACK version 3.11.0\n\nlocale:\n[1] en_US.UTF-8/en_US.UTF-8/en_US.UTF-8/C/en_US.UTF-8/en_US.UTF-8\n\ntime zone: Asia/Shanghai\ntzcode source: internal\n\nattached base packages:\n[1] stats     graphics  grDevices utils     datasets  methods   base     \n\nother attached packages:\n[1] ggplot2_3.4.4      Seurat_5.0.1       SeuratObject_5.0.1 sp_2.1-2          \n\nloaded via a namespace (and not attached):\n  [1] deldir_2.0-2           pbapply_1.7-2          gridExtra_2.3         \n  [4] rlang_1.1.3            magrittr_2.0.3         RcppAnnoy_0.0.21      \n  [7] spatstat.geom_3.2-7    matrixStats_1.2.0      ggridges_0.5.5        \n [10] compiler_4.3.2         png_0.1-8              vctrs_0.6.5           \n [13] reshape2_1.4.4         stringr_1.5.1          pkgconfig_2.0.3       \n [16] fastmap_1.1.1          ellipsis_0.3.2         labeling_0.4.3        \n [19] utf8_1.2.4             promises_1.2.1         rmarkdown_2.25        \n [22] ggbeeswarm_0.7.2       purrr_1.0.2            xfun_0.41             \n [25] jsonlite_1.8.8         goftest_1.2-3          later_1.3.2           \n [28] spatstat.utils_3.0-4   irlba_2.3.5.1          parallel_4.3.2        \n [31] cluster_2.1.6          R6_2.5.1               ica_1.0-3             \n [34] stringi_1.8.3          RColorBrewer_1.1-3     spatstat.data_3.0-4   \n [37] reticulate_1.34.0      parallelly_1.36.0      lmtest_0.9-40         \n [40] scattermore_1.2        Rcpp_1.0.12            knitr_1.45            \n [43] tensor_1.5             future.apply_1.11.1    zoo_1.8-12            \n [46] sctransform_0.4.1      httpuv_1.6.13          Matrix_1.6-5          \n [49] splines_4.3.2          igraph_1.6.0           tidyselect_1.2.0      \n [52] abind_1.4-5            rstudioapi_0.15.0      yaml_2.3.8            \n [55] spatstat.random_3.2-2  codetools_0.2-19       miniUI_0.1.1.1        \n [58] spatstat.explore_3.2-5 listenv_0.9.0          lattice_0.22-5        \n [61] tibble_3.2.1           plyr_1.8.9             withr_3.0.0           \n [64] shiny_1.8.0            ROCR_1.0-11            ggrastr_1.0.2         \n [67] evaluate_0.23          Rtsne_0.17             future_1.33.1         \n [70] fastDummies_1.7.3      survival_3.5-7         polyclip_1.10-6       \n [73] fitdistrplus_1.1-11    pillar_1.9.0           KernSmooth_2.23-22    \n [76] plotly_4.10.4          generics_0.1.3         RcppHNSW_0.5.0        \n [79] munsell_0.5.0          scales_1.3.0           globals_0.16.2        \n [82] xtable_1.8-4           glue_1.7.0             lazyeval_0.2.2        \n [85] tools_4.3.2            data.table_1.14.10     RSpectra_0.16-1       \n [88] RANN_2.6.1             leiden_0.4.3.1         dotCall64_1.1-1       \n [91] cowplot_1.1.2          grid_4.3.2             tidyr_1.3.0           \n [94] colorspace_2.1-0       nlme_3.1-164           patchwork_1.2.0       \n [97] beeswarm_0.4.0         vipor_0.4.7            cli_3.6.2             \n[100] spatstat.sparse_3.0-3  spam_2.10-0            fansi_1.0.6           \n[103] viridisLite_0.4.2      dplyr_1.1.4            uwot_0.1.16           \n[106] gtable_0.3.4           digest_0.6.34          progressr_0.14.0      \n[109] ggrepel_0.9.5          farver_2.1.1           htmlwidgets_1.6.4     \n[112] htmltools_0.5.7        lifecycle_1.0.4        httr_1.4.7            \n[115] mime_0.12              MASS_7.3-60.0.1       \n```\n:::\n:::\n\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}