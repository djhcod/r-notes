{
  "hash": "77aa12f3305e97de55250c287e42bace",
  "result": {
    "markdown": "---\nbibliography: references.bib\n---\n\n\n# Normalization and regressing out unwanted variation {#sec-normalization-and-regressing-out-unwanted-variation}\n\n::: callout-note\n###### **Learning Objectives:**\n\n-   Discuss why normalizing counts is necessary for accurate comparison between cells\n-   Describe different normalization approaches\n-   Evaluate the effects from any unwanted sources of variation and correct for them\n:::\n\nNow that we have our high quality cells, we can explore our data and see if we are able to identify any **sources of unwanted variation**. Depending on what we observe, we will utilize that information when performing variance stabilization using `SCTransform` but also to regress out the effects of any covariates that have an effect on our data.\n\n![](images/sc_workflow_2022-01.jpg){width=\"545\"}\n\n------------------------------------------------------------------------\n\n**Goals:**\n\n-   To accurately **normalize the gene expression values** to account for differences in **sequencing depth** and overdispersed count values.\n-   To **identify the most variant genes** likely to be indicative of the different cell types present.\n\n**Challenges:**\n\n-   **Checking and removing unwanted variation** so that we do not have cells clustering by artifacts downstream\n\n**Recommendations:**\n\n-   Have a good idea of your expectations for the **cell types to be present** prior to performing the clustering. Know whether you expect cell types of low complexity or higher mitochondrial content AND whether the cells are differentiating\n-   **Regress out** number of **UMIs** (default using `SCTransform`), **mitochondrial content**, and **cell cycle**, if needed and appropriate for experiment, so not to drive clustering downstream\n\n------------------------------------------------------------------------\n\n## 标准化（Normalization）的原理和类型\n\nAn essential first step in the majority of mRNA expression analyses is normalization, whereby systematic variations are adjusted for to **make expression counts comparable across genes and/or samples**. The counts of mapped reads for each gene is proportional to the expression of RNA (\"interesting\") in addition to many other factors (\"uninteresting\"). Normalization is the process of adjusting raw count values to account for the \"uninteresting\" factors.\n\nThe main factors often considered during normalization are:\n\n-   **Sequencing depth:** Accounting for sequencing depth is necessary for comparison of gene expression between cells. In the example below, each gene appears to have doubled in expression in cell 2, however this is a consequence of cell 2 having twice the sequencing depth.\n\n![](images/sequencing_depth.png){width=\"509\"}\n\n> Each cell in scRNA-seq will have a differing number of reads associated with it. So to accurately compare expression between cells, it is necessary to normalize for sequencing depth.\n\n-   **Gene length:** Accounting for gene length is necessary for comparing expression between different genes within the same cell. The number of reads mapped to a longer gene can appear to have equal count/expression as a shorter gene that is more highly expressed.\n\n![](images/length_of_gene.png){width=\"464\"}\n\n::: callout-note\nIf using a **3' or 5' droplet-based method (10X Genomics, CEL-seq2, Drop-seq, inDrops)**, the length of the gene will **not** affect the analysis because only the 5' or 3' end of the transcript is sequenced. However, if using **full-length sequencing (Smart-seq)**, the transcript length should be accounted for.\n:::\n\n### Methods for scRNA-seq normalization\n\nVarious methods have been developed specifically for scRNA-seq normalization. Some simpler methods resemble what we have seen with bulk RNA-seq; the application of **global scale factors** adjusting for a count-depth relationship that is assumed common across all genes. However, if those assumptions are not true then this basic normalization can lead to over-correction for lowly and moderately expressed genes and, in some cases, under-normalization of highly expressed genes [@bacher2017]. More complex methods will apply correction on a per-gene basis**.** In this lesson we will explore both approaches.\n\nRegardless of which method is used for normalization, it can be helpful to think of it as a **two-step process** (even though it is often described as a single step in most papers). The first is a scaling step and the second is a transformation.\n\n**1. Scaling**\n\nThe first step in normalization is to **multiply each UMI count by a [cell specific factor]{.underline} to get [all cells to have the same UMI counts]{.underline}**. Why would we want to do this? Different cells have different amounts of mRNA; this could be due to differences between cell types or variation within the same cell type depending on how well the chemistry worked in one drop versus another. In either case, we are not interested in comparing these **absolute counts** between cells. Instead we are interested in comparing **concentrations**, and scaling helps achieve this.\n\n**2. Transformation**\n\nThe next step is a transformation, and it is at this step where we can distinguish the simpler versus complex methods as mentioned above.\n\n**Simple transformations** are those which apply the same function to each individual measurement. Common examples include a **log transform** (which is applied in the original Seurat workflow), or a square root transform (less commonly used).\n\nIn the [Hafemeister and Satija, 2019 paper](https://genomebiology.biomedcentral.com/articles/10.1186/s13059-019-1874-1) the authors explored the issues with simple transformations. Specifically they evaluated the standard log normalization approach and found that genes with different abundances are affected differently and that effective normalization (using the log transform) is only observed with low/medium abundance genes (Figure 1D, below). Additionally, substantial imbalances in variance were observed with the log-normalized data (Figure 1E, below). In particular, cells with low total UMI counts exhibited disproportionately higher variance for high-abundance genes, dampening the variance contribution from other gene abundances. \n\n![](images/SCT_Fig1.png)\n\n> Image credit: Hafemeister C and Satija R. Normalization and variance stabilization of single-cell RNA-seq data using regularized negative binomial regression, Genom Biology 2019 (<https://doi.org/10.1186/s13059-019-1874-1>)\n\nThe conclusion is, **we cannot treat all genes the same.**\n\nThe proposed solution was the use of **Pearson residuals for transformation**, as implemented in Seurat's `SCTransform` function. With this approach:\n\n-   Measurements are multiplied by a **gene-specific weight**\n\n-   Each gene is weighted based on how much evidence there is that it is non-uniformly expressed across cells. More evidence == more of a weight\n\n-   Genes that are expressed in only a small fraction of cells will be favored (useful for finding rare cell populations)\n\n-   Not just a consideration of the expression level is, but also the distribution of expression\n\nIn this workshop we will demonstrate the use of both transformations at different steps in the workflow.\n\n## 基于传统标准化流程对非期望变异来源进行评估\n\nThe most common biological data correction (or source of \"uninteresting\" variation) in single cell RNA-seq is the effects of the **cell cycle** on the transcriptome. We need to explore the data and see if we observe any effects in our data.\n\n### Set-up\n\nBefore we make any comparisons across cells, we will apply a **simple normalization.** **This is solely for the purpose of exploring the sources of variation in our data.**\n\nThe input for this analysis is a `seurat` object. We will use the one that we created in @sec-qc called `filtered_seurat`.\n\n\n::: {.cell hash='06_SC_SCT_normalization_cache/html/unnamed-chunk-1_2b3d41d03675b09e7a0556314825e8de'}\n\n```{.r .cell-code}\nlibrary(Seurat)\nfiltered_seurat <- readRDS(\"output/scRNA-seq_online/seurat_filtered.rds\")\nfiltered_seurat\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nAn object of class Seurat \n14065 features across 29629 samples within 1 assay \nActive assay: RNA (14065 features, 0 variable features)\n 1 layer present: counts\n```\n:::\n\n```{.r .cell-code}\nhead(filtered_seurat@meta.data)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n                      orig.ident nCount_RNA nFeature_RNA sample\nctrl_AAACATACAATGCC-1          1       2344          874   ctrl\nctrl_AAACATACATTTCC-1          1       3125          896   ctrl\nctrl_AAACATACCAGAAA-1          1       2578          725   ctrl\nctrl_AAACATACCAGCTA-1          1       3261          979   ctrl\nctrl_AAACATACCATGCA-1          1        746          362   ctrl\nctrl_AAACATACCTCGCT-1          1       3519          866   ctrl\n                      log10GenesPerUMI  mitoRatio                 cells\nctrl_AAACATACAATGCC-1        0.8728630 0.01962457 ctrl_AAACATACAATGCC-1\nctrl_AAACATACATTTCC-1        0.8447596 0.01792000 ctrl_AAACATACATTTCC-1\nctrl_AAACATACCAGAAA-1        0.8384933 0.01551590 ctrl_AAACATACCAGAAA-1\nctrl_AAACATACCAGCTA-1        0.8512622 0.01379945 ctrl_AAACATACCAGCTA-1\nctrl_AAACATACCATGCA-1        0.8906861 0.02144772 ctrl_AAACATACCATGCA-1\nctrl_AAACATACCTCGCT-1        0.8283053 0.01392441 ctrl_AAACATACCTCGCT-1\n```\n:::\n\n```{.r .cell-code}\n# Normalize the counts\nseurat_phase <- NormalizeData(filtered_seurat)\nseurat_phase\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nAn object of class Seurat \n14065 features across 29629 samples within 1 assay \nActive assay: RNA (14065 features, 0 variable features)\n 2 layers present: counts, data\n```\n:::\n:::\n\n\n可以发现，运行`NormalizeDataNext`后的数据多出了新的layer：data, 里面即储存了标准化后的数据。Next, we take this normalized data and check to see if data correction methods are necessary.\n\n### 评估细胞周期的影响（Evaluating effects of cell cycle） {#sec-evaluating_effects_of_cell_cycle}\n\n#### 计算细胞周期评分\n\n::: callout-tip\n关于细胞周期的详细说明，见 @sec-Calculating_cell_cycle_scores 。\n:::\n\nTo assign each cell a score based on its expression of G2/M and S phase markers, we can use the Seuart function `CellCycleScoring()`. This function calculates cell cycle phase scores based on canonical markers that required as input.\n\nA list of cell cycle markers, from Tirosh et al, 2015, is loaded with Seurat. We can segregate this list into markers of G2/M phase and markers of S phase. However, if you are not working with human data we have [additional materials](https://hbctraining.github.io/scRNA-seq_online/lessons/cell_cycle_scoring.html) detailing how to acquire cell cycle markers for other organisms of interest.\n\n\n::: {.cell hash='06_SC_SCT_normalization_cache/html/unnamed-chunk-2_31b1dc53b562428dee2d82e6172d1f6e'}\n\n```{.r .cell-code}\n# Load cell cycle markers\ns.genes <- cc.genes$s.genes\ng2m.genes <- cc.genes$g2m.genes\n\n# Score cells for cell cycle\nseurat_phase <- CellCycleScoring(seurat_phase, \n                                 g2m.features = g2m.genes, \n                                 s.features = s.genes)\n\n# 现在的meta.data中多出了细胞周期评分“S.Score”和“G2M.Score”，以及推断的细胞所处的周期“Phase”\nhead(seurat_phase@meta.data)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n                      orig.ident nCount_RNA nFeature_RNA sample\nctrl_AAACATACAATGCC-1          1       2344          874   ctrl\nctrl_AAACATACATTTCC-1          1       3125          896   ctrl\nctrl_AAACATACCAGAAA-1          1       2578          725   ctrl\nctrl_AAACATACCAGCTA-1          1       3261          979   ctrl\nctrl_AAACATACCATGCA-1          1        746          362   ctrl\nctrl_AAACATACCTCGCT-1          1       3519          866   ctrl\n                      log10GenesPerUMI  mitoRatio                 cells\nctrl_AAACATACAATGCC-1        0.8728630 0.01962457 ctrl_AAACATACAATGCC-1\nctrl_AAACATACATTTCC-1        0.8447596 0.01792000 ctrl_AAACATACATTTCC-1\nctrl_AAACATACCAGAAA-1        0.8384933 0.01551590 ctrl_AAACATACCAGAAA-1\nctrl_AAACATACCAGCTA-1        0.8512622 0.01379945 ctrl_AAACATACCAGCTA-1\nctrl_AAACATACCATGCA-1        0.8906861 0.02144772 ctrl_AAACATACCATGCA-1\nctrl_AAACATACCTCGCT-1        0.8283053 0.01392441 ctrl_AAACATACCTCGCT-1\n                          S.Score   G2M.Score Phase\nctrl_AAACATACAATGCC-1  0.02713602  0.04344302   G2M\nctrl_AAACATACATTTCC-1  0.01519129  0.01846409   G2M\nctrl_AAACATACCAGAAA-1 -0.05272781 -0.05038367    G1\nctrl_AAACATACCAGCTA-1 -0.05194312  0.04583528   G2M\nctrl_AAACATACCATGCA-1  0.04406978 -0.03445262     S\nctrl_AAACATACCTCGCT-1  0.03421052  0.02033139     S\n```\n:::\n\n```{.r .cell-code}\n# 查看一下细胞周期的分布情况\ntable(seurat_phase$Phase)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\n   G1   G2M     S \n10387  9547  9695 \n```\n:::\n:::\n\n\n#### 使用PCA确定细胞周期是否是我们数据集中的主要变异来源\n\nAfter scoring the cells for cell cycle, we would like to determine **whether cell cycle is a major source of variation in our dataset using PCA（PCA的原理详见：** @sec-pca_theory **）**.\n\nTo perform PCA, we need to **first choose the most variable features, then scale the data**. Since highly expressed genes exhibit the highest amount of variation and we don't want our 'highly variable genes' only to reflect high expression, we need to scale the data to scale variation with expression level. The Seurat `ScaleData()` function will scale the data by:\n\n-   adjusting the expression of each gene **to give a mean expression across cells to be 0**\n-   scaling expression of each gene **to give a variance across cells to be 1**\n\n\n::: {.cell hash='06_SC_SCT_normalization_cache/html/unnamed-chunk-3_c3a9547eb839f0adade5b81c6b41d47f'}\n\n```{.r .cell-code}\n# Identify the most variable genes\nseurat_phase <- FindVariableFeatures(seurat_phase, \n                                     selection.method = \"vst\", # 默认值\n                                     nfeatures = 2000) # 默认值\n             \n# Scale the counts\nseurat_phase <- ScaleData(seurat_phase)\nLayers(seurat_phase)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"counts\"     \"data\"       \"scale.data\"\n```\n:::\n:::\n\n\n可以发现，运行`ScaleData`后的数据多出了新的layer：scale.data, 里面即储存了归一化后的数据。Now, we can perform the PCA analysis and plot the first two principal components against each other. We also split the figure by cell cycle phase, to evaluate similarities and/or differences.\n\n\n::: {.cell hash='06_SC_SCT_normalization_cache/html/unnamed-chunk-4_e22a3cfa42da4347bdd1b12c773fdf18'}\n\n```{.r .cell-code}\n# Perform PCA。如果没有指定features，RunPCA默认使用FindVariableFeatures找到的高变基因作为PCA输入.\nseurat_phase <- RunPCA(seurat_phase)\n\n# Plot the PCA colored by cell cycle phase\np1 <- DimPlot(seurat_phase,\n              reduction = \"pca\",\n              group.by= \"Phase\")\np2 <- DimPlot(seurat_phase,\n              reduction = \"pca\",\n              group.by= \"Phase\",\n              split.by = \"Phase\")\nlibrary(cowplot)\nplot_grid(p1, p2, ncol = 2, labels = \"AUTO\")\n```\n\n::: {.cell-output-display}\n![](06_SC_SCT_normalization_files/figure-html/unnamed-chunk-4-1.png){width=960}\n:::\n:::\n\n\n**We do not see large differences due to cell cycle phase. Based on this plot, we would not regress out the variation due to cell cycle.**\n\n::: {.callout-tip collapse=\"true\"}\n###### When should cell cycle phase be regressed out?\n\nBelow are two PCA plots taken from @sec-Elimination_of_cell_cycle_effects 。This first plot is similar to what we plotted above, it is a PCA prior to regression to evaluate if the cell cycle is playing a big role in driving PC1 and PC2. Clearly, the cells are separating by cell type in this case, so it suggests regressing out these effects.\n\n![](images/unnamed-chunk-6-1.png){width=\"427\"}\n\nThis second PCA plot is post-regression, and displays how effective the regression was in removing the effect we observed.\n\n![](images/unnamed-chunk-10-1.png){width=\"430\"}\n:::\n\n::: callout-tip\n在需要消除细胞周期的影响时，如何通过`ScaleData`回归掉（regress out）细胞周期的影响，以及如何在消除细胞周期的影响同时保留增殖细胞与静止细胞的区分，参考 @sec-Elimination_of_cell_cycle_effects 。\n:::\n\n------------------------------------------------------------------------\n\n### 评估线粒体基因表达的影响\n\nMitochondrial expression is another factor which can greatly influence clustering. Oftentimes, it is useful to regress out variation due to mitochondrial expression. However, **if the differences in mitochondrial gene expression represent a biological phenomenon that may help to distinguish cell clusters, then we advise not regressing this out**. In this exercise, we can perform a quick check similar to looking at cell cycle and decide whether or not we want to regress it out.\n\n1.  First, turn the mitochondrial ratio variable into a new categorical variable based on quartiles. 根据各细胞线粒体基因的比例的四分位数将所有细胞分为低线粒体基因比例细胞、中线粒体基因比例细胞···\n\n\n    ::: {.cell hash='06_SC_SCT_normalization_cache/html/unnamed-chunk-5_db73b946a4ab25b9a1401917f1d1c611'}\n    \n    ```{.r .cell-code}\n    # Check quartile values\n    summary(seurat_phase$mitoRatio)\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    ```\n       Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n    0.00000 0.01438 0.01993 0.02139 0.02669 0.14464 \n    ```\n    :::\n    \n    ```{.r .cell-code}\n    # Turn mitoRatio into categorical factor vector based on quartile values\n    seurat_phase$mitoFr <- cut(seurat_phase@meta.data$mitoRatio, \n                               breaks=c(-Inf, 0.0144, 0.0199, 0.0267, Inf), \n                               labels=c(\"Low\", \"Medium\", \"Medium high\", \"High\"))\n    table(seurat_phase$mitoFr)\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    ```\n    \n            Low      Medium Medium high        High \n           7443        7325        7459        7402 \n    ```\n    :::\n    :::\n\n\n2.  Next, plot the PCA similar to how we did with cell cycle regression. *Hint: use the new `mitoFr` variable to split cells and color them accordingly.*\n\n\n    ::: {.cell hash='06_SC_SCT_normalization_cache/html/unnamed-chunk-6_16eda56e8930a5a802d5fd81c034deb8'}\n    \n    ```{.r .cell-code}\n    # 根据各细胞线粒体基因的比例信息绘制PCA\n    p1 <- DimPlot(seurat_phase,\n                  reduction = \"pca\",\n                  group.by= \"mitoFr\")\n    p2 <- DimPlot(seurat_phase,\n                  reduction = \"pca\",\n                  group.by= \"mitoFr\",\n                  split.by = \"mitoFr\")\n    plot_grid(p1, p2, ncol = 2, labels = \"AUTO\")\n    ```\n    \n    ::: {.cell-output-display}\n    ![](06_SC_SCT_normalization_files/figure-html/unnamed-chunk-6-1.png){width=1920}\n    :::\n    :::\n\n\n3.  Evaluate the PCA plot.\n\n    We do not see large differences due to mitochondrial expression. Based on this plot, we would not regress out the variation due to mitochondrial expression.\n\n------------------------------------------------------------------------\n\n## `SCTransform`-based Normalization and regressing out sources of unwanted variation\n\nNow that we have established which effects are observed in our data, we can use the `SCTransform` method to regress out these effects. The `SCTransform` method was proposed as a better alternative to the log transform normalization method that we used for exploring sources of unwanted variation. The method not only **normalizes data, but it also performs a variance stabilization and allows for additional covariates to be regressed out**.\n\nAs described earlier, all genes cannot be treated the same. As such, the `SCTransform` **method constructs a generalized linear model (GLM) for each gene** with UMI counts as the response and sequencing depth as the explanatory variable. Information is pooled across genes with similar abundances, to regularize parameter estimates and **obtain residuals which represent effectively normalized data values** which are no longer correlated with sequencing depth.\n\n![](images/SCT_UMAP.png){width=\"532\"}\n\n> Image credit: Hafemeister C and Satija R. Normalization and variance stabilization of single-cell RNA-seq data using regularized negative binomial regression, Genom Biology 2019 (<https://doi.org/10.1101/576827)_>\n\n::: callout-note\nSince the UMI counts are part of the GLM, the effects are automatically regressed out. The user can include any additional covariates (`vars.to.regress`) that may have an effect on expression and will be included in the model.\n:::\n\n### 数据导入\n\n前面的流程和此前一样\n\n\n::: {.cell hash='06_SC_SCT_normalization_cache/html/unnamed-chunk-7_5a345fdd694c0b44163c9c17b1251bb9'}\n\n```{.r .cell-code}\nrm(list = ls())\n\nlibrary(Seurat)\nfiltered_seurat <- readRDS(\"output/scRNA-seq_online/seurat_filtered.rds\")\nfiltered_seurat\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nAn object of class Seurat \n14065 features across 29629 samples within 1 assay \nActive assay: RNA (14065 features, 0 variable features)\n 1 layer present: counts\n```\n:::\n\n```{.r .cell-code}\nhead(filtered_seurat@meta.data)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n                      orig.ident nCount_RNA nFeature_RNA sample\nctrl_AAACATACAATGCC-1          1       2344          874   ctrl\nctrl_AAACATACATTTCC-1          1       3125          896   ctrl\nctrl_AAACATACCAGAAA-1          1       2578          725   ctrl\nctrl_AAACATACCAGCTA-1          1       3261          979   ctrl\nctrl_AAACATACCATGCA-1          1        746          362   ctrl\nctrl_AAACATACCTCGCT-1          1       3519          866   ctrl\n                      log10GenesPerUMI  mitoRatio                 cells\nctrl_AAACATACAATGCC-1        0.8728630 0.01962457 ctrl_AAACATACAATGCC-1\nctrl_AAACATACATTTCC-1        0.8447596 0.01792000 ctrl_AAACATACATTTCC-1\nctrl_AAACATACCAGAAA-1        0.8384933 0.01551590 ctrl_AAACATACCAGAAA-1\nctrl_AAACATACCAGCTA-1        0.8512622 0.01379945 ctrl_AAACATACCAGCTA-1\nctrl_AAACATACCATGCA-1        0.8906861 0.02144772 ctrl_AAACATACCATGCA-1\nctrl_AAACATACCTCGCT-1        0.8283053 0.01392441 ctrl_AAACATACCTCGCT-1\n```\n:::\n:::\n\n\n### 执行`SCTransform`\n\n-   这里先运行一次`SCTransform`以便后面评估细胞周期、线粒体基因等非期望变异来源（**This is solely for the purpose of exploring the sources of variation in our data**）\n\n-   `SCTransform`替代了传统单细胞数据分析流程中的`NormalizeData()`、`ScaleData()`和`FindVariableFeatures()`函数的功能，因此不再需要运行这些函数。\n\n-   In Seurat v5, SCT v2 is applied by default. You can revert to v1 by setting `vst.flavor = 'v1'`。\n\n-   `SCTransform`的运算调用了[`glmGamPoi`](https://bioconductor.org/packages/release/bioc/html/glmGamPoi.html)包以显著提升运算速度。所以事先需要通过`BiocManager`安装该包。\n\n\n::: {.cell hash='06_SC_SCT_normalization_cache/html/unnamed-chunk-8_d4078aa89abf7982a50c8aad36160d06'}\n\n```{.r .cell-code}\n# SCTranform\n# BiocManager::install(\"glmGamPoi\")\nseurat_phase <- SCTransform(filtered_seurat, verbose = FALSE)\nseurat_phase\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nAn object of class Seurat \n28130 features across 29629 samples within 2 assays \nActive assay: SCT (14065 features, 3000 variable features)\n 3 layers present: counts, data, scale.data\n 1 other assay present: RNA\n```\n:::\n\n```{.r .cell-code}\n# Check which assays are stored in objects\nseurat_phase@assays\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n$RNA\nAssay (v5) data with 14065 features for 29629 cells\nFirst 10 features:\n AL627309.1, AL669831.5, LINC00115, FAM41C, NOC2L, KLHL17, PLEKHN1,\nHES4, ISG15, AGRN \nLayers:\n counts \n\n$SCT\nSCTAssay data with 14065 features for 29629 cells, and 1 SCTModel(s) \nTop 10 variable features:\n CCL8, IGKC, CXCL10, FTL, CCL2, CCL7, ISG15, GNLY, IGLC2, CCL4 \n```\n:::\n\n```{.r .cell-code}\n# 查看目前默认的assay\nDefaultAssay(seurat_phase)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"SCT\"\n```\n:::\n\n```{.r .cell-code}\n# 查看默认assay的layers\nLayers(seurat_phase)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"counts\"     \"data\"       \"scale.data\"\n```\n:::\n:::\n\n\nNote, the last line of output specifies **\"Set default assay to SCT\"**. 表明运行`SCTransform`之后，会将默认的assay指定为`SCTransform`之后的数据。This specifies that moving forward we would like to use the data after SCT was implemented. We can view the different assays that we have stored in our seurat object.\n\n### 评估细胞周期的影响\n\n\n::: {.cell hash='06_SC_SCT_normalization_cache/html/unnamed-chunk-9_95de4f6b468fd2dab067465cf3423d95'}\n\n```{.r .cell-code}\n# Load cell cycle markers\ns.genes <- cc.genes$s.genes\ng2m.genes <- cc.genes$g2m.genes\n\n# Score cells for cell cycle\nseurat_phase <- CellCycleScoring(seurat_phase, \n                                 g2m.features = g2m.genes, \n                                 s.features = s.genes)\n\n# 现在的meta.data中多出了细胞周期评分“S.Score”和“G2M.Score”，以及推断的细胞所处的周期“Phase”\nhead(seurat_phase@meta.data)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n                      orig.ident nCount_RNA nFeature_RNA sample\nctrl_AAACATACAATGCC-1          1       2344          874   ctrl\nctrl_AAACATACATTTCC-1          1       3125          896   ctrl\nctrl_AAACATACCAGAAA-1          1       2578          725   ctrl\nctrl_AAACATACCAGCTA-1          1       3261          979   ctrl\nctrl_AAACATACCATGCA-1          1        746          362   ctrl\nctrl_AAACATACCTCGCT-1          1       3519          866   ctrl\n                      log10GenesPerUMI  mitoRatio                 cells\nctrl_AAACATACAATGCC-1        0.8728630 0.01962457 ctrl_AAACATACAATGCC-1\nctrl_AAACATACATTTCC-1        0.8447596 0.01792000 ctrl_AAACATACATTTCC-1\nctrl_AAACATACCAGAAA-1        0.8384933 0.01551590 ctrl_AAACATACCAGAAA-1\nctrl_AAACATACCAGCTA-1        0.8512622 0.01379945 ctrl_AAACATACCAGCTA-1\nctrl_AAACATACCATGCA-1        0.8906861 0.02144772 ctrl_AAACATACCATGCA-1\nctrl_AAACATACCTCGCT-1        0.8283053 0.01392441 ctrl_AAACATACCTCGCT-1\n                      nCount_SCT nFeature_SCT      S.Score    G2M.Score Phase\nctrl_AAACATACAATGCC-1       1591          863  0.010526369  0.011803814   G2M\nctrl_AAACATACATTTCC-1       1553          724  0.010251663  0.015119823   G2M\nctrl_AAACATACCAGAAA-1       1549          668 -0.019803499 -0.015779795    G1\nctrl_AAACATACCAGCTA-1       1579          777 -0.032093208  0.013380044   G2M\nctrl_AAACATACCATGCA-1       1096          371  0.008301833 -0.008402066     S\nctrl_AAACATACCTCGCT-1       1493          632  0.018235066  0.018993438   G2M\n```\n:::\n\n```{.r .cell-code}\n# 查看一下细胞周期的分布情况\ntable(seurat_phase$Phase)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\n   G1   G2M     S \n10554  9586  9489 \n```\n:::\n\n```{.r .cell-code}\n# 执行PCA\nseurat_phase <- RunPCA(seurat_phase)\n\n# Plot the PCA colored by cell cycle phase\np1 <- DimPlot(seurat_phase,\n              reduction = \"pca\",\n              group.by= \"Phase\")\np2 <- DimPlot(seurat_phase,\n              reduction = \"pca\",\n              group.by= \"Phase\",\n              split.by = \"Phase\")\nlibrary(cowplot)\nplot_grid(p1, p2, ncol = 2, labels = \"AUTO\")\n```\n\n::: {.cell-output-display}\n![](06_SC_SCT_normalization_files/figure-html/unnamed-chunk-9-1.png){width=960}\n:::\n:::\n\n\n### 评估线粒体基因的影响\n\n\n::: {.cell hash='06_SC_SCT_normalization_cache/html/unnamed-chunk-10_0178b134a976c3c798eec2543778add7'}\n\n```{.r .cell-code}\n# Check quartile values\nsummary(seurat_phase$mitoRatio)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n0.00000 0.01438 0.01993 0.02139 0.02669 0.14464 \n```\n:::\n\n```{.r .cell-code}\n# Turn mitoRatio into categorical factor vector based on quartile values\nseurat_phase$mitoFr <- cut(seurat_phase@meta.data$mitoRatio, \n                           breaks=c(-Inf, 0.0144, 0.0199, 0.0267, Inf), \n                           labels=c(\"Low\", \"Medium\", \"Medium high\", \"High\"))\ntable(seurat_phase$mitoFr)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\n        Low      Medium Medium high        High \n       7443        7325        7459        7402 \n```\n:::\n\n```{.r .cell-code}\n# Plot the PCA colored by cell cycle phase\np1 <- DimPlot(seurat_phase,\n              reduction = \"pca\",\n              group.by= \"mitoFr\")\np2 <- DimPlot(seurat_phase,\n              reduction = \"pca\",\n              group.by= \"mitoFr\",\n              split.by = \"mitoFr\")\nplot_grid(p1, p2, ncol = 2, labels = \"AUTO\")\n```\n\n::: {.cell-output-display}\n![](06_SC_SCT_normalization_files/figure-html/unnamed-chunk-10-1.png){width=1920}\n:::\n:::\n\n\n### 分割layer，再次执行`SCTranform`\n\nSince we have two samples in our dataset (from two conditions), we want to keep them as separate layers and transform them as that is **what is required for integration**.\n\n\n::: {.cell hash='06_SC_SCT_normalization_cache/html/unnamed-chunk-11_5aa581d1cbc0e05ff5055fc7d675d5ac'}\n\n```{.r .cell-code}\n# Split RNA assay by condition to perform cell cycle scoring and SCT on all samples\nseurat_phase[[\"RNA\"]] <- split(seurat_phase[[\"RNA\"]], \n                               f = seurat_phase$sample) # 按照meta.data中的“sample”列进行分割\nseurat_phase\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nAn object of class Seurat \n28130 features across 29629 samples within 2 assays \nActive assay: SCT (14065 features, 3000 variable features)\n 3 layers present: counts, data, scale.data\n 1 other assay present: RNA\n 1 dimensional reduction calculated: pca\n```\n:::\n:::\n\n\n现在可以发现RNA assay的`counts`和`data`按照\"seurat_phase\\$sample\"（ctrl vs. stim）被分别分割成了2个layer：\n\n![](images/截屏2023-12-19%2010.46.18.png)\n\nNow we will run the `SCTransform()` on each sample, and regress out mitochondrial expression by specifying in the `vars.to.regress` argument of the `SCTransform()` function.\n\n::: callout-tip\nThe output of `SCTransform()` can generate large R objects/variables in terms of memory. If we have a large dataset, then we might need to **adjust the limit for allowable object sizes within R** (*Default is 500* 1024 \\^ 2 = 500 Mb\\*) using the following code:\n\n\n::: {.cell hash='06_SC_SCT_normalization_cache/html/unnamed-chunk-12_7bd61303ffdbfc0b44e7f68f2b748ac1'}\n\n````{.cell-code}\n```{{r}}\n#| eval: false\noptions(future.globals.maxSize = 4000 * 1024^2)\n```\n````\n:::\n\n\n如果出现如下报错：\n\n``` md\nError: vector memory exhausted (limit reached?)\n```\n\n说明所处理的数据量超出了R内存分配上限，请参阅 @sec-Raising_memory_limit 进行处理。\n:::\n\n#### 执行`SCTranform` {#sec-perform_sctranform}\n\n\n::: {.cell hash='06_SC_SCT_normalization_cache/html/unnamed-chunk-13_e9d989a8f4c10e55e528445dfc80bbaf'}\n\n```{.r .cell-code}\n# SCTranform\nseurat_phase <- SCTransform(seurat_phase, \n                            vars.to.regress = c(\"mitoRatio\"),\n                            verbose = FALSE)\n```\n:::\n\n\nBy default, after normalizing, adjusting the variance, and regressing out uninteresting sources of variation, `SCTransform` will rank the genes by residual variance and output the **3000** most variant genes. If the dataset has larger cell numbers, then it may be beneficial to adjust this parameter higher using the `variable.features.n` argument.\n\nNow we can see that in addition to the raw RNA counts, we now have a SCT component in our `assays` slot. The most variable features will be the only genes stored inside the SCT assay. As we move through the scRNA-seq analysis, we will choose the most appropriate assay to use for the different steps in the analysis.\n\n------------------------------------------------------------------------\n\n### Save the object!\n\n\n::: {.cell hash='06_SC_SCT_normalization_cache/html/unnamed-chunk-14_6a927843fc3b14ceb78a65dea011d685'}\n\n```{.r .cell-code}\nsaveRDS(seurat_phase, \"output/scRNA-seq_online/split_seurat.rds\")\n```\n:::\n\n\n------------------------------------------------------------------------\n\n::: {.callout-note collapse=\"true\" icon=\"false\"}\n## Session Info\n\n\n::: {.cell hash='06_SC_SCT_normalization_cache/html/unnamed-chunk-15_7c92f6dad57b5352def4548afbf3d82f'}\n::: {.cell-output .cell-output-stdout}\n```\nR version 4.3.2 (2023-10-31)\nPlatform: aarch64-apple-darwin20 (64-bit)\nRunning under: macOS Sonoma 14.2.1\n\nMatrix products: default\nBLAS:   /Library/Frameworks/R.framework/Versions/4.3-arm64/Resources/lib/libRblas.0.dylib \nLAPACK: /Library/Frameworks/R.framework/Versions/4.3-arm64/Resources/lib/libRlapack.dylib;  LAPACK version 3.11.0\n\nlocale:\n[1] en_US.UTF-8/en_US.UTF-8/en_US.UTF-8/C/en_US.UTF-8/en_US.UTF-8\n\ntime zone: Asia/Shanghai\ntzcode source: internal\n\nattached base packages:\n[1] stats     graphics  grDevices utils     datasets  methods   base     \n\nother attached packages:\n[1] cowplot_1.1.2      Seurat_5.0.1       SeuratObject_5.0.1 sp_2.1-2          \n\nloaded via a namespace (and not attached):\n  [1] RColorBrewer_1.1-3          rstudioapi_0.15.0          \n  [3] jsonlite_1.8.8              magrittr_2.0.3             \n  [5] spatstat.utils_3.0-4        farver_2.1.1               \n  [7] rmarkdown_2.25              zlibbioc_1.48.0            \n  [9] vctrs_0.6.5                 ROCR_1.0-11                \n [11] DelayedMatrixStats_1.24.0   spatstat.explore_3.2-5     \n [13] RCurl_1.98-1.14             S4Arrays_1.2.0             \n [15] htmltools_0.5.7             SparseArray_1.2.3          \n [17] sctransform_0.4.1           parallelly_1.36.0          \n [19] KernSmooth_2.23-22          htmlwidgets_1.6.4          \n [21] ica_1.0-3                   plyr_1.8.9                 \n [23] plotly_4.10.4               zoo_1.8-12                 \n [25] igraph_1.6.0                mime_0.12                  \n [27] lifecycle_1.0.4             pkgconfig_2.0.3            \n [29] Matrix_1.6-5                R6_2.5.1                   \n [31] fastmap_1.1.1               GenomeInfoDbData_1.2.11    \n [33] MatrixGenerics_1.14.0       fitdistrplus_1.1-11        \n [35] future_1.33.1               shiny_1.8.0                \n [37] digest_0.6.34               colorspace_2.1-0           \n [39] patchwork_1.2.0             S4Vectors_0.40.2           \n [41] tensor_1.5                  RSpectra_0.16-1            \n [43] irlba_2.3.5.1               GenomicRanges_1.54.1       \n [45] labeling_0.4.3              progressr_0.14.0           \n [47] fansi_1.0.6                 spatstat.sparse_3.0-3      \n [49] httr_1.4.7                  polyclip_1.10-6            \n [51] abind_1.4-5                 compiler_4.3.2             \n [53] withr_3.0.0                 fastDummies_1.7.3          \n [55] MASS_7.3-60.0.1             DelayedArray_0.28.0        \n [57] tools_4.3.2                 lmtest_0.9-40              \n [59] httpuv_1.6.13               future.apply_1.11.1        \n [61] goftest_1.2-3               glmGamPoi_1.14.0           \n [63] glue_1.7.0                  nlme_3.1-164               \n [65] promises_1.2.1              grid_4.3.2                 \n [67] Rtsne_0.17                  cluster_2.1.6              \n [69] reshape2_1.4.4              generics_0.1.3             \n [71] gtable_0.3.4                spatstat.data_3.0-4        \n [73] tidyr_1.3.0                 data.table_1.14.10         \n [75] XVector_0.42.0              utf8_1.2.4                 \n [77] BiocGenerics_0.48.1         spatstat.geom_3.2-7        \n [79] RcppAnnoy_0.0.21            ggrepel_0.9.5              \n [81] RANN_2.6.1                  pillar_1.9.0               \n [83] stringr_1.5.1               spam_2.10-0                \n [85] RcppHNSW_0.5.0              later_1.3.2                \n [87] splines_4.3.2               dplyr_1.1.4                \n [89] lattice_0.22-5              survival_3.5-7             \n [91] deldir_2.0-2                tidyselect_1.2.0           \n [93] miniUI_0.1.1.1              pbapply_1.7-2              \n [95] knitr_1.45                  gridExtra_2.3              \n [97] IRanges_2.36.0              SummarizedExperiment_1.32.0\n [99] scattermore_1.2             stats4_4.3.2               \n[101] xfun_0.41                   Biobase_2.62.0             \n[103] matrixStats_1.2.0           stringi_1.8.3              \n[105] lazyeval_0.2.2              yaml_2.3.8                 \n[107] evaluate_0.23               codetools_0.2-19           \n[109] tibble_3.2.1                cli_3.6.2                  \n[111] uwot_0.1.16                 xtable_1.8-4               \n[113] reticulate_1.34.0           munsell_0.5.0              \n[115] Rcpp_1.0.12                 GenomeInfoDb_1.38.5        \n[117] globals_0.16.2              spatstat.random_3.2-2      \n[119] png_0.1-8                   parallel_4.3.2             \n[121] ellipsis_0.3.2              ggplot2_3.4.4              \n[123] dotCall64_1.1-1             sparseMatrixStats_1.14.0   \n[125] bitops_1.0-7                listenv_0.9.0              \n[127] viridisLite_0.4.2           scales_1.3.0               \n[129] ggridges_0.5.5              crayon_1.5.2               \n[131] leiden_0.4.3.1              purrr_1.0.2                \n[133] rlang_1.1.3                \n```\n:::\n:::\n\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}