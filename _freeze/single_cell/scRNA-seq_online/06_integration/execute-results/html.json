{
  "hash": "ba0329d204b4089e94cac936722aacfd",
  "result": {
    "markdown": "---\ntitle: \"单细胞数据整合（Integration）\"\n---\n\n\n::: callout-note\n###### Learning Objectives:\n\n-   Perform integration of cells across conditions to identify cells that are similar to each other\n-   Describe complex integration tasks and alternative tools for integration\n:::\n\n![](images/sc_workflow_2022-01.jpg){width=\"545\"}\n\n------------------------------------------------------------------------\n\n**Goals:**\n\n-   To **align same cell types** across conditions.\n\n**Challenges:**\n\n-   **Aligning cells of similar cell types** so that we do not have clustering downstream due to differences between samples, conditions, modalities, or batches\n\n**Recommendations:**\n\n-   Go through the analysis without integration first to determine whether integration is necessary\n\n------------------------------------------------------------------------\n\n# 不进行整合时检验细胞分群情况\n\nGenerally, we always look at our clustering **without integration** before deciding whether we need to perform any alignment. **Do not just always perform integration because you think there might be differences - explore the data.** If we had performed the normalization on both conditions together in a Seurat object and visualized the similarity between cells, we would have seen condition-specific clustering.\n\n## 数据导入\n\nWe use the `split_seurat` object from the [previous lesson](/single_cell/scRNA-seq_online/06_SC_SCT_normalization.qmd).\n\n\n::: {.cell hash='06_integration_cache/html/unnamed-chunk-1_cbaa5da497e5a9910aa358babc831889'}\n\n```{.r .cell-code}\nlibrary(Seurat)\nsplit_seurat <- readRDS(\"output/scRNA-seq_online/split_seurat.rds\")\nsplit_seurat\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nAn object of class Seurat \n28130 features across 29629 samples within 2 assays \nActive assay: SCT (14065 features, 3000 variable features)\n 3 layers present: counts, data, scale.data\n 1 other assay present: RNA\n 1 dimensional reduction calculated: pca\n```\n:::\n\n```{.r .cell-code}\n# Check which assays are stored in objects\nsplit_seurat@assays\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n$RNA\nAssay (v5) data with 14065 features for 29629 cells\nFirst 10 features:\n AL627309.1, AL669831.5, LINC00115, FAM41C, NOC2L, KLHL17, PLEKHN1,\nHES4, ISG15, AGRN \nLayers:\n counts.ctrl, counts.stim \n\n$SCT\nSCTAssay data with 14065 features for 29629 cells, and 2 SCTModel(s) \nTop 10 variable features:\n FTL, IGKC, CCL2, GNLY, IGLC2, CCL3, CCL4, CXCL10, CCL7, TIMP1 \n```\n:::\n\n```{.r .cell-code}\n# 查看目前默认的assay\nDefaultAssay(split_seurat)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"SCT\"\n```\n:::\n\n```{.r .cell-code}\n# 查看默认assay的layers\nLayers(split_seurat)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"counts\"     \"data\"       \"scale.data\"\n```\n:::\n\n```{.r .cell-code}\n# 查看每种样本包含多少细胞\ntable(split_seurat$sample)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\n ctrl  stim \n14847 14782 \n```\n:::\n\n```{.r .cell-code}\n# 查看降维信息\nnames(split_seurat@reductions)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"pca\"\n```\n:::\n:::\n\n\n![](images/截屏2023-12-19%2010.46.18.png)\n\n## 降维、分群\n\n\n::: {.cell hash='06_integration_cache/html/fig-整合前的细胞分群情况_8fbed1c0d4ff5538fc2638b0e877f497'}\n\n```{.r .cell-code}\n# Run PCA\nsplit_seurat <- RunPCA(split_seurat)\n# Run UMAP\nsplit_seurat <- RunUMAP(split_seurat, \n                        dims = 1:40, \n                        reduction = \"pca\", \n                        reduction.name = \"umap.unintegrated\")\n\n# 分群\nsplit_seurat <- FindNeighbors(split_seurat, \n                              dims = 1:40, \n                              reduction = \"pca\")\nsplit_seurat <- FindClusters(split_seurat, \n                             cluster.name = \"unintegrated_clusters\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nModularity Optimizer version 1.3.0 by Ludo Waltman and Nees Jan van Eck\n\nNumber of nodes: 29629\nNumber of edges: 1104454\n\nRunning Louvain algorithm...\nMaximum modularity in 10 random starts: 0.8974\nNumber of communities: 22\nElapsed time: 4 seconds\n```\n:::\n\n```{.r .cell-code}\n# Plot UMAP\np1 <- DimPlot(split_seurat, reduction = \"umap.unintegrated\", group.by = \"sample\")\np2 <- DimPlot(split_seurat, reduction = \"umap.unintegrated\", split.by = \"sample\")\nlibrary(cowplot)\nplot_grid(p1, p2, ncol = 2, labels = \"AUTO\")\n```\n\n::: {.cell-output-display}\n![整合前的细胞分群情况](06_integration_files/figure-html/fig-整合前的细胞分群情况-1.png){#fig-整合前的细胞分群情况 width=1920}\n:::\n:::\n\n\n可以看到，如果不进行整合，不同样本（ctrl vs. stim）间的细胞类型差异很大。The resulting clusters are defined **both by cell type** **and stimulation condition**, which creates challenges for downstream analysis. Condition-specific clustering of the cells indicates that we need to integrate the cells across conditions to ensure that cells of the same cell type cluster together.\n\n::: callout-tip\n关于`FindNeighbors()`和`FindClusters()`的详细说明见[下一节](/single_cell/scRNA-seq_online/07_SC_clustering_cells_SCT.qmd)。\n:::\n\n::: callout-note\n###### **Why is it important the cells of the same cell type cluster together?**\n\nWe want to identify **cell types which are present in all samples/conditions/modalities** within our dataset, and therefore would like to observe a representation of cells from both samples/conditions/modalities in every cluster. This will enable more interpretable results downstream (i.e. DE analysis, ligand-receptor analysis, differential abundance analysis...).\n:::\n\nIn this lesson, we will cover the integration of our samples across conditions, which is adapted from [Seurat-整合](/single_cell/seurat/integration.qmd).\n\n::: callout-note\n在此前的[Seurat-基于SCTransform](/single_cell/seurat/sctransform.qmd)中我们学习了how to run through the workflow from normalization to clustering without integration. Other steps in the workflow remain fairly similar, but the **samples would not necessarily be split** in the beginning and integration would not be performed.\n\nIt can help to first run conditions individually if unsure what clusters to expect or expecting some different cell types between conditions (e.g. tumor and control samples), then run them together to see whether there are condition-specific clusters for cell types present in both conditions. Oftentimes, when clustering cells from multiple conditions there are condition-specific clusters and integration can help ensure the same cell types cluster together.\n:::\n\n# **整合**\n\n**If cells cluster by sample, condition, batch, dataset, modality, this integration step can greatly improve the clustering and the downstream analyses**.\n\nTo integrate, we will use the shared highly variable genes (identified using `SCTransform`) from each group, then, we will \"integrate\" or \"harmonize\" the groups to overlay cells that are similar or have a \"common set of biological features\" between groups. For example, we could integrate across:\n\n-   Different **conditions** (e.g. control and stimulated)\n\n    ![](images/seurat_condition_integ.png)\n\n-   Different **datasets** (e.g. scRNA-seq from datasets generated using different library preparation methods on the same samples)\n\n    ![](images/seurat_dataset_integ.png)\n\n-   Different **modalities** (e.g. scRNA-seq and scATAC-seq)\n\n    ![](images/seurat_modality_integ.png)\n\n-   Different **batches** (e.g. when experimental conditions make batch processing of samples necessary)\n\nThe goal of integration is to ensure that the cell types of one condition/dataset align with the same celltypes of the other conditions/datasets (e.g. control macrophages align with stimulated macrophages).\n\n## Integration using CCA\n\nSeurat v5 enables streamlined integrative analysis using the `IntegrateLayers` function. The method currently supports **five integration methods**. Each of these methods performs integration in low-dimensional space, and **returns a dimensional reduction** (i.e. `integrated.rpca`) that aims to co-embed shared cell types across batches:\n\nThe **anchor-based CCA integration** (`method=CCAIntegration`) utilizes the canonical correlation analysis (CCA). This method expects \"correspondences\" or **shared biological states** among at least a subset of single cells across the groups. The steps in the `Seurat` integration workflow are outlined in the figure below:\n\n![](images/integration.png)\n\n> Image credit: [@stuart2019]\n\nThe different steps applied are as follows:\n\n1.  Perform **canonical correlation analysis (CCA):**\n\n    CCA identifies shared sources of variation between the conditions/groups. It is a form of PCA, in that it **identifies the greatest sources of variation** in the data, but only if it is **shared or conserved** across the conditions/groups (using the 3000 most variant genes from each sample).\n\n    This step roughly aligns the cells using the greatest shared sources of variation.\n\n    ::: callout-note\n    The shared highly variable genes are used because they are the most likely to represent those genes distinguishing the different cell types present.\n    :::\n\n2.  **Identify anchors** or mutual nearest neighbors (MNNs) across datasets (sometimes incorrect anchors are identified):\n\n    MNNs can be thought of as 'best buddies'. For each cell in one condition:\n\n    -   The cell's closest neighbor in the other condition is identified based on gene expression values - its 'best buddy'.\n    -   The reciprocal analysis is performed, and if the two cells are 'best buddies' in both directions, then those cells will be marked as **anchors** to 'anchor' the two datasets together.\n\n    > \"The difference in expression values between cells in an MNN pair provides an estimate of the batch effect, which is made more precise by averaging across many such pairs. A correction vector is obtained and applied to the expression values to perform batch correction.\" [@stuart2019]\n\n3.  **Filter anchors** to remove incorrect anchors:\n\n    Assess the similarity between anchor pairs by the overlap in their local neighborhoods (incorrect anchors will have low scores) - do the adjacent cells have 'best buddies' that are adjacent to each other?\n\n4.  **Integrate** the conditions/datasets:\n\n    Use anchors and corresponding scores to transform the cell expression values, allowing for the integration of the conditions/datasets (different samples, conditions, datasets, modalities)\n\n    ::: callout-note\n    Transformation of each cell uses a weighted average of the two cells of each anchor across anchors of the datasets. Weights determined by cell similarity score (distance between cell and k nearest anchors) and anchor scores, so cells in the same neighborhood should have similar correction values.\n    :::\n\n    **If cell types are present in one dataset, but not the other, then the cells will still appear as a separate sample-specific cluster.**\n\nNow, using our `SCTransform` object as input, let's perform the integration across conditions.\n\n\n::: {.cell hash='06_integration_cache/html/unnamed-chunk-3_3119163a514792607995c8269b506c6b'}\n\n```{.r .cell-code}\n# 可以看到目前的降维信息包括\"pca\"和\"umap.unintegrated\"\nnames(split_seurat@reductions)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"pca\"               \"umap.unintegrated\"\n```\n:::\n\n```{.r .cell-code}\n# 整合，比较耗时间（约13min），进度条会一直显示0%直至运算完成\nlibrary(beepr)\nseurat_integrated <- IntegrateLayers(object = split_seurat,\n                                     method = CCAIntegration,\n                                     normalization.method = \"SCT\", # 指定使用的标准化方法为SCTransform\n                                     orig.reduction = \"pca\",\n                                     new.reduction = \"integrated.cca\", #  整合后新的降维数据的名称\n                                     verbose = FALSE); beep()\n\n# 整合后重新合并RNA layer\nseurat_integrated[[\"RNA\"]] <- JoinLayers(seurat_integrated[[\"RNA\"]])\n\n# 查看整合后的降维信息\nnames(seurat_integrated@reductions)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"pca\"               \"umap.unintegrated\" \"integrated.cca\"   \n```\n:::\n:::\n\n\n::: callout-tip\n如何调用Seurat嵌入的其他整合算法进行整合，参考：[Seurat v5单细胞数据整合分析](/single_cell/seurat/integrative_analysis_in_seurat_v5.qmd)。\n:::\n\n# 整合后检验细胞分群情况\n\nAfter integration, to visualize the integrated data we can use dimensionality reduction techniques, such as PCA and Uniform Manifold Approximation and Projection (UMAP). While PCA will determine all PCs, we can only plot two at a time. In contrast, UMAP will take the information from any number of top PCs to arrange the cells in this multidimensional space. It will take those distances in multidimensional space and plot them in two dimensions working to preserve local and global structure. In this way, the distances between cells represent similarity in expression. If you wish to explore UMAP in more detail, [this post](https://pair-code.github.io/understanding-umap/) is a nice introduction to UMAP theory.\n\nHere, we **visualize with UMAP**. UMAP is a stochastic algorithm -- this means that it makes use of randomness both to speed up approximation steps, and to aid in solving hard optimization problems. Due to the stochastic nature, different runs of UMAP can produce different results. We can **set the seed** to a specific (but random) number, and this avoids the creation of a slightly different UMAP each time re-run our code.\n\n\n::: {.cell hash='06_integration_cache/html/fig-整合前后细胞分群情况_ecd9eb6eb1a9e1fe5fa431c821c510ae'}\n\n```{.r .cell-code}\n# Set seed\nset.seed(123456)\n# Run UMAP\nseurat_integrated <- RunUMAP(seurat_integrated, \n                             dims = 1:40,\n                             reduction = \"integrated.cca\", # 更改降维来源为整合后的\"integrated.cca\"\n                             reduction.name = \"umap.integrated\") \n\n# 分群\nseurat_integrated <- FindNeighbors(seurat_integrated, \n                                   dims = 1:40, \n                                   reduction = \"integrated.cca\") #更改降维来源为\"integrated.cca\"\n                                   \nseurat_integrated <- FindClusters(seurat_integrated, \n                                  cluster.name = \"integrated_clusters\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nModularity Optimizer version 1.3.0 by Ludo Waltman and Nees Jan van Eck\n\nNumber of nodes: 29629\nNumber of edges: 1128935\n\nRunning Louvain algorithm...\nMaximum modularity in 10 random starts: 0.8864\nNumber of communities: 22\nElapsed time: 4 seconds\n```\n:::\n\n```{.r .cell-code}\n# Plot UMAP                             \np3 <- DimPlot(seurat_integrated, \n              reduction = \"umap.integrated\", \n              group.by = \"sample\")\np4 <- DimPlot(seurat_integrated, \n              reduction = \"umap.integrated\", \n              split.by = \"sample\")\nplot_grid(p1, p2, p3, p4, \n          ncol = 2, labels = \"AUTO\")\n```\n\n::: {.cell-output-display}\n![整合前后细胞分群情况（A, B: 整合前；C, D: 整合后）](06_integration_files/figure-html/fig-整合前后细胞分群情况-1.png){#fig-整合前后细胞分群情况 width=1920}\n:::\n:::\n\n\n> When we compare the similarity between the ctrl and stim clusters in the above plot with what we see using the the unintegrated dataset, **it is clear that this dataset benefitted from the integration!**\n\n## Save the \"integrated\" object!\n\n\n::: {.cell hash='06_integration_cache/html/unnamed-chunk-5_af8e3d78a2490eab444726aa8d6d2cf5'}\n\n```{.r .cell-code}\n# Save integrated seurat object\nsaveRDS(seurat_integrated, \"output/scRNA-seq_online/integrated_seurat.rds\")\n```\n:::\n\n\n# Complex Integration Tasks\n\nIn the section above, we've presented the `Seurat` integration workflow, which uses canonical correlation analysis (CCA) and multiple nearest neighbors (MNN) to find \"anchors\" and integrate across samples, conditions, modalities, etc. While the `Seurat` integration approach is widely used and several benchmarking studies support its great performance in many cases, it is important to recognize that **alternative integration algorithms exist and may work better for more complex integration tasks** (see [@luecken2021] for a comprehensive review).\n\nNot all integration algorithms rely on the same methodology, and they do not always provide the same type of corrected output (embeddings, count matrix...). Their performance is also affected by preliminary data processing steps, including which normalization method was used and how highly variable genes (HVGs) were determined. All those considerations are important to keep in mind when selecting a data integration approach for your study.\n\n**What do we mean by a \"complex\" integration task?**\n\nIn their benchmarking study [@luecken2021] compared the performance of different scRNA-seq integration tools when confronted to different \"complex\" tasks. The \"complexity\" of integrating a dataset may relate to the number of samples (perhaps generated using different protocols) but also to the biological question the study seeks to address (e.g. comparing cell types across tissues, species...). In these contexts, you may **need to integrate across multiple confounding factors before you can start exploring the biology of your system.**\n\n![](images/complex_integration.png){width=\"597\"}\n\nIn these more complex scenarios, you want to select a data integration approach that successfully balances out the following challenges:\n\n-   Correcting for **inter-sample variability** due to source samples from different donors\n-   Correcting for variability across **protocols/technologies** (10X, SMART-Seq2, inDrop...; single-cell vs. single nucleus; variable number of input cells and sequencing depth; different sample preparation steps...)\n-   Identifying consistent cell types across **different tissues** (peripheral blood, bone marrow, lung...) and/or different locations (e.g. areas of the brain)\n-   Keeping apart cell subtypes (or even cell states) that show similar transcriptomes (CD4 naive vs. memory, NK vs NKT)\n-   Keeping apart cell subtypes that are unique to a tissue/condition\n-   Conserving the developmental trajectory, if applicable\n\nNot all tools may perform as well on every task, and complex datasets may require testing several data integration approaches. You might want to analyze independently each of the batches you consider to integrate across, in order to define cell identities at this level before integrating and checking that the initially annotated cell types are mixed as expected.\n\n## Harmonizing as a method of integration\n\nHarmony [@korsunsky2019] was devleoped in 2019, and is an example of **a tool that can work with complex integration tasks**. It is available as an [GitHub](#0) and [CRAN](#0), and it has functions for standalone and Seurat pipeline analyses. It has been shown to perform incredibly well from recent benchmarking studies [@tran2020].\n\n在Seurat工作流的基础上实现基于Harmony的单细胞数据整合，可以使用`Harmony`包（available on [GitHub](https://github.com/immunogenomics/harmony) and [CRAN](https://cran.r-project.org/web/packages/harmony/index.html)），详见[该教程](https://hbctraining.github.io/scRNA-seq_online/lessons/06a_integration_harmony.html)。同时，Seurat V5中的`IntegrateLayers`函数集成了Harmony整合算法，可以直接调用，详见：[Seurat v5单细胞数据整合分析](/single_cell/seurat/integrative_analysis_in_seurat_v5.qmd#sec-sc_integration)。Compared to other algorithms, `Harmony` notably presents the following advantages [@korsunsky2019] [@tran2020]:\n\n1.  Possibility to integrate data across several variables (for example, by experimental batch and by condition)\n\n2.  Significant gain in speed and lower memory requirements for integration of large datasets\n\n3.  Interoperability with the `Seurat` workflow\n\n------------------------------------------------------------------------\n\n::: {.callout-note collapse=\"true\" icon=\"false\"}\n## Session Info\n\n\n::: {.cell hash='06_integration_cache/html/unnamed-chunk-6_62dc81563f60dc2ac9390c7f966c2592'}\n::: {.cell-output .cell-output-stdout}\n```\nR version 4.3.2 (2023-10-31)\nPlatform: aarch64-apple-darwin20 (64-bit)\nRunning under: macOS Sonoma 14.3\n\nMatrix products: default\nBLAS:   /Library/Frameworks/R.framework/Versions/4.3-arm64/Resources/lib/libRblas.0.dylib \nLAPACK: /Library/Frameworks/R.framework/Versions/4.3-arm64/Resources/lib/libRlapack.dylib;  LAPACK version 3.11.0\n\nlocale:\n[1] en_US.UTF-8/en_US.UTF-8/en_US.UTF-8/C/en_US.UTF-8/en_US.UTF-8\n\ntime zone: Asia/Shanghai\ntzcode source: internal\n\nattached base packages:\n[1] stats     graphics  grDevices utils     datasets  methods   base     \n\nother attached packages:\n[1] beepr_1.3          cowplot_1.1.2      Seurat_5.0.1       SeuratObject_5.0.1\n[5] sp_2.1-2          \n\nloaded via a namespace (and not attached):\n  [1] deldir_2.0-2           pbapply_1.7-2          gridExtra_2.3         \n  [4] rlang_1.1.3            magrittr_2.0.3         RcppAnnoy_0.0.21      \n  [7] spatstat.geom_3.2-7    matrixStats_1.2.0      ggridges_0.5.5        \n [10] compiler_4.3.2         png_0.1-8              vctrs_0.6.5           \n [13] reshape2_1.4.4         stringr_1.5.1          pkgconfig_2.0.3       \n [16] fastmap_1.1.1          ellipsis_0.3.2         labeling_0.4.3        \n [19] utf8_1.2.4             promises_1.2.1         rmarkdown_2.25        \n [22] purrr_1.0.2            xfun_0.41              jsonlite_1.8.8        \n [25] goftest_1.2-3          later_1.3.2            spatstat.utils_3.0-4  \n [28] irlba_2.3.5.1          parallel_4.3.2         cluster_2.1.6         \n [31] R6_2.5.1               ica_1.0-3              stringi_1.8.3         \n [34] RColorBrewer_1.1-3     spatstat.data_3.0-4    reticulate_1.34.0     \n [37] parallelly_1.36.0      lmtest_0.9-40          scattermore_1.2       \n [40] Rcpp_1.0.12            knitr_1.45             tensor_1.5            \n [43] future.apply_1.11.1    audio_0.1-11           zoo_1.8-12            \n [46] sctransform_0.4.1      httpuv_1.6.13          Matrix_1.6-5          \n [49] splines_4.3.2          igraph_1.6.0           tidyselect_1.2.0      \n [52] abind_1.4-5            rstudioapi_0.15.0      yaml_2.3.8            \n [55] spatstat.random_3.2-2  codetools_0.2-19       miniUI_0.1.1.1        \n [58] spatstat.explore_3.2-5 listenv_0.9.0          lattice_0.22-5        \n [61] tibble_3.2.1           plyr_1.8.9             withr_3.0.0           \n [64] shiny_1.8.0            ROCR_1.0-11            evaluate_0.23         \n [67] Rtsne_0.17             future_1.33.1          fastDummies_1.7.3     \n [70] survival_3.5-7         polyclip_1.10-6        fitdistrplus_1.1-11   \n [73] pillar_1.9.0           KernSmooth_2.23-22     plotly_4.10.4         \n [76] generics_0.1.3         RcppHNSW_0.5.0         ggplot2_3.4.4         \n [79] munsell_0.5.0          scales_1.3.0           globals_0.16.2        \n [82] xtable_1.8-4           glue_1.7.0             lazyeval_0.2.2        \n [85] tools_4.3.2            data.table_1.14.10     RSpectra_0.16-1       \n [88] RANN_2.6.1             leiden_0.4.3.1         dotCall64_1.1-1       \n [91] grid_4.3.2             tidyr_1.3.0            colorspace_2.1-0      \n [94] nlme_3.1-164           patchwork_1.2.0        cli_3.6.2             \n [97] spatstat.sparse_3.0-3  spam_2.10-0            fansi_1.0.6           \n[100] viridisLite_0.4.2      dplyr_1.1.4            uwot_0.1.16           \n[103] gtable_0.3.4           digest_0.6.34          progressr_0.14.0      \n[106] ggrepel_0.9.5          farver_2.1.1           htmlwidgets_1.6.4     \n[109] htmltools_0.5.7        lifecycle_1.0.4        httr_1.4.7            \n[112] mime_0.12              MASS_7.3-60.0.1       \n```\n:::\n:::\n\n:::\n\n# References {.unnumbered}\n\n::: {#refs}\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}