[
  {
    "objectID": "single_cell/scRNA-seq_online/07_SC_clustering_cells_SCT.html#set-up",
    "href": "single_cell/scRNA-seq_online/07_SC_clustering_cells_SCT.html#set-up",
    "title": "24  细胞聚类（clustering analysis）",
    "section": "\n24.1 Set up",
    "text": "24.1 Set up\n读取上一节（ Chapter 23 ）中完成质控和整合的单细胞数据seurat_integrated。\n\nlibrary(Seurat)\nseurat_integrated &lt;- readRDS(\"output/scRNA-seq_online/integrated_seurat.rds\")\nseurat_integrated\n\nAn object of class Seurat \n28130 features across 29629 samples within 2 assays \nActive assay: SCT (14065 features, 3000 variable features)\n 3 layers present: counts, data, scale.data\n 1 other assay present: RNA\n 3 dimensional reductions calculated: pca, umap, integrated.cca\n\nhead(seurat_integrated, 5)\n\n                      orig.ident nCount_RNA nFeature_RNA sample\nctrl_AAACATACAATGCC-1          1       2344          874   ctrl\nctrl_AAACATACATTTCC-1          1       3125          896   ctrl\nctrl_AAACATACCAGAAA-1          1       2578          725   ctrl\nctrl_AAACATACCAGCTA-1          1       3261          979   ctrl\nctrl_AAACATACCATGCA-1          1        746          362   ctrl\n                      log10GenesPerUMI  mitoRatio                 cells\nctrl_AAACATACAATGCC-1        0.8728630 0.01962457 ctrl_AAACATACAATGCC-1\nctrl_AAACATACATTTCC-1        0.8447596 0.01792000 ctrl_AAACATACATTTCC-1\nctrl_AAACATACCAGAAA-1        0.8384933 0.01551590 ctrl_AAACATACCAGAAA-1\nctrl_AAACATACCAGCTA-1        0.8512622 0.01379945 ctrl_AAACATACCAGCTA-1\nctrl_AAACATACCATGCA-1        0.8906861 0.02144772 ctrl_AAACATACCATGCA-1\n                      nCount_SCT nFeature_SCT      S.Score    G2M.Score Phase\nctrl_AAACATACAATGCC-1       1598          864  0.010526369  0.011803814   G2M\nctrl_AAACATACATTTCC-1       1575          735  0.010251663  0.015119823   G2M\nctrl_AAACATACCAGAAA-1       1563          671 -0.019803499 -0.015779795    G1\nctrl_AAACATACCAGCTA-1       1587          775 -0.032093208  0.013380044   G2M\nctrl_AAACATACCATGCA-1       1086          374  0.008301833 -0.008402066     S\n                           mitoFr\nctrl_AAACATACAATGCC-1      Medium\nctrl_AAACATACATTTCC-1      Medium\nctrl_AAACATACCAGAAA-1      Medium\nctrl_AAACATACCAGCTA-1         Low\nctrl_AAACATACCATGCA-1 Medium high"
  },
  {
    "objectID": "single_cell/scRNA-seq_online/07_SC_clustering_cells_SCT.html#决定后续分析的主成分",
    "href": "single_cell/scRNA-seq_online/07_SC_clustering_cells_SCT.html#决定后续分析的主成分",
    "title": "24  细胞聚类（clustering analysis）",
    "section": "\n24.2 决定后续分析的主成分",
    "text": "24.2 决定后续分析的主成分\nTo overcome the extensive technical noise in the expression of any single gene for scRNA-seq data, Seurat assigns cells to clusters based on their PCA scores derived from the expression of the integrated most variable genes, with each PC essentially representing a “metagene” that combines information across a correlated gene set. Determining how many PCs to include in the clustering step is therefore important to ensure that we are capturing the majority of the variation, or cell types, present in our dataset.\nIt is useful to explore the PCs prior to deciding which PCs to include for the downstream clustering analysis.\n通过热图判断需要包括的主成分\nOne way of exploring the PCs is using a heatmap to visualize the most variant genes for select PCs with the genes and cells ordered by PCA scores. The idea here is to look at the PCs and determine whether the genes driving them make sense for differentiating the different cell types.\nThe cells argument specifies the number of cells with the most negative or postive PCA scores to use for the plotting. The idea is that we are looking for a PC where the heatmap starts to look more “fuzzy”, i.e. where the distinctions between the groups of genes is not so distinct.\n\n# Explore heatmap of PCs\nDimHeatmap(seurat_integrated, \n           dims = 1:9, \n           cells = 500, \n           balanced = TRUE)\n\n\n\n\nThis method can be slow and hard to visualize individual genes if we would like to explore a large number of PCs. In the same vein and to explore a large number of PCs, we could print out the top 10 (or more) positive and negative genes by PCA scores driving the PCs.\n\n# Printing out the most variable genes driving PCs\nprint(x = seurat_integrated[[\"pca\"]], \n      dims = 1:10, \n      nfeatures = 5)\n\nPC_ 1 \nPositive:  IGKC, GNLY, RPL3, RPL13, RPS18 \nNegative:  FTL, CCL2, CCL8, CXCL10, TIMP1 \nPC_ 2 \nPositive:  GNLY, CCL5, GZMB, NKG7, PRF1 \nNegative:  IGKC, IGHM, CD74, HLA-DRA, CD79A \nPC_ 3 \nPositive:  PABPC1, RPS18, RPL13, RPL10, RPS6 \nNegative:  GNLY, IGKC, GZMB, CCL5, NKG7 \nPC_ 4 \nPositive:  CCL4, CCL3, CCL4L2, CCL2, CCL8 \nNegative:  FTL, TIMP1, GNLY, HLA-DRA, VMO1 \nPC_ 5 \nPositive:  CCL4, CCL3, CCL4L2, TIMP1, VMO1 \nNegative:  CCL2, CCL7, CCL8, IGKC, GNLY \nPC_ 6 \nPositive:  FTL, CXCL8, CCL4L2, CXCL3, S100A8 \nNegative:  CXCL10, CCL8, ISG15, IGLC2, APOBEC3A \nPC_ 7 \nPositive:  IGKC, CXCL10, VMO1, TIMP1, FCGR3A \nNegative:  IGLC2, IGLC3, IGHM, CD74, HLA-DRA \nPC_ 8 \nPositive:  HBB, HBA2, HBA1, SNCA, HBG2 \nNegative:  IGLC2, PPBP, HLA-DRA, CD74, IGLC3 \nPC_ 9 \nPositive:  PPBP, PF4, GNG11, CAVIN2, TUBB1 \nNegative:  GNLY, FTL, TXN, RPL10, RPL3 \nPC_ 10 \nPositive:  TXN, HSPB1, HSPA1A, HSPA1B, HLA-DRA \nNegative:  IGLC2, TIMP1, VMO1, PPBP, IGHM \n\n\n通过肘图（elbow plot）判断需要包括的主成分\nThe elbow plot is another helpful way to determine how many PCs to use for clustering so that we are capturing majority of the variation in the data. The elbow plot visualizes the standard deviation of each PC, and we are looking for where the standard deviations begins to plateau. Essentially, where the elbow appears is usually the threshold for identifying the majority of the variation. However, this method can be quite subjective.\nLet’s draw an elbow plot using the top 40 PCs:\n\n# Plot the elbow plot\nElbowPlot(object = seurat_integrated, \n          ndims = 40)\n\n\n\n\nBased on this plot, we could roughly determine the majority of the variation by where the elbow occurs around PC8 - PC10, or one could argue that it should be when the data points start to get close to the X-axis, PC30 or so. This gives us a very rough idea of the number of PCs needed to be included, we can extract the information visualized here in a more quantitative manner, which may be a bit more reliable.\nWhile the above 2 methods were used a lot more with older methods from Seurat for normalization and identification of variable genes, they are no longer as important as they used to be. This is because the SCTransform method is more accurate than older methods，基于SCTransform的标准化流程中不再需要判断纳入的主成分数量，可以纳入更多的主成分（ Section 9.5 ）.\n\n\n\n\n\n\nWhy is selection of PCs more important for older methods?\n\n\n\nThe older methods incorporated some technical sources of variation into some of the higher PCs, so selection of PCs was more important. SCTransform estimates the variance better and does not frequently include these sources of technical variation in the higher PCs.\nIn theory, with SCTransform, the more PCs we choose the more variation is accounted for when performing the clustering, but it takes a lot longer to perform the clustering. Therefore for this analysis, we will use the first 40 PCs to generate the clusters."
  },
  {
    "objectID": "single_cell/scRNA-seq_online/07_SC_clustering_cells_SCT.html#聚类cluster-the-cells",
    "href": "single_cell/scRNA-seq_online/07_SC_clustering_cells_SCT.html#聚类cluster-the-cells",
    "title": "24  细胞聚类（clustering analysis）",
    "section": "\n24.3 聚类（Cluster the cells）",
    "text": "24.3 聚类（Cluster the cells）\nSeurat uses a graph-based clustering approach using a K-nearest neighbor approach, and then attempts to partition this graph into highly interconnected ‘quasi-cliques’ or ‘communities’ （ Section 7.7 ）. A nice in-depth description of clustering methods is provided in the SVI Bioinformatics and Cellular Genomics Lab course.\nFind neighbors\nThe first step is to construct a K-nearest neighbor (KNN) graph based on the euclidean distance in PCA space.\n\n\nImage source: Analysis of Single cell RNA-seq data\n\n\nEdges are drawn between cells with similar features expression patterns.\nEdge weights are refined between any two cells based on shared overlap in their local neighborhoods.\n\nThis is done in Seurat by using the FindNeighbors() function:\n\n# Determine the K-nearest neighbor graph\nseurat_integrated &lt;- FindNeighbors(object = seurat_integrated, \n                                   dims = 1:40)\n\nFind clusters\nNext, Seurat will iteratively group cells together with the goal of optimizing the standard modularity function.\nWe will use the FindClusters() function to perform the graph-based clustering. The resolution is an important argument that sets the “granularity” of the downstream clustering and will need to be optimized for every individual experiment. For datasets of 3,000 - 5,000 cells, the resolution set between 0.4-1.4 generally yields good clustering. Increased resolution values lead to a greater number of clusters, which is often required for larger datasets.\nThe FindClusters() function allows us to enter a series of resolutions and will calculate the “granularity” of the clustering. This is very helpful for testing which resolution works for moving forward without having to run the function for each resolution.\n\n# Determine the clusters for various resolutions                                \nseurat_integrated &lt;- FindClusters(object = seurat_integrated,\n                                  resolution = c(0.4, 0.6, 0.8, 1.0, 1.4))\n\nModularity Optimizer version 1.3.0 by Ludo Waltman and Nees Jan van Eck\n\nNumber of nodes: 29629\nNumber of edges: 1104454\n\nRunning Louvain algorithm...\nMaximum modularity in 10 random starts: 0.9278\nNumber of communities: 16\nElapsed time: 4 seconds\nModularity Optimizer version 1.3.0 by Ludo Waltman and Nees Jan van Eck\n\nNumber of nodes: 29629\nNumber of edges: 1104454\n\nRunning Louvain algorithm...\nMaximum modularity in 10 random starts: 0.9117\nNumber of communities: 20\nElapsed time: 4 seconds\nModularity Optimizer version 1.3.0 by Ludo Waltman and Nees Jan van Eck\n\nNumber of nodes: 29629\nNumber of edges: 1104454\n\nRunning Louvain algorithm...\nMaximum modularity in 10 random starts: 0.8974\nNumber of communities: 22\nElapsed time: 5 seconds\nModularity Optimizer version 1.3.0 by Ludo Waltman and Nees Jan van Eck\n\nNumber of nodes: 29629\nNumber of edges: 1104454\n\nRunning Louvain algorithm...\nMaximum modularity in 10 random starts: 0.8847\nNumber of communities: 24\nElapsed time: 4 seconds\nModularity Optimizer version 1.3.0 by Ludo Waltman and Nees Jan van Eck\n\nNumber of nodes: 29629\nNumber of edges: 1104454\n\nRunning Louvain algorithm...\nMaximum modularity in 10 random starts: 0.8625\nNumber of communities: 29\nElapsed time: 4 seconds"
  },
  {
    "objectID": "single_cell/scRNA-seq_online/07_SC_clustering_cells_SCT.html#visualize-clusters-of-cells",
    "href": "single_cell/scRNA-seq_online/07_SC_clustering_cells_SCT.html#visualize-clusters-of-cells",
    "title": "24  细胞聚类（clustering analysis）",
    "section": "\n24.4 Visualize clusters of cells",
    "text": "24.4 Visualize clusters of cells\nTo visualize the cell clusters, there are a few different dimensionality reduction techniques that can be helpful. The most popular methods include t-distributed stochastic neighbor embedding (t-SNE) and Uniform Manifold Approximation and Projection (UMAP) techniques.\nBoth methods aim to place cells with similar local neighborhoods in high-dimensional space together in low-dimensional space. These methods will require you to input number of PCA dimentions to use for the visualization, we suggest using the same number of PCs as input to the clustering analysis. Here, we will proceed with the UMAP method for visualizing the clusters.\nWe can only visualize the results of one resolution setting at a time. If we look at the metadata of our Seurat object(seurat_integrated@meta.data), you should observe a separate column for each of the different resolutions calculated.\n\n# Explore resolutions\nhead(seurat_integrated@meta.data, 5)\n\n                      orig.ident nCount_RNA nFeature_RNA sample\nctrl_AAACATACAATGCC-1          1       2344          874   ctrl\nctrl_AAACATACATTTCC-1          1       3125          896   ctrl\nctrl_AAACATACCAGAAA-1          1       2578          725   ctrl\nctrl_AAACATACCAGCTA-1          1       3261          979   ctrl\nctrl_AAACATACCATGCA-1          1        746          362   ctrl\n                      log10GenesPerUMI  mitoRatio                 cells\nctrl_AAACATACAATGCC-1        0.8728630 0.01962457 ctrl_AAACATACAATGCC-1\nctrl_AAACATACATTTCC-1        0.8447596 0.01792000 ctrl_AAACATACATTTCC-1\nctrl_AAACATACCAGAAA-1        0.8384933 0.01551590 ctrl_AAACATACCAGAAA-1\nctrl_AAACATACCAGCTA-1        0.8512622 0.01379945 ctrl_AAACATACCAGCTA-1\nctrl_AAACATACCATGCA-1        0.8906861 0.02144772 ctrl_AAACATACCATGCA-1\n                      nCount_SCT nFeature_SCT      S.Score    G2M.Score Phase\nctrl_AAACATACAATGCC-1       1598          864  0.010526369  0.011803814   G2M\nctrl_AAACATACATTTCC-1       1575          735  0.010251663  0.015119823   G2M\nctrl_AAACATACCAGAAA-1       1563          671 -0.019803499 -0.015779795    G1\nctrl_AAACATACCAGCTA-1       1587          775 -0.032093208  0.013380044   G2M\nctrl_AAACATACCATGCA-1       1086          374  0.008301833 -0.008402066     S\n                           mitoFr SCT_snn_res.0.4 SCT_snn_res.0.6\nctrl_AAACATACAATGCC-1      Medium               5               5\nctrl_AAACATACATTTCC-1      Medium               0               1\nctrl_AAACATACCAGAAA-1      Medium               1              13\nctrl_AAACATACCAGCTA-1         Low               1               0\nctrl_AAACATACCATGCA-1 Medium high               8               9\n                      SCT_snn_res.0.8 SCT_snn_res.1 SCT_snn_res.1.4\nctrl_AAACATACAATGCC-1               4             4               3\nctrl_AAACATACATTTCC-1               0             0               0\nctrl_AAACATACCAGAAA-1              14            16              19\nctrl_AAACATACCAGCTA-1               1             1              20\nctrl_AAACATACCATGCA-1              16            17              21\n                      seurat_clusters\nctrl_AAACATACAATGCC-1               3\nctrl_AAACATACATTTCC-1               0\nctrl_AAACATACCAGAAA-1              19\nctrl_AAACATACCAGCTA-1              20\nctrl_AAACATACCATGCA-1              21\n\n\nTo choose a resolution to start with, we often pick something in the middle of the range like 0.6 or 0.8. We will start with a resolution of 0.8 by assigning the identity of the clusters using the Idents() function.\n\n# Assign identity of clusters\nIdents(seurat_integrated) &lt;- \"SCT_snn_res.0.8\"\n\nNow, we can plot the UMAP to look at how cells cluster together at a resolution of 0.8:\n\n# Calculation of UMAP\n# DO NOT RUN (calculated in the last lesson)\nseurat_integrated &lt;- RunUMAP(seurat_integrated, \n                             reduction = \"integrated.cca\", \n                             dims = 1:40)\n\n\n# Plot the UMAP\nDimPlot(seurat_integrated,\n        reduction = \"umap\",\n        label = FALSE,\n        label.size = 6)\n\n\n\n\nIt can be useful to explore other resolutions as well. It will give you a quick idea about how the clusters would change based on the resolution parameter. For example, let’s switch to a resolution of 0.4:\n\n# Assign identity of clusters\nIdents(object = seurat_integrated) &lt;- \"SCT_snn_res.0.4\"\n\n# Plot the UMAP\nDimPlot(seurat_integrated,\n        reduction = \"umap\",\n        label = FALSE,\n        label.size = 6)\n\n\n\n\n载入案例数据\nHow does your UMAP plot compare to the one above?\nIt is possible that there is some variability in the way your clusters look compared to the image in this lesson. In particular you may see a difference in the labeling of clusters. This is an unfortunate consequence of slight variations in the versions of packages (mostly Seurat dependencies).\nIf your clusters look identical to what’s in the lesson, please go ahead to the next section.\n\nIf your clusters do look different from what we have in the lesson, please follow the instructions provided below.\nInside your data folder you will see a folder called additional_data. It contains the seurat_integrated object that we have created for the class. Let’s load in the object to your R session and overwrite the existing one:\n\nload(bzfile(\"data/scRNA-seq_online/additional_data/seurat_integrated.RData.bz2\"))\nseurat_integrated\n\nAn object of class Seurat \n31130 features across 29629 samples within 3 assays \nActive assay: integrated (3000 features, 3000 variable features)\n 2 layers present: data, scale.data\n 2 other assays present: RNA, SCT\n 2 dimensional reductions calculated: pca, umap\n\nhead(seurat_integrated, 5)\n\n                      orig.ident nCount_RNA nFeature_RNA\nctrl_AAACATACAATGCC-1       ctrl       2344          874\nctrl_AAACATACATTTCC-1       ctrl       3124          895\nctrl_AAACATACCAGAAA-1       ctrl       2578          725\nctrl_AAACATACCAGCTA-1       ctrl       3260          978\nctrl_AAACATACCATGCA-1       ctrl        746          362\n                                      seq_folder nUMI nGene log10GenesPerUMI\nctrl_AAACATACAATGCC-1 ctrl_raw_feature_bc_matrix 2344   874        0.8728630\nctrl_AAACATACATTTCC-1 ctrl_raw_feature_bc_matrix 3125   896        0.8447596\nctrl_AAACATACCAGAAA-1 ctrl_raw_feature_bc_matrix 2578   725        0.8384933\nctrl_AAACATACCAGCTA-1 ctrl_raw_feature_bc_matrix 3261   979        0.8512622\nctrl_AAACATACCATGCA-1 ctrl_raw_feature_bc_matrix  746   362        0.8906861\n                       mitoRatio                 cells sample     S.Score\nctrl_AAACATACAATGCC-1 0.01962457 ctrl_AAACATACAATGCC-1   ctrl  0.04330502\nctrl_AAACATACATTTCC-1 0.01792000 ctrl_AAACATACATTTCC-1   ctrl  0.02661900\nctrl_AAACATACCAGAAA-1 0.01551590 ctrl_AAACATACCAGAAA-1   ctrl -0.04670650\nctrl_AAACATACCAGCTA-1 0.01379945 ctrl_AAACATACCAGCTA-1   ctrl -0.05832833\nctrl_AAACATACCATGCA-1 0.02144772 ctrl_AAACATACCATGCA-1   ctrl  0.03929605\n                        G2M.Score Phase      mitoFr nCount_SCT nFeature_SCT\nctrl_AAACATACAATGCC-1  0.05422631   G2M      Medium       1572          829\nctrl_AAACATACATTTCC-1  0.05159679   G2M      Medium       1572          718\nctrl_AAACATACCAGAAA-1 -0.04841661    G1      Medium       1553          648\nctrl_AAACATACCAGCTA-1  0.05045960   G2M         Low       1576          756\nctrl_AAACATACCATGCA-1 -0.02995512     S Medium high       1075          363\n                      integrated_snn_res.0.4 integrated_snn_res.0.6\nctrl_AAACATACAATGCC-1                      2                      1\nctrl_AAACATACATTTCC-1                      0                      2\nctrl_AAACATACCAGAAA-1                      0                      3\nctrl_AAACATACCAGCTA-1                      0                      3\nctrl_AAACATACCATGCA-1                      5                      6\n                      integrated_snn_res.0.8 integrated_snn_res.1\nctrl_AAACATACAATGCC-1                      2                    2\nctrl_AAACATACATTTCC-1                      1                    0\nctrl_AAACATACCAGAAA-1                      3                   15\nctrl_AAACATACCAGCTA-1                      3                    3\nctrl_AAACATACCATGCA-1                      4                   12\n                      integrated_snn_res.1.4 seurat_clusters\nctrl_AAACATACAATGCC-1                      5               5\nctrl_AAACATACATTTCC-1                      0               0\nctrl_AAACATACCAGAAA-1                     19              19\nctrl_AAACATACCAGCTA-1                      3               3\nctrl_AAACATACCATGCA-1                     13              13\n\n\n\n\n\n\n\n\n\nWarning\n\n\n\n由于这里的案例数据是基于Seurat V5之前的版本创建的，所以数据结构和基于Seurat V5的结果有所差异。比较重要的区别是，这里的Seurat对象的没有layer结构；同时有一个“integrated” assay，用于存放整合后的信息，其类型仍属于SCT assay。而一个典型的经过SCTransform和整合的Seurat V5对象如下图所示（来自 Section 11.4.2 ）：\n\n可以看到没有“integrated” assay，因此，为了和最新的Seurat V5流程保持一致，我们后续把本案例中的“integrated” assay看作整合后的Seurat V5的“SCT” assay。\n\n\n再次检查不同分辨率下的细胞分群情况\nAfter loading seurat_integrated.RData.bz2, we now re-check the object clusters with different resolution (0.4, 0.6, 0.8, 1.0, 1.4).\n\n# 查看不同分辨率下的细胞分群情况\napply(seurat_integrated@meta.data[ ,grep(\"integrated_snn_res.\", \n                                         colnames(seurat_integrated@meta.data))], \n      2, \n      table)\n\n$integrated_snn_res.0.4\n\n   0    1   10   11   12    2    3    4    5    6    7    8    9 \n6715 5899  456  280  124 3661 2680 2377 2166 2143 1217 1177  734 \n\n$integrated_snn_res.0.6\n\n   0    1   10   11   12   13   14    2    3    4    5    6    7    8    9 \n5443 3667 1176  467  464  288  124 3403 3306 2631 2382 2137 1679 1249 1213 \n\n$integrated_snn_res.0.8\n\n   0    1   10   11   12   13   14   15   16    2    3    4    5    6    7    8 \n4220 3718 1208 1174  858  468  459  289  124 3649 3004 2164 1959 1810 1646 1504 \n   9 \n1375 \n\n$integrated_snn_res.1\n\n   0    1   10   11   12   13   14   15   16   17   18   19    2   20   21    3 \n3392 3269 1158 1152  952  876  873  650  520  462  282  176 3041  124   23 2668 \n   4    5    6    7    8    9 \n2508 1881 1643 1509 1261 1209 \n\n$integrated_snn_res.1.4\n\n   0    1   10   11   12   13   14   15   16   17   18   19    2   20   21   22 \n2886 2497 1211 1174  874  838  832  802  766  657  655  629 2130  468  459  357 \n  23   24   25   26    3    4    5    6    7    8    9 \n 292  175  124   23 2011 1884 1827 1646 1587 1489 1336 \n\n\n\n# 批量绘制不同分辨率下的UMAP图\nlibrary(ggplot2)\nlibrary(patchwork)\nlapply(grep(\"integrated_snn_res.\",\n            colnames(seurat_integrated@meta.data), \n            value = TRUE),\n       function(res) {\n         Idents(seurat_integrated) &lt;-  res\n         DimPlot(seurat_integrated,\n                 reduction = \"umap\",\n                 label = FALSE,\n                 label.size = 4) +\n           ggtitle(res) +\n           theme_bw()\n         }) |&gt;\n  wrap_plots(ncol = 2)\n\n\n\n\n\nWe will now continue with the 0.8 resolution to check the quality control metrics and known markers for the anticipated cell types.\n\n# Assign identity of clusters\nIdents(seurat_integrated) &lt;- \"integrated_snn_res.0.8\"\n\n# Plot the UMAP\nDimPlot(seurat_integrated,\n        reduction = \"umap\",\n        label = TRUE,\n        label.size = 6)\n\n\n\n\n\nsaveRDS(seurat_integrated, file = \"output/scRNA-seq_online/seurat_clustered.rds\")\n\n\n\n\n\n\n\n\nSession Info\n\n\n\n\n\n\n\nR version 4.3.2 (2023-10-31)\nPlatform: aarch64-apple-darwin20 (64-bit)\nRunning under: macOS Sonoma 14.2.1\n\nMatrix products: default\nBLAS:   /Library/Frameworks/R.framework/Versions/4.3-arm64/Resources/lib/libRblas.0.dylib \nLAPACK: /Library/Frameworks/R.framework/Versions/4.3-arm64/Resources/lib/libRlapack.dylib;  LAPACK version 3.11.0\n\nlocale:\n[1] en_US.UTF-8/en_US.UTF-8/en_US.UTF-8/C/en_US.UTF-8/en_US.UTF-8\n\ntime zone: Asia/Shanghai\ntzcode source: internal\n\nattached base packages:\n[1] stats     graphics  grDevices utils     datasets  methods   base     \n\nother attached packages:\n[1] patchwork_1.1.3    ggplot2_3.4.4      Seurat_5.0.1       SeuratObject_5.0.1\n[5] sp_2.1-2          \n\nloaded via a namespace (and not attached):\n  [1] deldir_2.0-2           pbapply_1.7-2          gridExtra_2.3         \n  [4] rlang_1.1.2            magrittr_2.0.3         RcppAnnoy_0.0.21      \n  [7] spatstat.geom_3.2-7    matrixStats_1.2.0      ggridges_0.5.5        \n [10] compiler_4.3.2         png_0.1-8              vctrs_0.6.5           \n [13] reshape2_1.4.4         stringr_1.5.1          pkgconfig_2.0.3       \n [16] fastmap_1.1.1          ellipsis_0.3.2         labeling_0.4.3        \n [19] utf8_1.2.4             promises_1.2.1         rmarkdown_2.25        \n [22] purrr_1.0.2            xfun_0.41              jsonlite_1.8.8        \n [25] goftest_1.2-3          later_1.3.2            spatstat.utils_3.0-4  \n [28] irlba_2.3.5.1          parallel_4.3.2         cluster_2.1.6         \n [31] R6_2.5.1               ica_1.0-3              stringi_1.8.3         \n [34] RColorBrewer_1.1-3     spatstat.data_3.0-3    reticulate_1.34.0     \n [37] parallelly_1.36.0      lmtest_0.9-40          scattermore_1.2       \n [40] Rcpp_1.0.11            knitr_1.45             tensor_1.5            \n [43] future.apply_1.11.0    zoo_1.8-12             sctransform_0.4.1     \n [46] httpuv_1.6.13          Matrix_1.6-4           splines_4.3.2         \n [49] igraph_1.6.0           tidyselect_1.2.0       abind_1.4-5           \n [52] rstudioapi_0.15.0      yaml_2.3.8             spatstat.random_3.2-2 \n [55] codetools_0.2-19       miniUI_0.1.1.1         spatstat.explore_3.2-5\n [58] listenv_0.9.0          lattice_0.22-5         tibble_3.2.1          \n [61] plyr_1.8.9             withr_2.5.2            shiny_1.8.0           \n [64] ROCR_1.0-11            evaluate_0.23          Rtsne_0.17            \n [67] future_1.33.0          fastDummies_1.7.3      survival_3.5-7        \n [70] polyclip_1.10-6        fitdistrplus_1.1-11    pillar_1.9.0          \n [73] KernSmooth_2.23-22     plotly_4.10.3          generics_0.1.3        \n [76] RcppHNSW_0.5.0         munsell_0.5.0          scales_1.3.0          \n [79] globals_0.16.2         xtable_1.8-4           glue_1.6.2            \n [82] lazyeval_0.2.2         tools_4.3.2            data.table_1.14.10    \n [85] RSpectra_0.16-1        RANN_2.6.1             leiden_0.4.3.1        \n [88] dotCall64_1.1-1        cowplot_1.1.2          grid_4.3.2            \n [91] tidyr_1.3.0            colorspace_2.1-0       nlme_3.1-164          \n [94] cli_3.6.2              spatstat.sparse_3.0-3  spam_2.10-0           \n [97] fansi_1.0.6            viridisLite_0.4.2      dplyr_1.1.4           \n[100] uwot_0.1.16            gtable_0.3.4           digest_0.6.33         \n[103] progressr_0.14.0       ggrepel_0.9.4          farver_2.1.1          \n[106] htmlwidgets_1.6.4      htmltools_0.5.7        lifecycle_1.0.4       \n[109] httr_1.4.7             mime_0.12              MASS_7.3-60"
  },
  {
    "objectID": "single_cell/scRNA-seq_online/08_SC_clustering_quality_control.html#exploration-of-quality-control-metrics",
    "href": "single_cell/scRNA-seq_online/08_SC_clustering_quality_control.html#exploration-of-quality-control-metrics",
    "title": "25  细胞分群质量评估",
    "section": "\n25.1 Exploration of quality control metrics",
    "text": "25.1 Exploration of quality control metrics\nTo determine whether our clusters might be due to artifacts such as cell cycle phase or mitochondrial expression, it can be useful to explore these metrics visually to see if any clusters exhibit enrichment or are different from the other clusters. However, if enrichment or differences are observed for particular clusters it may not be worrisome if it can be explained by the cell type.\nTo explore and visualize the various quality metrics, we will use the versatile DimPlot() and FeaturePlot() functions from Seurat."
  },
  {
    "objectID": "single_cell/scRNA-seq_online/08_SC_clustering_quality_control.html#数据读取",
    "href": "single_cell/scRNA-seq_online/08_SC_clustering_quality_control.html#数据读取",
    "title": "25  细胞分群质量评估",
    "section": "\n25.2 数据读取",
    "text": "25.2 数据读取\n载入上一节中完成细胞分群的数据seurat_clustered。\n\nlibrary(Seurat)\nseurat_clustered &lt;- readRDS(\"output/scRNA-seq_online/seurat_clustered.rds\")\nseurat_clustered\n\nAn object of class Seurat \n31130 features across 29629 samples within 3 assays \nActive assay: integrated (3000 features, 3000 variable features)\n 2 layers present: data, scale.data\n 2 other assays present: RNA, SCT\n 2 dimensional reductions calculated: pca, umap\n\nhead(seurat_clustered, 5)\n\n                      orig.ident nCount_RNA nFeature_RNA\nctrl_AAACATACAATGCC-1       ctrl       2344          874\nctrl_AAACATACATTTCC-1       ctrl       3124          895\nctrl_AAACATACCAGAAA-1       ctrl       2578          725\nctrl_AAACATACCAGCTA-1       ctrl       3260          978\nctrl_AAACATACCATGCA-1       ctrl        746          362\n                                      seq_folder nUMI nGene log10GenesPerUMI\nctrl_AAACATACAATGCC-1 ctrl_raw_feature_bc_matrix 2344   874        0.8728630\nctrl_AAACATACATTTCC-1 ctrl_raw_feature_bc_matrix 3125   896        0.8447596\nctrl_AAACATACCAGAAA-1 ctrl_raw_feature_bc_matrix 2578   725        0.8384933\nctrl_AAACATACCAGCTA-1 ctrl_raw_feature_bc_matrix 3261   979        0.8512622\nctrl_AAACATACCATGCA-1 ctrl_raw_feature_bc_matrix  746   362        0.8906861\n                       mitoRatio                 cells sample     S.Score\nctrl_AAACATACAATGCC-1 0.01962457 ctrl_AAACATACAATGCC-1   ctrl  0.04330502\nctrl_AAACATACATTTCC-1 0.01792000 ctrl_AAACATACATTTCC-1   ctrl  0.02661900\nctrl_AAACATACCAGAAA-1 0.01551590 ctrl_AAACATACCAGAAA-1   ctrl -0.04670650\nctrl_AAACATACCAGCTA-1 0.01379945 ctrl_AAACATACCAGCTA-1   ctrl -0.05832833\nctrl_AAACATACCATGCA-1 0.02144772 ctrl_AAACATACCATGCA-1   ctrl  0.03929605\n                        G2M.Score Phase      mitoFr nCount_SCT nFeature_SCT\nctrl_AAACATACAATGCC-1  0.05422631   G2M      Medium       1572          829\nctrl_AAACATACATTTCC-1  0.05159679   G2M      Medium       1572          718\nctrl_AAACATACCAGAAA-1 -0.04841661    G1      Medium       1553          648\nctrl_AAACATACCAGCTA-1  0.05045960   G2M         Low       1576          756\nctrl_AAACATACCATGCA-1 -0.02995512     S Medium high       1075          363\n                      integrated_snn_res.0.4 integrated_snn_res.0.6\nctrl_AAACATACAATGCC-1                      2                      1\nctrl_AAACATACATTTCC-1                      0                      2\nctrl_AAACATACCAGAAA-1                      0                      3\nctrl_AAACATACCAGCTA-1                      0                      3\nctrl_AAACATACCATGCA-1                      5                      6\n                      integrated_snn_res.0.8 integrated_snn_res.1\nctrl_AAACATACAATGCC-1                      2                    2\nctrl_AAACATACATTTCC-1                      1                    0\nctrl_AAACATACCAGAAA-1                      3                   15\nctrl_AAACATACCAGCTA-1                      3                    3\nctrl_AAACATACCATGCA-1                      4                   12\n                      integrated_snn_res.1.4 seurat_clusters\nctrl_AAACATACAATGCC-1                      5               5\nctrl_AAACATACATTTCC-1                      0               0\nctrl_AAACATACCAGAAA-1                     19              19\nctrl_AAACATACCAGCTA-1                      3               3\nctrl_AAACATACCATGCA-1                     13              13"
  },
  {
    "objectID": "single_cell/scRNA-seq_online/08_SC_clustering_quality_control.html#分析样本类型是否影响细胞分群",
    "href": "single_cell/scRNA-seq_online/08_SC_clustering_quality_control.html#分析样本类型是否影响细胞分群",
    "title": "25  细胞分群质量评估",
    "section": "\n25.3 分析样本类型是否影响细胞分群",
    "text": "25.3 分析样本类型是否影响细胞分群\n首先通过UMAP图，直观查看不同样本类型的细胞分群情况：\n\n# 先简单查看一下分群情况及不同cluster的细胞数\ntable(seurat_clustered@active.ident)\n\n\n   0    1    2    3    4    5    6    7    8    9   10   11   12   13   14   15 \n4220 3718 3649 3004 2164 1959 1810 1646 1504 1375 1208 1174  858  468  459  289 \n  16 \n 124 \n\n# UMAP of cells in each cluster by sample\nDimPlot(seurat_clustered, \n        label = TRUE, \n        split.by = \"sample\") + \n  NoLegend()\n\n\n\n\n\n从UMAP图上可以直观的发现不同样本（ctrl vs. stim）的细胞分群非常一致，这是符合预期的。\n\n接下来通过提取不同样本类型中各cluster的细胞数来以数据的形式验证这种一致性。下面是实现方法：\n\n\n通过Seurat包的FetchData()函数可以从Seurat对象中提取指定的变量并形成行为细胞列为变量的数据框。这里通过关键词“ident”提取“active.ident”（即每个细胞所在的cluster的编号）；并提取”orig.ident”变量，即每个细胞对应的样本类型（ctrl vs. stim）（也可以提取“sample”）\n\n\n\n然后通过dplyr包的count()函数统计每个样本类型内每个cluster的细胞数量\n\n\n\n最后，通过tidyr包的pivot_wider()函数将长数据转换成宽数据。其中的names_from参数用于指定原数据中要拆分的那一列的名字（会在转换后的数据中变成列名）；values_from参数用于指定新数据集中单元格的值由旧数据的哪个（或哪些）变量的值填充\n\n\n\n\nlibrary(dplyr)\nlibrary(tidyr)\nn_cells &lt;- FetchData(seurat_clustered, \n                     vars = c(\"ident\", \"orig.ident\")) |&gt;\n        count(ident, orig.ident) |&gt;\n        pivot_wider(names_from = ident,\n                    values_from = n)\nn_cells\n\n# A tibble: 2 × 18\n  orig.ident   `0`   `1`   `2`   `3`   `4`   `5`   `6`   `7`   `8`   `9`  `10`\n  &lt;chr&gt;      &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt;\n1 ctrl        2017  2398  1840  1076  1112   976   952   830   775   661   600\n2 stim        2203  1320  1809  1928  1052   983   858   816   729   714   608\n# ℹ 6 more variables: `11` &lt;int&gt;, `12` &lt;int&gt;, `13` &lt;int&gt;, `14` &lt;int&gt;,\n#   `15` &lt;int&gt;, `16` &lt;int&gt;\n\n\n\n从该表中可以看出，不同样本类型下的各细胞群的细胞数量基本一致。These clusters look pretty similar between conditions, which is good since we expected similar cell types to be present in both control and stimulated conditions.\n\n\n\n\n\n\n\nCaution\n\n\n\nGenerally, we expect to see the majority of the cell type clusters to be present in all conditions; however, depending on the experiment we might expect to see some condition-specific cell types present."
  },
  {
    "objectID": "single_cell/scRNA-seq_online/08_SC_clustering_quality_control.html#分析细胞周期是否影响细胞分群",
    "href": "single_cell/scRNA-seq_online/08_SC_clustering_quality_control.html#分析细胞周期是否影响细胞分群",
    "title": "25  细胞分群质量评估",
    "section": "\n25.4 分析细胞周期是否影响细胞分群",
    "text": "25.4 分析细胞周期是否影响细胞分群\nNext, we can explore whether the cells cluster influenced by the different cell cycle phases. We did not regress out variation due to cell cycle phase when we performed the SCTransform normalization ( Section 22.2.2 ). If our cell clusters showed large differences in cell cycle expression, this would be an indication we would want to re-run the SCTransform and add the S.Score and G2M.Score to our variables to regress, then re-run the rest of the steps.\n\n# Explore whether clusters segregate by cell cycle phase\nDimPlot(seurat_clustered,\n        label = TRUE, \n        split.by = \"Phase\") + \n  NoLegend()\n\n\n\n\n\nWe do not see much clustering by cell cycle score, so we can proceed with the QC."
  },
  {
    "objectID": "single_cell/scRNA-seq_online/08_SC_clustering_quality_control.html#分析其他非期望变异来源是否会影响细胞分群",
    "href": "single_cell/scRNA-seq_online/08_SC_clustering_quality_control.html#分析其他非期望变异来源是否会影响细胞分群",
    "title": "25  细胞分群质量评估",
    "section": "\n25.5 分析其他非期望变异来源是否会影响细胞分群",
    "text": "25.5 分析其他非期望变异来源是否会影响细胞分群\nNext we will explore additional metrics, such as the number of UMIs and genes per cell, S-phase and G2M-phase markers, and mitochondrial gene expression by UMAP. Looking at the individual S and G2M scores can give us additional information to checking the phase as we did previously.\n\n\n\n\n\n\nTip\n\n\n\nThe order argument will plot the positive cells above the negative cells, while the min.cutoff argument will determine the threshold for shading. A min.cutoff of q10 translates to the 10% of cells with the lowest expression of the gene will not exhibit any purple shading (completely gray) (min.cutoff定义着色阈值。这里指定值最低的10%的细胞不着色).\n\n\n\n# Determine metrics to plot present in seurat_clustered@meta.data\nmetrics &lt;-  c(\"nUMI\", \"nGene\", \"S.Score\", \"G2M.Score\", \"mitoRatio\")\n\nFeaturePlot(seurat_clustered, \n            reduction = \"umap\", \n            features = metrics,\n            pt.size = 0.4, \n            order = TRUE,\n            min.cutoff = 'q10', \n            label = TRUE)\n\n\n\n\n\nThe metrics seem to be relatively even across the clusters, with the exception of nGene exhibiting slightly higher values in clusters to the left of the plot. We can keep an eye on these clusters to see whether the cell types may explain the increase.\nIf we see differences corresponding to any of these metrics at this point in time, then we will often note them and then decide after identifying the cell type identities whether to take any further action."
  },
  {
    "objectID": "single_cell/scRNA-seq_online/08_SC_clustering_quality_control.html#sec-Effect_of_pcs_clustering",
    "href": "single_cell/scRNA-seq_online/08_SC_clustering_quality_control.html#sec-Effect_of_pcs_clustering",
    "title": "25  细胞分群质量评估",
    "section": "\n25.6 分析主成分（PCs）对细胞分群的影响",
    "text": "25.6 分析主成分（PCs）对细胞分群的影响\nWe can also explore how well our clusters separate by the different PCs; we hope that the defined PCs separate the cell types well. To visualize this information, we need to extract the UMAP coordinate information for the cells along with their corresponding scores for each of the PCs to view by UMAP.\nFirst, we identify the information we would like to extract from the Seurat object, then, we can use the FetchData() function to extract it.\n\n# Defining the information in the seurat object of interest\ncolumns &lt;- c(\"ident\", paste0(\"PC_\", 1:16), \"UMAP_1\", \"UMAP_2\")\n\n# Extracting this data from the seurat object\npc_data &lt;- FetchData(seurat_clustered, \n                     vars = columns)\nhead(pc_data, 3)\n\n                      ident      PC_1      PC_2      PC_3      PC_4       PC_5\nctrl_AAACATACAATGCC-1     2 -14.97782 -2.879193 -5.059351 -1.602766  0.8728779\nctrl_AAACATACATTTCC-1     1  22.39233 -5.296913  4.951958  3.112632  0.3379874\nctrl_AAACATACCAGAAA-1     3  28.98473  1.203408 -5.947993 -1.042701 -7.5690434\n                           PC_6        PC_7       PC_8       PC_9     PC_10\nctrl_AAACATACAATGCC-1 -1.501420   0.5327841 -0.5855545  0.8866479 0.8223524\nctrl_AAACATACATTTCC-1 -7.873002   2.2740054 -5.8362430 -0.9666741 0.2170141\nctrl_AAACATACCAGAAA-1  5.477813 -10.7953185 19.5052392 -1.8312647 2.1803084\n                          PC_11      PC_12      PC_13       PC_14     PC_15\nctrl_AAACATACAATGCC-1 -1.722880 -0.1832132  0.2985759 -0.04539058  1.260942\nctrl_AAACATACATTTCC-1  3.105132 -0.7964707  2.8982516  0.04362601 -3.189937\nctrl_AAACATACCAGAAA-1 -7.796582 -1.3324607 -2.3117140  3.06677862  1.663382\n                           PC_16     UMAP_1    UMAP_2\nctrl_AAACATACAATGCC-1  0.1993319   7.270473 0.9072988\nctrl_AAACATACATTTCC-1  5.3805322  -8.742020 1.5622634\nctrl_AAACATACCAGAAA-1 -3.0593032 -10.032904 4.7139827\n\n\n\n\n\n\n\n\nTip\n\n\n\nHow did we know in the FetchData() function to include UMAP_1 to obtain the UMAP coordinates? Chapter 6 describes the function as being able to pull any data from the expression matrices, cell embeddings, or metadata.\nFor instance, if you explore the seurat_clustered@reductions list object, the first component is for PCA, and includes a slot for cell.embeddings (坐标数据). We can use the column names (PC_1, PC_2, PC_3, etc.) to pull out the coordinates or PC scores corresponding to each cell for each of the PCs (提取每个细胞在指定主成分上的坐标).\nWe could do the same thing for UMAP:\n\n# 提取前5个细胞在前两个UMAP主成分上的坐标\nseurat_clustered@reductions[[\"umap\"]]@cell.embeddings[1:5, 1:2]\n\n                          UMAP_1     UMAP_2\nctrl_AAACATACAATGCC-1   7.270473  0.9072988\nctrl_AAACATACATTTCC-1  -8.742020  1.5622634\nctrl_AAACATACCAGAAA-1 -10.032904  4.7139827\nctrl_AAACATACCAGCTA-1  -8.363044  5.0377137\nctrl_AAACATACCATGCA-1   6.875784 -4.6442526\n\n\n等价于：\n\nFetchData(seurat_clustered, vars = c(\"UMAP_1\", \"UMAP_2\")) |&gt; head(5)\n\nThe FetchData() function just allows us to extract the data more easily.\n\n\n\n\n\n\n\n\nCaution\n\n\n\nThe pre-existing seurat_clustered loaded in previously was created using an older version of Seurat. As such the columns we Fetch() are in upper case (i.e UMAP_1). If you are using your own seurat object using a newer version of Seurat you will need to change the column names as shown below. Alternatively, explore your Seurat object to see how they have been stored.\n\n # Defining the information in the seurat object of interest\n columns &lt;- c(\"ident\", paste0(\"PC_\", 1:16), \"umap_1\", \"umap_2\")\n\n\n\nIn the UMAP plots below, the cells are colored by their PC score for each respective principal component.\nLet’s take a quick look at the top 16 PCs:\n\n# Adding cluster label to center of cluster on UMAP\numap_label &lt;- FetchData(seurat_clustered, \n                        vars = c(\"ident\", \"UMAP_1\", \"UMAP_2\")) |&gt;\n  group_by(ident) |&gt; # 指定分组计算依据\n  summarise(UMAP1_mean = mean(UMAP_1), UMAP2_mean = mean(UMAP_2)) # 根据指定的分组依据进行分组计算\nhead(umap_label)\n\n# A tibble: 6 × 3\n  ident UMAP1_mean UMAP2_mean\n  &lt;fct&gt;      &lt;dbl&gt;      &lt;dbl&gt;\n1 0          8.42       1.99 \n2 1         -9.18       1.84 \n3 2          5.51       1.68 \n4 3         -8.49       3.87 \n5 4          6.67      -2.58 \n6 5          0.359      0.115\n\n# Plotting a UMAP plot for each of the PCs\nlibrary(purrr)\nlibrary(ggplot2)\nlibrary(cowplot)\nlibrary(dplyr)\nmap(paste0(\"PC_\", 1:16), \n    function(pc) {\n      ggplot(pc_data, \n             aes(UMAP_1, UMAP_2)) +\n        geom_point(aes_string(color = pc), \n                   alpha = 0.7) +\n        scale_color_gradient(low = \"grey90\", \n                             high = \"blue\") +\n        geom_text(data = umap_label, \n                  aes(label = ident, UMAP1_mean, UMAP2_mean)) +\n        ggtitle(pc)\n      }) %&gt;% \n  plot_grid(plotlist = .)\n\n\n\n\nWe can see how the clusters are represented by the different PCs. For instance, the genes driving PC_2 exhibit higher expression in clusters 8 and 12. We could look back at our genes driving this PC to get an idea of what the cell types might be:\n\n# 提取PCA信息中的第二主成分，并展示对该主成分影响最大的前5个基因名\nprint(seurat_clustered[[\"pca\"]], dims = 2, nfeatures = 5)\n\nPC_ 2 \nPositive:  GNLY, CCL5, NKG7, GZMB, FGFBP2 \nNegative:  CD74, IGHM, IGKC, HLA-DRA, CD79A \n\n\nWith the GNLY and NKG7 genes as positive markers of PC_2, we can hypothesize that clusters 8 and 12 correspond to NK cells ( Table 25.1 ). This just hints at what the clusters identity could be, with the identities of the clusters being determined through a combination of the PCs.\nTo truly determine the identity of the clusters and whether the resolution is appropriate, it is helpful to explore a handful of known gene markers for the cell types expected."
  },
  {
    "objectID": "single_cell/scRNA-seq_online/08_SC_clustering_quality_control.html#sec-explore_known_markers",
    "href": "single_cell/scRNA-seq_online/08_SC_clustering_quality_control.html#sec-explore_known_markers",
    "title": "25  细胞分群质量评估",
    "section": "\n25.7 探索已知的cell type markers的表达",
    "text": "25.7 探索已知的cell type markers的表达\nWith the cells clustered, we can explore the cell type identities by looking for known markers. 下面给出了本案例的cell type markers及其对应的细胞类型：\n\n\nTable 25.1: 细胞类型marker基因\n\nCell Type\nMarker\n\n\n\nCD14+ monocytes\nCD14, LYZ\n\n\nFCGR3A+ monocytes\nFCGR3A, MS4A7\n\n\nConventional dendritic cells\nFCER1A, CST3\n\n\nPlasmacytoid dendritic cells\nIL3RA, GZMB, SERPINF1, ITM2C\n\n\nMacrophages\nMARCO, ITGAM, ADGRE1\n\n\nB cells\nCD79A, MS4A1\n\n\nT cells\nCD3D\n\n\nCD4+ T cells\nCD3D, IL7R, CCR7\n\n\nCD8+ T cells\nCD3D, CD8A\n\n\nNK cells\nGNLY, NKG7\n\n\nMegakaryocytes\nPPBP\n\n\nErythrocytes\nHBB, HBA2\n\n\n\n\nThe FeaturePlot() function from Seurat makes it easy to visualize a handful of genes using the gene IDs stored in the Seurat object. We can easily explore the expression of known gene markers on top of our UMAP visualizations. Let’s go through and determine the identities of the clusters.\n\n\n\n\n\n\nCaution\n\n\n\nThe SCTransform normalization was performed only on the 3000 most variable genes, so many of our genes of interest may not be present in this data ( Section 22.3.5.1 ).\n\n\n\n\n\n\n\n\nWarning\n\n\n\n在原教程中，由于采用了Seurat V5之前的工作流（如 Section 24.4.1 所述），所以为了准确可视化marker基因的表达情况，将默认的assay改回了“RNA”，然后运行NormalizeData：\n\nDefaultAssay(seurat_clustered) \n\n[1] \"integrated\"\n\n# Select the RNA counts slot to be the default assay\nDefaultAssay(seurat_clustered) &lt;- \"RNA\"\n\n# Normalize RNA data for visualization purposes\nseurat_clustered &lt;- NormalizeData(seurat_clustered, verbose = FALSE)\n\nAssay is a slot defined in the Seurat object, it has multiple slots within it. In a given assay, the counts slot stores non-normalized raw counts, and the data slot stores normalized expression data. Therefore, when we run the NormalizeData() function in the above code, the normalized data will be stored in the data slot of the RNA assay while the counts slot will remain unaltered.\n而在Seurat V5的官方教程中（ Chapter 9 ），经过了SCTransform之后绘制marker基因的表达情况时，并没有执行这一步，默认的assay仍然是“SCT”。这里为了和原教程的图像一致，所以也进行这一步。而对于以后的Seurat V5工作流考虑按照官方教程的做法。\n\n\nDepending on our markers of interest, they could be positive or negative markers for a particular cell type. The combined expression of our chosen handful of markers should give us an idea on whether a cluster corresponds to that particular cell type.\nFor the markers used here, we are looking for positive markers and consistency of expression of the markers across the clusters. For example, if there are two markers for a cell type and only one of them is expressed in a cluster - then we cannot reliably assign that cluster to the cell type.\nCD14+ monocyte markers\n\nFeaturePlot(seurat_clustered, \n            reduction = \"umap\", \n            features = c(\"CD14\", \"LYZ\"), \n            order = TRUE,\n            min.cutoff = 'q10', \n            label = TRUE)\n\n\n\n\nCD14+ monocytes appear to correspond to clusters 1, and 3. We wouldn’t include clusters 14 and 10 because they do not highly express both of these markers.\nFCGR3A+ monocyte markers\n\nFeaturePlot(seurat_clustered, \n            reduction = \"umap\", \n            features = c(\"FCGR3A\", \"MS4A7\"), \n            order = TRUE,\n            min.cutoff = 'q10', \n            label = TRUE)\n\n\n\n\nFCGR3A+ monocytes markers distinctly highlight cluster 10, although we do see some decent expression in clusters 1 and 3. We would like to see additional markers for FCGR3A+ cells show up when we perform the marker identification.\nConventional dendritic cell markers\n\nFeaturePlot(seurat_clustered, \n            reduction = \"umap\", \n            features = c(\"FCER1A\", \"CST3\"), \n            order = TRUE,\n            min.cutoff = 'q10', \n            label = TRUE)\n\n\n\n\nThe markers corresponding to conventional dendritic cells identify cluster 14 (both markers consistently show expression).\nPlasmacytoid dendritic cell markers\n\nFeaturePlot(seurat_clustered, \n            reduction = \"umap\", \n            features = c(\"IL3RA\", \"GZMB\", \"SERPINF1\", \"ITM2C\"), \n            order = TRUE,\n            min.cutoff = 'q10', \n            label = TRUE)\n\n\n\n\nPlasmacytoid dendritic cells represent cluster 16. While there are a lot of differences in the expression of these markers, we see cluster 16 (though small) is consistently strongly expressed.\nMacrophages\n\nFeaturePlot(seurat_clustered, \n            reduction = \"umap\", \n            features = c(\"MARCO\", \"ITGAM\", \"ADGRE1\"), \n            order = TRUE,\n            min.cutoff = 'q10', \n            label = TRUE)\n\n\n\n\nWe don’t see much overlap of our markers, so no clusters appear to correspond to macrophages; perhaps cell culture conditions negatively selected for macrophages (more highly adherent).\nB cells\n\nFeaturePlot(seurat_clustered, \n            reduction = \"umap\", \n            features = c(\"CD79A\", \"MS4A1\"), \n            order = TRUE,\n            min.cutoff = 'q10', \n            label = TRUE)\n\n\n\n\n可以看出，cluster 11, 7, 13属于B细胞。\nT cells\n\nFeaturePlot(seurat_clustered, \n            reduction = \"umap\", \n            features = c(\"CD3D\"), \n            order = TRUE,\n            min.cutoff = 'q10', \n            label = TRUE)\n\n\n\n\nT细胞的标志物在大量的cluster中均表达，包括cluster 0, 2, 6, 4, 5, 9。\nCD4+ T cells\n\nFeaturePlot(seurat_clustered, \n            reduction = \"umap\", \n            features = c(\"CD3D\", \"IL7R\", \"CCR7\"), \n            order = TRUE,\n            min.cutoff = 'q10', \n            label = TRUE)\n\n\n\n\n大致看出cluster 4, 0, 6, 2属于CD4+ T 细胞。\nCD8+ T cells\n\nFeaturePlot(seurat_clustered, \n            reduction = \"umap\", \n            features = c(\"CD3D\", \"CD8A\"), \n            order = TRUE,\n            min.cutoff = 'q10', \n            label = TRUE)\n\n\n\n\ncluster 5和 cluster 9属于CD8+ T细胞。\nNK cells\n\nFeaturePlot(seurat_clustered, \n            reduction = \"umap\", \n            features = c(\"GNLY\", \"NKG7\"), \n            order = TRUE,\n            min.cutoff = 'q10', \n            label = TRUE)\n\n\n\n\ncluster 8, 12属于NK细胞。这和我们在前面的 Section 25.6 中的结论（第二主成分的top基因GNLY和NKG7在cluster 8和cluster 12中高表达）一致。\nMegakaryocytes（巨核细胞）\n\nFeaturePlot(seurat_clustered, \n            reduction = \"umap\", \n            features = c(\"PPBP\"), \n            order = TRUE,\n            min.cutoff = 'q10', \n            label = TRUE)\n\n\n\n\ncluster 15属于巨核细胞。\nErythrocytes（红细胞）\n\nFeaturePlot(seurat_clustered, \n            reduction = \"umap\", \n            features = c(\"HBB\", \"HBA2\"), \n            order = TRUE,\n            min.cutoff = 'q10', \n            label = TRUE)\n\n\n\n\n可以看到，红细胞的marker gene基本没有明显的表达。"
  },
  {
    "objectID": "single_cell/scRNA-seq_online/08_SC_clustering_quality_control.html#sec-Preliminary_cell_type_identification_results",
    "href": "single_cell/scRNA-seq_online/08_SC_clustering_quality_control.html#sec-Preliminary_cell_type_identification_results",
    "title": "25  细胞分群质量评估",
    "section": "\n25.8 细胞类型初步鉴定结果\n",
    "text": "25.8 细胞类型初步鉴定结果\n\n根据上面的marker表达情况，我们大致可以确定如下细胞类型鉴定结果:\n\n\nCell Type\nClusters\n\n\n\nCD14+ monocytes\n1, 3\n\n\nFCGR3A+ monocytes\n10\n\n\nConventional dendritic cells\n14\n\n\nPlasmacytoid dendritic cells\n16\n\n\nMarcrophages\n-\n\n\nB cells\n11, 7, 13\n\n\nT cells\n0, 2, 6, 4, 5, 9\n\n\nCD4+ T cells\n4, 0, 6, 2\n\n\nCD8+ T cells\n5, 9\n\n\nNK cells\n8, 12\n\n\nMegakaryocytes\n15\n\n\nErythrocytes\n-\n\n\nUnknown\n-\n\n\n\n\n\n\n\n\n\n\nImportant\n\n\n\nIf any cluster appears to contain two separate cell types, it’s helpful to increase our clustering resolution to properly subset the clusters. Alternatively, if we still can’t separate out the clusters using increased resolution, then it’s possible that we had used too few principal components such that we are just not separating out these cell types of interest. To inform our choice of PCs, we could look at our PC gene expression overlapping the UMAP plots and determine whether our cell populations are separating by the PCs included.\n\n\nNow we have a decent idea as to the cell types corresponding to the majority of the clusters, but some questions remain:\n\nT cell markers appear to be highly expressed in many clusters. How can we differentiate and subset the larger group into smaller subset of cells?\nDo the clusters corresponding to the same cell types have biologically meaningful differences? Are there subpopulations of these cell types?\nCan we acquire higher confidence in these cell type identities by identifying other marker genes for these clusters?\n\nMarker identification analysis can help us address all of these questions!!\nThe next step will be to perform marker identification analysis, which will output the genes that significantly differ in expression between clusters. Using these genes we can determine or improve confidence in the identities of the clusters/subclusters."
  },
  {
    "objectID": "single_cell/scRNA-seq_online/08_SC_clustering_quality_control.html#保存数据",
    "href": "single_cell/scRNA-seq_online/08_SC_clustering_quality_control.html#保存数据",
    "title": "25  细胞分群质量评估",
    "section": "\n25.9 保存数据",
    "text": "25.9 保存数据\n\nsaveRDS(seurat_clustered, file = \"output/scRNA-seq_online/seurat_clustered_qc.rds\")\n\n\n\n\n\n\n\n\nSession Info\n\n\n\n\n\n\n\nR version 4.3.2 (2023-10-31)\nPlatform: aarch64-apple-darwin20 (64-bit)\nRunning under: macOS Sonoma 14.2.1\n\nMatrix products: default\nBLAS:   /Library/Frameworks/R.framework/Versions/4.3-arm64/Resources/lib/libRblas.0.dylib \nLAPACK: /Library/Frameworks/R.framework/Versions/4.3-arm64/Resources/lib/libRlapack.dylib;  LAPACK version 3.11.0\n\nlocale:\n[1] en_US.UTF-8/en_US.UTF-8/en_US.UTF-8/C/en_US.UTF-8/en_US.UTF-8\n\ntime zone: Asia/Shanghai\ntzcode source: internal\n\nattached base packages:\n[1] stats     graphics  grDevices utils     datasets  methods   base     \n\nother attached packages:\n[1] cowplot_1.1.2      ggplot2_3.4.4      purrr_1.0.2        tidyr_1.3.0       \n[5] dplyr_1.1.4        Seurat_5.0.1       SeuratObject_5.0.1 sp_2.1-2          \n\nloaded via a namespace (and not attached):\n  [1] deldir_2.0-2           pbapply_1.7-2          gridExtra_2.3         \n  [4] rlang_1.1.2            magrittr_2.0.3         RcppAnnoy_0.0.21      \n  [7] spatstat.geom_3.2-7    matrixStats_1.2.0      ggridges_0.5.5        \n [10] compiler_4.3.2         png_0.1-8              vctrs_0.6.5           \n [13] reshape2_1.4.4         stringr_1.5.1          pkgconfig_2.0.3       \n [16] fastmap_1.1.1          ellipsis_0.3.2         labeling_0.4.3        \n [19] utf8_1.2.4             promises_1.2.1         rmarkdown_2.25        \n [22] xfun_0.41              jsonlite_1.8.8         goftest_1.2-3         \n [25] later_1.3.2            spatstat.utils_3.0-4   irlba_2.3.5.1         \n [28] parallel_4.3.2         cluster_2.1.6          R6_2.5.1              \n [31] ica_1.0-3              stringi_1.8.3          RColorBrewer_1.1-3    \n [34] spatstat.data_3.0-3    reticulate_1.34.0      parallelly_1.36.0     \n [37] lmtest_0.9-40          scattermore_1.2        Rcpp_1.0.11           \n [40] knitr_1.45             tensor_1.5             future.apply_1.11.0   \n [43] zoo_1.8-12             sctransform_0.4.1      httpuv_1.6.13         \n [46] Matrix_1.6-4           splines_4.3.2          igraph_1.6.0          \n [49] tidyselect_1.2.0       abind_1.4-5            rstudioapi_0.15.0     \n [52] yaml_2.3.8             spatstat.random_3.2-2  codetools_0.2-19      \n [55] miniUI_0.1.1.1         spatstat.explore_3.2-5 listenv_0.9.0         \n [58] lattice_0.22-5         tibble_3.2.1           plyr_1.8.9            \n [61] withr_2.5.2            shiny_1.8.0            ROCR_1.0-11           \n [64] evaluate_0.23          Rtsne_0.17             future_1.33.0         \n [67] fastDummies_1.7.3      survival_3.5-7         polyclip_1.10-6       \n [70] fitdistrplus_1.1-11    pillar_1.9.0           KernSmooth_2.23-22    \n [73] plotly_4.10.3          generics_0.1.3         RcppHNSW_0.5.0        \n [76] munsell_0.5.0          scales_1.3.0           globals_0.16.2        \n [79] xtable_1.8-4           glue_1.6.2             lazyeval_0.2.2        \n [82] tools_4.3.2            data.table_1.14.10     RSpectra_0.16-1       \n [85] RANN_2.6.1             leiden_0.4.3.1         dotCall64_1.1-1       \n [88] grid_4.3.2             colorspace_2.1-0       nlme_3.1-164          \n [91] patchwork_1.1.3        cli_3.6.2              spatstat.sparse_3.0-3 \n [94] spam_2.10-0            fansi_1.0.6            viridisLite_0.4.2     \n [97] uwot_0.1.16            gtable_0.3.4           digest_0.6.33         \n[100] progressr_0.14.0       ggrepel_0.9.4          farver_2.1.1          \n[103] htmlwidgets_1.6.4      htmltools_0.5.7        lifecycle_1.0.4       \n[106] httr_1.4.7             mime_0.12              MASS_7.3-60"
  },
  {
    "objectID": "single_cell/scRNA-seq_online/09_merged_SC_marker_identification.html#数据导入",
    "href": "single_cell/scRNA-seq_online/09_merged_SC_marker_identification.html#数据导入",
    "title": "\n26  寻找marker基因+细胞注释\n",
    "section": "\n26.1 数据导入",
    "text": "26.1 数据导入\n载入 Chapter 25 中完成细胞分群质量评估的数据seurat_clustered_qc。\n\nlibrary(Seurat)\nseurat_clustered_qc &lt;- readRDS(\"output/scRNA-seq_online/seurat_clustered_qc.rds\")\nseurat_clustered_qc\n\nAn object of class Seurat \n31130 features across 29629 samples within 3 assays \nActive assay: RNA (14065 features, 0 variable features)\n 2 layers present: counts, data\n 2 other assays present: SCT, integrated\n 2 dimensional reductions calculated: pca, umap\n\nhead(seurat_clustered_qc, 3)\n\n                      orig.ident nCount_RNA nFeature_RNA\nctrl_AAACATACAATGCC-1       ctrl       2344          874\nctrl_AAACATACATTTCC-1       ctrl       3124          895\nctrl_AAACATACCAGAAA-1       ctrl       2578          725\n                                      seq_folder nUMI nGene log10GenesPerUMI\nctrl_AAACATACAATGCC-1 ctrl_raw_feature_bc_matrix 2344   874        0.8728630\nctrl_AAACATACATTTCC-1 ctrl_raw_feature_bc_matrix 3125   896        0.8447596\nctrl_AAACATACCAGAAA-1 ctrl_raw_feature_bc_matrix 2578   725        0.8384933\n                       mitoRatio                 cells sample     S.Score\nctrl_AAACATACAATGCC-1 0.01962457 ctrl_AAACATACAATGCC-1   ctrl  0.04330502\nctrl_AAACATACATTTCC-1 0.01792000 ctrl_AAACATACATTTCC-1   ctrl  0.02661900\nctrl_AAACATACCAGAAA-1 0.01551590 ctrl_AAACATACCAGAAA-1   ctrl -0.04670650\n                        G2M.Score Phase mitoFr nCount_SCT nFeature_SCT\nctrl_AAACATACAATGCC-1  0.05422631   G2M Medium       1572          829\nctrl_AAACATACATTTCC-1  0.05159679   G2M Medium       1572          718\nctrl_AAACATACCAGAAA-1 -0.04841661    G1 Medium       1553          648\n                      integrated_snn_res.0.4 integrated_snn_res.0.6\nctrl_AAACATACAATGCC-1                      2                      1\nctrl_AAACATACATTTCC-1                      0                      2\nctrl_AAACATACCAGAAA-1                      0                      3\n                      integrated_snn_res.0.8 integrated_snn_res.1\nctrl_AAACATACAATGCC-1                      2                    2\nctrl_AAACATACATTTCC-1                      1                    0\nctrl_AAACATACCAGAAA-1                      3                   15\n                      integrated_snn_res.1.4 seurat_clusters\nctrl_AAACATACAATGCC-1                      5               5\nctrl_AAACATACATTTCC-1                      0               0\nctrl_AAACATACCAGAAA-1                     19              19\n\n\nBefore we start our marker identification we will explicitly set our default assay, we want to use the normalized data, but not the integrated data.\n\nDefaultAssay(seurat_clustered_qc) &lt;- \"RNA\"\n\n\n\n\n\n\n\nImportant\n\n\n\n原教程将默认的assay设置为了”RNA”，其解释如下：The default assay should have already been RNA, because we set it up in the previous clustering quality control lesson ( Section 25.7 ). But we encourage you to run this line of code above to be absolutely sure in case the active slot was changed somewhere upstream in your analysis. Note that the raw and normalized counts are stored in the counts and data slots of RNA assay. By default, the functions for finding markers will use normalized data. （关于FindMarkers为什么要使用”RNA” assay的更多解释，参阅此链接）\n而在Seurat V5的官方教程中（ Section 13.2 ），对于经过SCTransform归一化处理后的单细胞数据，在进行FindMarkers差异分析之前，需要先运行seurat_clustered_qc &lt;- PrepSCTFindMarkers(seurat_clustered_qc)，来预处理SCT assay。详细解释见此链接。\n如果是基于NormalizeData标准化的单细胞数据，和这里一样，需要使用”RNA” assay进行差异分析，如果不是，需要通过DefaultAssay(seurat_clustered_qc) &lt;- \"RNA\"进行设定。\n这里为了和原教程保持一致，默认的将assay设置为”RNA”。\n\n\nOur clustering analysis resulted in the following clusters:\n\nDimPlot(seurat_clustered_qc, label = TRUE)\n\n\n\n\nRemember that we had the following questions from the clustering analysis（ Section 25.8 ）:\n\n\nDo the clusters corresponding to the same cell types have biologically meaningful differences? Are there subpopulations of these cell types?\nCan we acquire higher confidence in these cell type identities by identifying other marker genes for these clusters?\n\n\nThere are a few different types of marker identification that we can explore using Seurat to get to the answer of these questions. Each with their own benefits and drawbacks:\n\n\nIdentification of all markers for each cluster\nThis analysis compares each cluster against all others and outputs the genes that are differentially expressed/present.\n\nUseful for identifying unknown clusters and improving confidence in hypothesized cell types.\n\n\n\nIdentification of conserved markers for each cluster\nThis analysis looks for genes that are differentially expressed/present within each condition first, and then reports those genes that are conserved in the cluster across all conditions. These genes can help to figure out the identity for the cluster.\n\nUseful with more than one condition to identify cell type markers that are conserved across conditions.\n\n\n\nMarker identification between specific clusters\nThis analysis explores differentially expressed genes between specific clusters.\n\nUseful for determining differences in gene expression between clusters that appear to be representing the same celltype (i.e with markers that are similar) from the above analyses."
  },
  {
    "objectID": "single_cell/scRNA-seq_online/09_merged_SC_marker_identification.html#findallmarkers-identification-of-all-markers-for-each-cluster",
    "href": "single_cell/scRNA-seq_online/09_merged_SC_marker_identification.html#findallmarkers-identification-of-all-markers-for-each-cluster",
    "title": "\n26  寻找marker基因+细胞注释\n",
    "section": "\n26.2 FindAllMarkers-Identification of all markers for each cluster",
    "text": "26.2 FindAllMarkers-Identification of all markers for each cluster\nThis type of analysis is typically recommended for when evaluating a single sample group/condition. With the FindAllMarkers() function we are comparing each cluster against all other clusters to identify potential marker genes. The cells in each cluster are treated as replicates, and essentially a differential expression analysis is performed with some statistical test.\n\n\n\n\n\n\nTip\n\n\n\nThe default is a Wilcoxon Rank Sum test, but there are other options available.\n\n\n\nThe FindAllMarkers() function has three important arguments which provide thresholds for determining whether a gene is a marker:\n\n\nlogfc.threshold: minimum log2 fold change for average expression of gene in cluster relative to the average expression in all other clusters combined. Default is 0.25.\n\n\nCons:\n\ncould miss those cell markers that are expressed in a small fraction of cells within the cluster of interest, but not in the other clusters, if the average logfc doesn’t meet the threshold\ncould return a lot of metabolic/ribosomal genes due to slight differences in metabolic output by different cell types, which are not as useful to distinguish cell type identities\n\n\n\n\n\nmin.diff.pct: minimum percent difference between the percent of cells expressing the gene in the cluster and the percent of cells expressing gene in all other clusters combined.\n\n\nCons: could miss those cell markers that are expressed in all cells, but are highly up-regulated in this specific cell type\n\n\n\nmin.pct: only test genes that are detected in a minimum fraction of cells in either of the two populations. Meant to speed up the function by not testing genes that are very infrequently expressed. Default is 0.1.\n\n\nCons: if set to a very high value could incur many false negatives due to the fact that not all genes are detected in all cells (even if it is expressed)\n\n\n\nYou could use any combination of these arguments depending on how stringent/lenient you want to be. Also, by default this function will return to you genes that exhibit both positive and negative expression changes. Typically, we add an argument only.pos to opt for keeping only the positive changes. The code to find markers for each cluster is shown below.\n\n\n\n\n\n\nImportant\n\n\n\nIn Seurat v5, we use the presto package (as described here and available for installation here), to dramatically improve the speed of DE analysis, particularly for large datasets ( Section 13.2 ). 因此，需要先安装presto包：\n\n```{r}\n#| eval: false\n# install.packages(\"devtools\")\ndevtools::install_github(\"immunogenomics/presto\")\n```\n\n\n\n\n# Find markers for every cluster compared to all remaining cells, report only the positive ones\nmarkers &lt;- FindAllMarkers(object = seurat_clustered_qc, \n                          only.pos = TRUE,\n                          logfc.threshold = 0.25) \nhead(markers)\n\n       p_val avg_log2FC pct.1 pct.2 p_val_adj cluster   gene\nCCR7       0   1.494342 0.885 0.399         0       0   CCR7\nSELL       0   1.847509 0.726 0.277         0       0   SELL\nGIMAP7     0   1.482245 0.872 0.443         0       0 GIMAP7\nLTB        0   1.561875 0.735 0.311         0       0    LTB\nLDHB       0   1.569828 0.733 0.330         0       0   LDHB\nTRAC       0   1.285588 0.746 0.356         0       0   TRAC\n\ntail(markers)\n\n               p_val avg_log2FC pct.1 pct.2 p_val_adj cluster    gene\nDNAJC213 0.009747737  0.5018165 0.056 0.022         1      16 DNAJC21\nPOGK     0.009763789  1.4868037 0.032 0.010         1      16    POGK\nZNF5443  0.009781767  0.6873261 0.024 0.006         1      16  ZNF544\nMRPS313  0.009912914  0.4306063 0.105 0.051         1      16  MRPS31\nUCKL11   0.009958018  0.5284076 0.040 0.013         1      16   UCKL1\nQTRT22   0.009998863  0.3087035 0.056 0.022         1      16   QTRT2\n\n\nThe results data frame has the following columns :\n\np_val : p-value (unadjusted)\navg_log2FC : log fold-change of the average expression between the two groups. Positive values indicate that the feature is more highly expressed in the first group.\npct.1 : The percentage of cells where the feature is detected in the first group\npct.2 : The percentage of cells where the feature is detected in the second group\np_val_adj : Adjusted p-value, based on Bonferroni correction using all features in the dataset.\n\n获取每个cluster的前10个marker基因 ( 详细解释见下面的 Section 26.3.2.1 ):\n\nlibrary(dplyr)\n# 获取每个cluster的前10个marker基因\ntop_markers &lt;- markers |&gt;\n  group_by(cluster) |&gt; \n  slice_max(n = 10, order_by = avg_log2FC)"
  },
  {
    "objectID": "single_cell/scRNA-seq_online/09_merged_SC_marker_identification.html#findconservedmarkers-identification-of-conserved-markers-in-all-conditions",
    "href": "single_cell/scRNA-seq_online/09_merged_SC_marker_identification.html#findconservedmarkers-identification-of-conserved-markers-in-all-conditions",
    "title": "\n26  寻找marker基因+细胞注释\n",
    "section": "\n26.3 FindConservedMarkers-Identification of conserved markers in all conditions",
    "text": "26.3 FindConservedMarkers-Identification of conserved markers in all conditions\nSince we have samples representing different conditions in our dataset, our best option is to find conserved markers. This function internally separates out cells by sample group/condition, and then performs differential gene expression testing for a single specified cluster against all other clusters (or a second cluster, if specified). Gene-level p-values are computed for each condition and then combined across groups using meta-analysis methods from the MetaDE R package.\n\n寻找cluster 0和cluster 10的conserved markers\n我们首先通过寻找cluster 0和cluster 10的conserved markers来初步学习FindConservedMarkers函数的用法。\nfor FindConservedMarkers, you will recognize some of the arguments we described previously for the FindAllMarkers() function; this is because internally it is using that function to first find markers within each group. Here, we list some additional arguments which provide for when using FindConservedMarkers():\n\n\nident.1: this function only evaluates one cluster at a time; here you would specify the cluster of interest.\n\ngrouping.var: the variable (column header) in your metadata which specifies the separation of cells into groups\n\nFindConservedMarkers函数会调用metap包，metap包需要multtest包，所以需要先安装这两个依赖包：\n\nBiocManager::install('multtest')\ninstall.packages('metap')\n\n寻找cluster 0的conserved markers\nFor our analysis we will be fairly lenient and use only the log fold change threshold greater than 0.25. We will also specify to return only the positive markers for each cluster.\nLet’s test it out on cluster 0 to see how it works:\n\ncluster0_conserved_markers &lt;- FindConservedMarkers(seurat_clustered_qc,\n                                                   ident.1 = 0,\n                                                   grouping.var = \"sample\",\n                                                   only.pos = TRUE,\n                                                   logfc.threshold = 0.25)\nhead(cluster0_conserved_markers)\n\n       stim_p_val stim_avg_log2FC stim_pct.1 stim_pct.2 stim_p_val_adj\nCCR7            0        1.481347      0.927      0.430              0\nSELL            0        1.724888      0.832      0.370              0\nLDHB            0        1.720061      0.732      0.304              0\nGIMAP7          0        1.463588      0.934      0.507              0\nLTB             0        1.538317      0.702      0.295              0\nRPL10A          0        1.216299      0.966      0.664              0\n          ctrl_p_val ctrl_avg_log2FC ctrl_pct.1 ctrl_pct.2 ctrl_p_val_adj\nCCR7    0.000000e+00       1.4694462      0.839      0.368   0.000000e+00\nSELL    0.000000e+00       2.0273581      0.610      0.186   0.000000e+00\nLDHB   2.056415e-293       1.4530062      0.734      0.356  2.892347e-289\nGIMAP7  0.000000e+00       1.4612133      0.804      0.380   0.000000e+00\nLTB     0.000000e+00       1.5963402      0.770      0.327   0.000000e+00\nRPL10A  0.000000e+00       0.9640366      0.969      0.809   0.000000e+00\n            max_pval minimump_p_val\nCCR7    0.000000e+00              0\nSELL    0.000000e+00              0\nLDHB   2.056415e-293              0\nGIMAP7  0.000000e+00              0\nLTB     0.000000e+00              0\nRPL10A  0.000000e+00              0\n\n\nThe output from the FindConservedMarkers function, is a matrix containing a ranked list of putative markers listed by gene ID for the cluster we specified, and associated statistics. Note that the same set of statistics are computed for each group (in our case, Ctrl and Stim) and the last two columns (max_pval和minimump_p_val) correspond to the combined p-value across the two groups. We describe some of these columns below:\n\n\ngene: gene symbol\n\ncondition_p_val(即本例中的“stim_p_val”和“ctrl_p_val”列，后面同理): p-value not adjusted for multiple test correction for condition\n\ncondition_avg_log2FC: average log fold change for condition. Positive values indicate that the gene is more highly expressed in the cluster.\n\ncondition_pct.1: percentage of cells where the gene is detected in the cluster for condition\n\ncondition_pct.2: percentage of cells where the gene is detected on average in the other clusters for condition\n\ncondition_p_val_adj: adjusted p-value for condition, based on bonferroni correction using all genes in the dataset, used to determine significance\n\nmax_pval: largest p value of p value calculated by each group/condition\n\nminimump_p_val: combined p value\n\n\n\n\n\n\n\nTip\n\n\n\nThe condition_p_val, condition_avg_log2FC, condition_pct.1, condition_pct.2, and condition_p_val_adj mean the same thing as they do in FindMarkers, just restricted to only the cells present in group X. The max_pval is the maximum p-value across all groups. The mimimump_p_val represents one way of doing a meta-analysis of significance values (combining p-values across different tests).\n(来自：https://github.com/satijalab/seurat/issues/1164)\n\n\n\n\n\n\n\n\nWarning\n\n\n\nSince each cell is being treated as a replicate this will result in inflated p-values within each group! A gene may have an incredibly low p-value &lt; 1e-50 but that doesn’t translate as a highly reliable marker gene.\n\n\nWhen looking at the output, we suggest looking for markers with large differences in expression between pct.1 and pct.2 and larger fold changes. For instance if pct.1 = 0.90 and pct.2 = 0.80, it may not be as exciting of a marker. However, if pct.2 = 0.1 instead, the bigger difference would be more convincing. Also, of interest is if the majority of cells expressing the marker is in my cluster of interest. If pct.1 is low, such as 0.3, it may not be as interesting. Both of these are also possible parameters to include when running the function, as described above.\n添加基因注释信息\nIt can be helpful to add columns with gene annotation information. In order to do that we will load in an annotation file located in your data folder, using the code provided below:\n\nannotations &lt;- readRDS(\"data/scRNA-seq_online/annotations.rds\")\nhead(annotations, 3)\n\n          gene_id gene_name seq_name                       gene_biotype\n1 ENSG00000290825   DDX11L2        1                             lncRNA\n6 ENSG00000223972   DDX11L1        1 transcribed_unprocessed_pseudogene\n7 ENSG00000227232    WASH7P        1             unprocessed_pseudogene\n                                                                                    description\n1 DEAD/H-box helicase 11 like 2 (pseudogene) [Source:NCBI gene (formerly Entrezgene);Acc:84771]\n6                DEAD/H-box helicase 11 like 1 (pseudogene) [Source:HGNC Symbol;Acc:HGNC:37102]\n7                         WASP family homolog 7, pseudogene [Source:HGNC Symbol;Acc:HGNC:38034]\n\n\n该数据的”description”列即对基因的注释，下面我们把这一列通过匹配基因名将其添加到cluster0_conserved_markers数据框中。\n\n\n\n\n\n\n获取基因注释信息的方法\n\n\n\n\n\n首先从BiocManager安装AnnotationHub包和ensembldb包：\n\nBiocManager::install(\"AnnotationHub\")\nBiocManager::install(\"ensembldb\")\n\n从AnnotationHub下载并提取所需的注释信息数据库:\n\n# 从AnnotationHub下载注释信息数据库\nlibrary(AnnotationHub)\nah &lt;- AnnotationHub()\nah\n\nAnnotationHub with 70762 records\n# snapshotDate(): 2023-10-20\n# $dataprovider: Ensembl, BroadInstitute, UCSC, ftp://ftp.ncbi.nlm.nih.gov/g...\n# $species: Homo sapiens, Mus musculus, Drosophila melanogaster, Bos taurus,...\n# $rdataclass: GRanges, TwoBitFile, BigWigFile, EnsDb, Rle, OrgDb, SQLiteFil...\n# additional mcols(): taxonomyid, genome, description,\n#   coordinate_1_based, maintainer, rdatadateadded, preparerclass, tags,\n#   rdatapath, sourceurl, sourcetype \n# retrieve records with, e.g., 'object[[\"AH5012\"]]' \n\n             title                              \n  AH5012   | Chromosome Band                    \n  AH5013   | STS Markers                        \n  AH5014   | FISH Clones                        \n  AH5015   | Recomb Rate                        \n  AH5016   | ENCODE Pilot                       \n  ...        ...                                \n  AH116159 | org.Aegialitis_vocifera.eg.sqlite  \n  AH116160 | org.Charadrius_vociferous.eg.sqlite\n  AH116161 | org.Charadrius_vociferus.eg.sqlite \n  AH116162 | org.Oxyechus_vociferus.eg.sqlite   \n  AH116163 | org.Drosophila_erecta.eg.sqlite    \n\nhead(unique(ah$species))\n\n[1] \"Homo sapiens\"         \"Vicugna pacos\"        \"Dasypus novemcinctus\"\n[4] \"Otolemur garnettii\"   \"Papio hamadryas\"      \"Papio anubis\"     \n\n# Access the Ensembl database for organism\nahDb &lt;- query(ah, \n              pattern = c(\"Homo sapiens\", \"EnsDb\"), \n              ignore.case = TRUE)\nahDb\n\nAnnotationHub with 25 records\n# snapshotDate(): 2023-10-20\n# $dataprovider: Ensembl\n# $species: Homo sapiens\n# $rdataclass: EnsDb\n# additional mcols(): taxonomyid, genome, description,\n#   coordinate_1_based, maintainer, rdatadateadded, preparerclass, tags,\n#   rdatapath, sourceurl, sourcetype \n# retrieve records with, e.g., 'object[[\"AH53211\"]]' \n\n             title                             \n  AH53211  | Ensembl 87 EnsDb for Homo Sapiens \n  AH53715  | Ensembl 88 EnsDb for Homo Sapiens \n  AH56681  | Ensembl 89 EnsDb for Homo Sapiens \n  AH57757  | Ensembl 90 EnsDb for Homo Sapiens \n  AH60773  | Ensembl 91 EnsDb for Homo Sapiens \n  ...        ...                               \n  AH100643 | Ensembl 106 EnsDb for Homo sapiens\n  AH104864 | Ensembl 107 EnsDb for Homo sapiens\n  AH109336 | Ensembl 108 EnsDb for Homo sapiens\n  AH109606 | Ensembl 109 EnsDb for Homo sapiens\n  AH113665 | Ensembl 110 EnsDb for Homo sapiens\n\n# Acquire the latest annotation files\nid &lt;- ahDb |&gt;\n  mcols() |&gt;\n  rownames() |&gt;\n  tail(n = 1)\nid\n\n[1] \"AH113665\"\n\n# Download the appropriate Ensembldb database\n# 需要开启全局代理\nedb &lt;- ah[[id]]\nedb\n\nEnsDb for Ensembl:\n|Backend: SQLite\n|Db type: EnsDb\n|Type of Gene ID: Ensembl Gene ID\n|Supporting package: ensembldb\n|Db created by: ensembldb package from Bioconductor\n|script_version: 0.3.10\n|Creation time: Mon Aug  7 09:02:07 2023\n|ensembl_version: 110\n|ensembl_host: 127.0.0.1\n|Organism: Homo sapiens\n|taxonomy_id: 9606\n|genome_build: GRCh38\n|DBSCHEMAVERSION: 2.2\n|common_name: human\n|species: homo_sapiens\n| No. of genes: 71440.\n| No. of transcripts: 278545.\n|Protein data available.\n提取并保存注释信息：\n\n# Extract gene-level information from database\nannotations &lt;- genes(edb, return.type = \"data.frame\")\ncolnames(annotations)\n\n[1] \"gene_id\"              \"gene_name\"            \"gene_biotype\"        \n[4] \"gene_seq_start\"       \"gene_seq_end\"         \"seq_name\"            \n[7] \"seq_strand\"           \"seq_coord_system\"     \"description\"         \n[10] \"gene_id_version\"      \"canonical_transcript\" \"symbol\"              \n[13] \"entrezid\"   \n\n# Select annotations of interest\nlibrary(dplyr)\nannotations &lt;- annotations |&gt;\n  select(gene_id, gene_name, seq_name, gene_biotype, description)\n\n保存到本地:\n\nsaveRDS(annotations, file = \"data/scRNA-seq_online/annotations.rds\")\n\n\n\n\nFirst, we will turn the row names with gene identifiers into its own columns. Then we will merge this annotation file with our results from the FindConservedMarkers():\n\n首先通过tibble包的rownames_to_column函数将“cluster0_conserved_markers”数据框的行名（基因symbol）转换成新的一列“gene”\n然后，通过dplyr包的left_join函数合并“cluster0_conserved_markers”数据（x）和“annotations”数据框的 “description”列（y）。通过匹配“cluster0_conserved_markers”数据中的“gene”列（上一步生成）和“annotations”数据的“gene_name”列来进行合并。同时，left_join会保留x（这里即上一步添加了“gene列”的“cluster0_conserved_markers”数据框）中的所有值；而删除y（“annotations”数据框）中用于匹配的那一列（即“gene_name”）\n\n\n# Combine markers with gene descriptions \nlibrary(tibble) # 调用rownames_to_column函数\nlibrary(dplyr) # 调用left_join函数\ncluster0_ann_markers &lt;- cluster0_conserved_markers |&gt;\n  rownames_to_column(var = \"gene\") |&gt; \n  # left_join保留x中的所有观测\n  left_join(y = unique(annotations[, c(\"gene_name\", \"description\")]),\n            by = c(\"gene\" = \"gene_name\"))\nhead(cluster0_ann_markers, 3)\n\n  gene stim_p_val stim_avg_log2FC stim_pct.1 stim_pct.2 stim_p_val_adj\n1 CCR7          0        1.481347      0.927      0.430              0\n2 SELL          0        1.724888      0.832      0.370              0\n3 LDHB          0        1.720061      0.732      0.304              0\n     ctrl_p_val ctrl_avg_log2FC ctrl_pct.1 ctrl_pct.2 ctrl_p_val_adj\n1  0.000000e+00        1.469446      0.839      0.368   0.000000e+00\n2  0.000000e+00        2.027358      0.610      0.186   0.000000e+00\n3 2.056415e-293        1.453006      0.734      0.356  2.892347e-289\n       max_pval minimump_p_val\n1  0.000000e+00              0\n2  0.000000e+00              0\n3 2.056415e-293              0\n                                                        description\n1 C-C motif chemokine receptor 7 [Source:HGNC Symbol;Acc:HGNC:1608]\n2                    selectin L [Source:HGNC Symbol;Acc:HGNC:10720]\n3        lactate dehydrogenase B [Source:HGNC Symbol;Acc:HGNC:6541]\n\n\n寻找cluster 10的conserved markers\nIn the previous lesson ( Section 25.7.2 ), we identified cluster 10 as FCGR3A+ monocytes by inspecting the expression of known cell markers FCGR3A and MS4A7.\n\nFeaturePlot(seurat_clustered_qc, \n            reduction = \"umap\", \n            features = c(\"FCGR3A\", \"MS4A7\"), \n            order = TRUE,\n            min.cutoff = 'q10', \n            label = TRUE)\n\n\n\n\nNow, we use FindConservedMarkers() function to find conserved markers for cluster 10.\n\ncluster10_conserved_markers &lt;- FindConservedMarkers(seurat_clustered_qc,\n                                                    ident.1 = 10,\n                                                    grouping.var = \"sample\",\n                                                    only.pos = TRUE,\n                                                    logfc.threshold = 0.25)\n\ncluster10_ann_markers &lt;- cluster10_conserved_markers |&gt; \n  rownames_to_column(var=\"gene\") |&gt; \n  left_join(y = unique(annotations[, c(\"gene_name\", \"description\")]),\n            by = c(\"gene\" = \"gene_name\"))\nhead(cluster10_ann_markers)\n\n    gene stim_p_val stim_avg_log2FC stim_pct.1 stim_pct.2 stim_p_val_adj\n1 FCGR3A          0        5.208580      0.988      0.101              0\n2 MS4A4A          0        5.106558      0.893      0.051              0\n3  MS4A7          0        4.313442      0.995      0.159              0\n4 CXCL16          0        4.097853      0.924      0.108              0\n5   VMO1          0        7.808405      0.758      0.016              0\n6   LST1          0        3.195206      0.873      0.148              0\n  ctrl_p_val ctrl_avg_log2FC ctrl_pct.1 ctrl_pct.2 ctrl_p_val_adj max_pval\n1          0        4.391965      0.980      0.141              0        0\n2          0        5.623548      0.577      0.016              0        0\n3          0        4.307014      0.962      0.122              0        0\n4          0        3.467690      0.945      0.148              0        0\n5          0        6.478637      0.850      0.039              0        0\n6          0        3.288439      0.932      0.165              0        0\n  minimump_p_val\n1              0\n2              0\n3              0\n4              0\n5              0\n6              0\n                                                                   description\n1                    Fc gamma receptor IIIa [Source:HGNC Symbol;Acc:HGNC:3619]\n2          membrane spanning 4-domains A4A [Source:HGNC Symbol;Acc:HGNC:13371]\n3           membrane spanning 4-domains A7 [Source:HGNC Symbol;Acc:HGNC:13378]\n4          C-X-C motif chemokine ligand 16 [Source:HGNC Symbol;Acc:HGNC:16642]\n5 vitelline membrane outer layer 1 homolog [Source:HGNC Symbol;Acc:HGNC:30387]\n6          leukocyte specific transcript 1 [Source:HGNC Symbol;Acc:HGNC:14189]\n\n\n\n可以发现cluster10的FCGR3A和MS4A7的表达比例显著高于其他cluster。符合此前的判断。\n\n批量寻找多个clusters的conserved markers\nThe function FindConservedMarkers() accepts a single cluster at a time, and we could run this function as many times as we have clusters. However, this is not very efficient. Instead we will first create a function to find the conserved markers including all the parameters we want to include. We will also add a few lines of code to modify the output. Our function will:\n\nRun the FindConservedMarkers() function\nTransfer row names to a column using rownames_to_column() function\nMerge in annotations\nCreate the column of cluster IDs using the cbind() function\n\n\n# Create function to get conserved markers for any given cluster\nget_conserved &lt;- function(cluster) {\n  FindConservedMarkers(seurat_clustered_qc,\n                       ident.1 = cluster,\n                       grouping.var = \"sample\",\n                       only.pos = TRUE) %&gt;%\n    rownames_to_column(var = \"gene\") %&gt;%\n    left_join(y = unique(annotations[, c(\"gene_name\", \"description\")]),\n               by = c(\"gene\" = \"gene_name\")) %&gt;%\n    cbind(cluster_id = cluster, .)\n  }\n\nNow that we have this function created we can use it as an argument to the appropriate map function. We want the output of the map family of functions to be a dataframe with each cluster output bound together by rows. （map函数输出的为一个list，通过list_rbind函数按照行组合列表中的每一个对象，并输出为数据框）\nNow, let’s try this function to find the conserved markers for the clusters that were identified as CD4+ T cells (4, 0, 6, 2) from our use of known marker genes ( Section 25.7.8 ).\n\nFeaturePlot(seurat_clustered_qc, \n            reduction = \"umap\", \n            features = c(\"CD3D\", \"IL7R\", \"CCR7\"), \n            order = TRUE,\n            min.cutoff = 'q10', \n            label = TRUE)\n\n\n\n\nLet’s see what genes we identify and of there are overlaps or obvious differences that can help us tease this apart a bit more.\n\nlibrary(purrr)\nconserved_markers &lt;- map(c(4, 0, 6, 2), get_conserved) |&gt; list_rbind()\n\n\n\n\n\n\n\nFinding markers for all clusters\n\n\n\nFor your data, you may want to run this function on all clusters, in which case you could input 0:20 instead of c(4,0,6,2). Also, it is possible that when you run this function on all clusters, in some cases you will have clusters that do not have enough cells for a particular group - and your function will fail. For these clusters you will need to use FindAllMarkers().\n\n\n获取top marker基因\nWe would like to use these gene lists to see of we can identify which celltypes these clusters identify with. Let’s take a look at the top genes for each of the clusters and see if that gives us any hints. We can view the top 10 markers by average fold change across the two groups, for each cluster for a quick perusal:\n\n首先通过dplyr包的mutate函数计算新的变量“avg_fc”，计算依据为：avg_fc = (ctrl_avg_log2FC + stim_avg_log2FC) /2\n然后通过dplyr包的group_by函数以“cluster_id”列为依据进行分组计算\n最后，通过dplyr包的slice_max函数取“avg_fc”（order_by = avg_fc）最大的前10行数据（n = 10）。由于group_by定义了分组计算，所以会输出每个cluster的前10个marker基因\n\n\n# 获取每个cluster的前10个marker基因\ntop_conserved_markers &lt;- conserved_markers %&gt;% \n  mutate(avg_fc = (ctrl_avg_log2FC + stim_avg_log2FC) /2) %&gt;% \n  group_by(cluster_id) %&gt;% \n  slice_max(n = 10, order_by = avg_fc)\n\n\n\n\n\n\n\n待解决的问题\n\n\n\n这里基于Seurat V5的运行结果和原教程的top markers结果不一致。原教程的top_conserved_markers如下：\n\n可能的原因：\n\n“In addition, in Seurat v5 we implement a pseudocount (when calculating log-FC) at the group level instead of the cell level. As a result, users will observe higher logFC estimates in v5 - but should note that these estimates may be more unstable - particularly for genes that are very lowly expressed in one of the two groups” （ Section 1 ）\n\n这一小节的后续内容暂时以原教程的marker基因结果为准。\n\n\n根据top marker基因重新评估细胞群的注释结果\nWhen we look at the entire list, we see clusters 0 and 6 have some overlapping genes, like CCR7 and SELL which correspond to markers of memory T cells.\nIt is possible that these two clusters are more similar to one another and could be merged together as naive T cells. On the other hand, with cluster 2 we observe CREM as one of our top genes; a marker gene of activation. This suggests that perhaps cluster 2 represents activated T cells.\n\n\nCell State\nMarker\n\n\n\nNaive T cells\nCCR7, SELL\n\n\nActivated T cells\nCREM, CD69\n\n\n\nFor cluster 4, we see a lot of heat shock and DNA damage genes appear in the top gene list. Based on these markers, it is likely that these are stressed or dying cells. However, if we explore the quality metrics for these cells in more detail (i.e. mitoRatio and nUMI overlayed on the cluster) we don’t really support for this argument：\n\n# Visualize the distribution of mitochondrial gene expression detected per cell\n# cluster 4中每个细胞检测到的线粒体基因表达分布情况\nlibrary(ggplot2)\nseurat_clustered_qc %&gt;% \n  subset(idents = 4) %&gt;% \n  .@meta.data %&gt;% \n  ggplot(aes(color = sample, x = mitoRatio, fill = sample)) + \n  geom_density(alpha = 0.2) + \n  scale_x_log10() + \n  theme_classic() +\n  geom_vline(xintercept = 0.2)\n\n\n\n\n\nThere is a breadth of research supporting the association of heat shock proteins with reactive T cells in the induction of anti‐inflammatory cytokines in chronic inflammation. This is a cluster for which we would need a deeper understanding of immune cells to really tease apart the results and make a final conclusion.\n\nTo get a better idea of cell type identity for cluster 4 we can explore the expression of different identified markers by cluster using the FeaturePlot() function.\n\n# Plot interesting marker gene expression for cluster 4\nFeaturePlot(seurat_clustered_qc, \n            features = c(\"HSPH1\", \"HSPE1\", \"DNAJB1\"),\n            order = TRUE,\n            min.cutoff = 'q10', \n            label = TRUE,\n            repel = TRUE)\n\n\n\n# 提取cluster 4，并单独查看interesting marker gene在其中的表达情况\nsubset(seurat_clustered_qc, idents = 4) %&gt;% \n  FeaturePlot(\n            features = c(\"HSPH1\", \"HSPE1\", \"DNAJB1\"),\n            order = TRUE,\n            min.cutoff = 'q10', \n            label = TRUE,\n            repel = TRUE)\n\n\n\n\n\nWe see that only a subset of cluster 4 are highly expressing these genes.\n\nWe can also explore the range in expression of specific markers by using violin plots:\n\n# Vln plot - cluster 4\nVlnPlot(seurat_clustered_qc, \n        features = c(\"HSPH1\", \"HSPE1\", \"DNAJB1\"))\n\n\n\n\n\n\n\n\n\n\nViolin plots\n\n\n\n\n\nViolin plots are similar to box plots, except that they also show the probability density of the data at different values, usually smoothed by a kernel density estimator. A violin plot is more informative than a plain box plot. While a box plot only shows summary statistics such as mean/median and interquartile ranges, the violin plot shows the full distribution of the data. The difference is particularly useful when the data distribution is multimodal (more than one peak). In this case a violin plot shows the presence of different peaks, their position and relative amplitude."
  },
  {
    "objectID": "single_cell/scRNA-seq_online/09_merged_SC_marker_identification.html#findmarkers-marker-identification-between-specific-clusters",
    "href": "single_cell/scRNA-seq_online/09_merged_SC_marker_identification.html#findmarkers-marker-identification-between-specific-clusters",
    "title": "\n26  寻找marker基因+细胞注释\n",
    "section": "\n26.4 FindMarkers-Marker identification between specific clusters\n",
    "text": "26.4 FindMarkers-Marker identification between specific clusters\n\nSometimes the list of markers returned don’t sufficiently separate some of the clusters. For instance, we had previously identified clusters 0, 4, 6 and 2 as CD4+ T cells, but when looking at marker gene lists we identfied markers to help us further subset cells. We were lucky and the signal observed from FindAllMarkers() helped us differentiate between naive and activated cells.\nAnother option to identify biologically meaningful differences would be to use the FindMarkers() function to determine the genes that are differentially expressed between two specific clusters.\n\nWe can try all combinations of comparisons, but we’ll start with cluster 2 versus all other CD4+ T cell clusters:\n\n# Determine differentiating markers for CD4+ T cell\ncd4_tcells &lt;- FindMarkers(seurat_clustered_qc,\n                          ident.1 = 2,\n                          ident.2 = c(0, 4, 6))  \n\n# Add gene symbols to the DE table\ncd4_tcells &lt;- cd4_tcells %&gt;%\n  rownames_to_column(var = \"gene\") %&gt;%\n  left_join(y = unique(annotations[, c(\"gene_name\", \"description\")]),\n            by = c(\"gene\" = \"gene_name\"))\ncolnames(cd4_tcells)\n\n[1] \"gene\"        \"p_val\"       \"avg_log2FC\"  \"pct.1\"       \"pct.2\"      \n[6] \"p_val_adj\"   \"description\"\n\n# Reorder columns and sort by \"p_val_adj\"\ncd4_tcells &lt;- cd4_tcells[, c(1, 3:5, 2, 6:7)]\ncd4_tcells &lt;- arrange(cd4_tcells, p_val_adj)\n\ncd4_tcells$gene[1:10]\n\n [1] \"GAPDH\"   \"SRGN\"    \"CYBA\"    \"ALOX5AP\" \"CCR7\"    \"FTH1\"    \"TMSB4X\" \n [8] \"CREM\"    \"SELL\"    \"ANXA1\"  \n\n\n\n\n\n\n\n\n\nWarning\n\n\n\n这个表格和原教程的仍然有差异。\n\n\n\nOf these top genes the CREM gene stands out as a marker of activation with a positive fold change. We also see markers of naive or memory cells include the SELL and CCR7 genes with negative fold changes, which is in line with previous results.\n\n\nCell State\nMarker\n\n\n\nNaive T cells\nCCR7, SELL\n\n\nActivated T cells\nCREM, CD69\n\n\n\n\n进一步通过气泡图来可视化上述基因的表达.\n\nDotPlot(seurat_clustered_qc, \n        features = c(\"CCR7\", \"SELL\", \"CREM\", \"CD69\"), \n        idents = c(0, 2, 4, 6)) + \n  RotatedAxis()\n\n\n\n\n\n可以看到，和FindMarkers找到的top genes的fold change一致，cluster 2中的CREM基因相较于cluster 0, 4, 6高表达，而cluster 2中的CCR7和SELL相对低表达。\nBased on these plots it seems as though clusters 2 are Activated T cells, cluster 0 and 6 are Naive or memory CD4+ T cells. However, for clusters 4 it is hard to tell."
  },
  {
    "objectID": "single_cell/scRNA-seq_online/09_merged_SC_marker_identification.html#注释细胞cluster",
    "href": "single_cell/scRNA-seq_online/09_merged_SC_marker_identification.html#注释细胞cluster",
    "title": "\n26  寻找marker基因+细胞注释\n",
    "section": "\n26.5 注释细胞cluster",
    "text": "26.5 注释细胞cluster\nNow taking all of this information, we can surmise the cell types of the different clusters and plot the cells with cell type labels.\n\n\nTable 26.1: 细胞注释结果\n\nCluster ID\nCell Type\n\n\n\n0\nNaive or memory CD4+ T cells\n\n\n1\nCD14+ monocytes\n\n\n2\nActivated T cells\n\n\n3\nCD14+ monocytes\n\n\n4\nStressed cells / Unknown\n\n\n5\nCD8+ T cells\n\n\n6\nNaive or memory CD4+ T cells\n\n\n7\nB cells\n\n\n8\nNK cells\n\n\n9\nCD8+ T cells\n\n\n10\nFCGR3A+ monocytes\n\n\n11\nB cells\n\n\n12\nNK cells\n\n\n13\nB cells\n\n\n14\nConventional dendritic cells\n\n\n15\nMegakaryocytes\n\n\n16\nPlasmacytoid dendritic cells\n\n\n\n\nWe can then reassign the identity of the clusters to these cell types:\n\n# Rename all identities\nseurat_clustered_qc &lt;- RenameIdents(seurat_clustered_qc, \n                                    \"0\" = \"Naive or memory CD4+ T cells\",\n                                    \"1\" = \"CD14+ monocytes\",\n                                    \"2\" = \"Activated T cells\",\n                                    \"3\" = \"CD14+ monocytes\",\n                                    \"4\" = \"Stressed cells / Unknown\",\n                                    \"5\" = \"CD8+ T cells\",\n                                    \"6\" = \"Naive or memory CD4+ T cells\",\n                                    \"7\" = \"B cells\",\n                                    \"8\" = \"NK cells\",\n                                    \"9\" = \"CD8+ T cells\",\n                                    \"10\" = \"FCGR3A+ monocytes\",\n                                    \"11\" = \"B cells\",\n                                    \"12\" = \"NK cells\",\n                                    \"13\" = \"B cells\",\n                                    \"14\" = \"Conventional dendritic cells\",\n                                    \"15\" = \"Megakaryocytes\",\n                                    \"16\" = \"Plasmacytoid dendritic cells\")\n\n\n# Plot the UMAP\nDimPlot(seurat_clustered_qc, \n        reduction = \"umap\", \n        label = FALSE)\n\n\n\n\n\n\n\n\n\n\nTip\n\n\n\nIf we wanted to remove the potentially stressed cells, we could use the subset() function:\n\n# Remove the stressed or dying cells\nseurat_subset_labeled &lt;- subset(seurat_clustered_qc,\n                               idents = \"Stressed cells / Unknown\", # 取子集的标准\n                               invert = TRUE) # 反选\n\n# Re-visualize the clusters\nDimPlot(seurat_subset_labeled, \n        reduction = \"umap\", \n        label = FALSE)\n\n\n\n\n\n\nNow we would want to save our final labelled Seurat object:\n\n# Save final R object\nsaveRDS(seurat_clustered_qc, file = \"output/scRNA-seq_online/seurat_labelled.rds\")\n\n最后，我们把sessionInfo也导出来：\n\n# Create and save a text file with sessionInfo\nsink(file = \"output/scRNA-seq_online/sessionInfo_scrnaseq.txt\", \n     append = FALSE, \n     split = FALSE)\nsessionInfo()\nsink()\n\n\n\n\n\n\n\n关于sink函数\n\n\n\n\n\nsink函数能够将R脚本运行的结果输出到文本文件中，输出的内容为两个sink()命令之间的所有内容。\n\nfile：输出目录\nappend：取TRUE表示若输出目录下有与结果文件同名的文件，则计算结果将追加到原文件内容的后面；取FALSE（默认）表示将本次的计算结果覆盖原文件的内容\nsplit：取TRUE表示在计算结果输出到指定文件中的同时，还输出到控制台上；取FALSE（默认）表示计算结果仅输出到指定文件中。"
  },
  {
    "objectID": "single_cell/scRNA-seq_online/09_merged_SC_marker_identification.html#可选的后续分析",
    "href": "single_cell/scRNA-seq_online/09_merged_SC_marker_identification.html#可选的后续分析",
    "title": "\n26  寻找marker基因+细胞注释\n",
    "section": "\n26.6 可选的后续分析:",
    "text": "26.6 可选的后续分析:\n\n\nExperimentally validate intriguing markers for our identified cell types.\n\nExplore a subset of the cell types to discover subclusters of cells\n\n\n\n\n\n\nSubclustering scRNA-seq datasets\n\n\n\n\n\nAfter we have completed the scRNA-seq workflow and identified the various cell types present in our samples, we might decide that for a particular cell type, we would like to identify subtypes. For example, if we have a large cluster of CD4+ Helper T cells, we may want to identify subsets of Th1, Th2, Th17, Th9, and Tfh cells. To subset the dataset, Seurat has a handy subset()function（ Section 6.3.1 ）.\nTo perform the subclustering, there are a couple of different methods you could try. The easiest would be to run the FindNeighbors() and FindClusters() on the subsetted cells, adjusting the resolution to give you the optimal clustering. However, with this approach you are not redefining the most variable genes used to find clusters, so it might not work if the genes delineating these subsets are not those driving any of the top PCs used for the clustering.\nAlternatively, we could start over with the raw counts for this subset of cells and run SCTransform()to determine the greatest sources of variation present. This would allow us to focus our clustering on the most variant genes present among our subset of cells. Hopefully, the most variant genes are those driving the various desired subsets (e.g. Th1, Th2, Th17, Th9, and Tfh cells). If integration is necessary, then this step would still need to be performed.\nSince subsetting the dataset can result in a much smaller number of cells, it is important to consider the total number of cells you are looking to cluster and some of the parameters that might be affected by the small numbers. For example, if integrating, there is a ‘K’ number of cells used for determining the neighborhoods for identifying and filtering anchors. Therefore, if your integration isn’t very good for a small dataset, you might want to consider lowering the ‘K’ parameter (k.filter、k.weight) inIntegrateLayers. However, if ‘K’ is too small, it could also lead to poor integration.\n\n\n\n\n\nPerform differential expression analysis between conditions ctrl and stim（即寻找不同样本类型/条件间同一细胞类型内的差异基因，方法详见 Chapter 14 ）\n\nBiological replicates are necessary to proceed with this analysis\n\n\n\nTrajectory analysis, or lineage tracing, could be performed if trying to determine the progression between cell types or cell states. For example, we could explore any of the following using this type of analysis:\n\nDifferentiation processes\nExpression changes over time\nCell state changes in expression\n\n\n\n\n\n\n\n\n\n\nSession Info\n\n\n\n\n\n\n\nR version 4.3.2 (2023-10-31)\nPlatform: aarch64-apple-darwin20 (64-bit)\nRunning under: macOS Sonoma 14.2.1\n\nMatrix products: default\nBLAS:   /Library/Frameworks/R.framework/Versions/4.3-arm64/Resources/lib/libRblas.0.dylib \nLAPACK: /Library/Frameworks/R.framework/Versions/4.3-arm64/Resources/lib/libRlapack.dylib;  LAPACK version 3.11.0\n\nlocale:\n[1] en_US.UTF-8/en_US.UTF-8/en_US.UTF-8/C/en_US.UTF-8/en_US.UTF-8\n\ntime zone: Asia/Shanghai\ntzcode source: internal\n\nattached base packages:\n[1] stats     graphics  grDevices utils     datasets  methods   base     \n\nother attached packages:\n[1] ggplot2_3.4.4      purrr_1.0.2        tibble_3.2.1       dplyr_1.1.4       \n[5] Seurat_5.0.1       SeuratObject_5.0.1 sp_2.1-2          \n\nloaded via a namespace (and not attached):\n  [1] mathjaxr_1.6-0         RColorBrewer_1.1-3     rstudioapi_0.15.0     \n  [4] jsonlite_1.8.8         magrittr_2.0.3         TH.data_1.1-2         \n  [7] spatstat.utils_3.0-4   farver_2.1.1           rmarkdown_2.25        \n [10] vctrs_0.6.5            multtest_2.58.0        ROCR_1.0-11           \n [13] spatstat.explore_3.2-5 htmltools_0.5.7        plotrix_3.8-4         \n [16] sctransform_0.4.1      parallelly_1.36.0      KernSmooth_2.23-22    \n [19] htmlwidgets_1.6.4      ica_1.0-3              sandwich_3.1-0        \n [22] plyr_1.8.9             plotly_4.10.3          zoo_1.8-12            \n [25] igraph_1.6.0           mime_0.12              lifecycle_1.0.4       \n [28] pkgconfig_2.0.3        Matrix_1.6-4           R6_2.5.1              \n [31] fastmap_1.1.1          rbibutils_2.2.16       fitdistrplus_1.1-11   \n [34] future_1.33.0          shiny_1.8.0            numDeriv_2016.8-1.1   \n [37] digest_0.6.33          colorspace_2.1-0       patchwork_1.1.3       \n [40] tensor_1.5             RSpectra_0.16-1        irlba_2.3.5.1         \n [43] labeling_0.4.3         progressr_0.14.0       fansi_1.0.6           \n [46] spatstat.sparse_3.0-3  httr_1.4.7             TFisher_0.2.0         \n [49] polyclip_1.10-6        abind_1.4-5            compiler_4.3.2        \n [52] withr_2.5.2            mutoss_0.1-13          fastDummies_1.7.3     \n [55] MASS_7.3-60            tools_4.3.2            lmtest_0.9-40         \n [58] metap_1.9              httpuv_1.6.13          future.apply_1.11.0   \n [61] qqconf_1.3.2           goftest_1.2-3          glue_1.6.2            \n [64] nlme_3.1-164           promises_1.2.1         grid_4.3.2            \n [67] Rtsne_0.17             cluster_2.1.6          reshape2_1.4.4        \n [70] generics_0.1.3         gtable_0.3.4           spatstat.data_3.0-3   \n [73] tidyr_1.3.0            sn_2.1.1               data.table_1.14.10    \n [76] utf8_1.2.4             BiocGenerics_0.48.1    spatstat.geom_3.2-7   \n [79] RcppAnnoy_0.0.21       ggrepel_0.9.4          RANN_2.6.1            \n [82] pillar_1.9.0           stringr_1.5.1          spam_2.10-0           \n [85] RcppHNSW_0.5.0         limma_3.58.1           later_1.3.2           \n [88] splines_4.3.2          lattice_0.22-5         survival_3.5-7        \n [91] deldir_2.0-2           tidyselect_1.2.0       miniUI_0.1.1.1        \n [94] pbapply_1.7-2          knitr_1.45             gridExtra_2.3         \n [97] scattermore_1.2        stats4_4.3.2           xfun_0.41             \n[100] Biobase_2.62.0         statmod_1.5.0          matrixStats_1.2.0     \n[103] stringi_1.8.3          lazyeval_0.2.2         yaml_2.3.8            \n[106] evaluate_0.23          codetools_0.2-19       cli_3.6.2             \n[109] uwot_0.1.16            xtable_1.8-4           reticulate_1.34.0     \n[112] Rdpack_2.6             munsell_0.5.0          Rcpp_1.0.11           \n[115] globals_0.16.2         spatstat.random_3.2-2  png_0.1-8             \n[118] parallel_4.3.2         ellipsis_0.3.2         presto_1.0.0          \n[121] dotCall64_1.1-1        listenv_0.9.0          viridisLite_0.4.2     \n[124] mvtnorm_1.2-4          scales_1.3.0           ggridges_0.5.5        \n[127] leiden_0.4.3.1         rlang_1.1.2            multcomp_1.4-25       \n[130] mnormt_2.1.1           cowplot_1.1.2"
  },
  {
    "objectID": "quarto_foundation/quarto_foundation.html",
    "href": "quarto_foundation/quarto_foundation.html",
    "title": "Quarto基础",
    "section": "",
    "text": "Quarto是一个支持多种编程语言的新一代R Markdown，拥有多个新的特性和功能，同时能够兼容和渲染大多数现有的.rmd文件，而无需额外修改。Quarto可通过多种IDEs编辑，包括VS Code和RStudio。文档的后缀为.qmd。\n\n目前，Quarto还处于起步和不断发展的阶段，针对其的学习资源还十分有限，尤其是中文资源更加匮乏，因此有了汇总和编写本章的动机。本章内容主要参考了Quarto的官方指南，并提取了其中我认为在将来的编写中会经常使用的技巧并加以汇总。这本学习笔记即全程采用Quarto编写。\n本章的逻辑结构：首先介绍Quarto文档的全局设置，即YAML语法（ Chapter 27 ）；然后介绍图片的设置（ Chapter 28 ），包括插入的图片和代码块运行后产生的图片；随后介绍如何实现对图、表等的交叉引用（ Chapter 29 ）；随后介绍其他几种内容的插入（ Chapter 30 ）；随后，介绍创建和编辑Quarto Books的方法（ Chapter 31 ）；最后，介绍如何将Quarto项目的源代码通过Git上传到GitHub以及如何将编译好的Quarto Book通过GitHub Pages进行发布（ Chapter 32 ）。\n有关Quarto的详细信息，参考：https://quarto.org.\n\n\n\n\n\n\n\nTip\n\n\n\n快捷键：\n\n插入代码块：Option+Command+I（macOS）；Ctrl+Alt+I（Windows）。\n插入各类对象：Command+/；或者当光标位于新的一行开头时，直接输入/。"
  },
  {
    "objectID": "quarto_foundation/yaml_settings.html#project设置",
    "href": "quarto_foundation/yaml_settings.html#project设置",
    "title": "27  YAML设置",
    "section": "\n27.1 project设置",
    "text": "27.1 project设置\nproject在编写Quarto Book或者Quarto Websites时使用，因为要创建这些类型的Quarto项目需要通过新建一个Quarto Project来进行，因此YAML中的project项就定义了项目的类型是Quarto Book还是Quarto Websites，以及其他项目的基本设定。并且这些类型的Quarto项目会在根目录中生成一个”_quarto.yml”文件，对于YAML的配置在这个独立的文件中进行，从而将项目内的多个.qmd文档合并编译成一个Quarto Book或者Quarto Websites。\n\n---\nproject:\n  type: book\n  output-dir: \"docs\" \n  execute-dir: project \n---\n\n\n\nproject：项目类型。定义了项目编译后的文档类型，包括”default”, “website”（Quarto Websites）和”book”（Quarto Book）。这里我们在新建项目时选择了Quarto Books，所以这里自动填写了”books”。\n\n\noutput-dir：输出文件夹。编译后的HTML文件、PDF文件以及运行code chunk后产生的图像、数据等的输出文件夹。上面的例子中将输出文件夹指定为”docs”文件夹可以方便将输出的HTML文件通过GitHub Pages发布（详见 Chapter 32 ）。\nexecute-dir：在编译时，各个qmd文件内的code chunk脚本运行的根目录，默认是”file”，即当前qmd文档所在目录，可设置为 “project”，这样在编译过程中执行代码块时会将运行根目录设置为项目根目录。"
  },
  {
    "objectID": "quarto_foundation/yaml_settings.html#标题作者日期信息",
    "href": "quarto_foundation/yaml_settings.html#标题作者日期信息",
    "title": "27  YAML设置",
    "section": "\n27.2 标题/作者/日期信息",
    "text": "27.2 标题/作者/日期信息\n对于HTML的编译，这些信息会展示在文档的开头部分。\n\n---\ntitle: Quarto学习笔记\nsubtitle: 面向多编程语言的新一代R Markdown\nauthor: 杜俊宏\ndate: 2023/11/10\ndate-modified: now\ndate-format: \"YYYY[年]M[月]D[日] HH:mm\"\nauthor-title: 作者\npublished-title: 写作日期\n---\n\n\ntitle：标题。\nsubtitle：副标题。在标题下方以较小字号展示。\nauthor：作者姓名。\nauthor-title：作者栏的标签。默认标签为”AUTHOR”\ndate：文档发行日期。日期既可以手动添加，如”2023/11/10”，也可以通过now（输出样式：2023年11月11日 19:01）或today（输出样式：2023年11月11日）自动生成日期。\ndate-modified：文档的修改日期。\ndate-format：日期格式。\npublished-title：修改date的标签，默认是”PUBLISHED DATE”。\n\n\ndate-format的设置\ndate-format通过以下关键词来定义日期格式：\n\n\n\n\n\n\n\nStyle\nDescription\nExample\n\n\n\nfull\nA full date that includes the weekday name\nMonday, March 7, 2005\n\n\nlong\nA long date that includes a wide month name\nMarch 7, 2005\n\n\nmedium\nA medium date\nMar 7, 2005\n\n\nshort\nA short date with a numeric month\n3/7/05\n\n\niso\nA short date in ISO format\n2005-03-07\n\n\n\n也可以通过以下语法更加灵活的定义日期格式：\n\n\n\n\n\n\n\normat String\nOutput\nDescription\n\n\n\nYY\n18\nTwo-digit year\n\n\nYYYY\n2018\n四位数年份\n\n\nM\n1-12\nThe month, beginning at 1\n\n\nMM\n01-12\n两位数月份\n\n\nMMM\nJan-Dec\nThe abbreviated month name\n\n\nMMMM\nJanuary-December\nThe full month name\n\n\nD\n1-31\nThe day of the month\n\n\nDD\n01-31\n两位数日期\n\n\nd\n0-6\nThe day of the week, with Sunday as 0\n\n\ndd\nSu-Sa\nThe min name of the day of the week\n\n\nddd\nSun-Sat\nThe short name of the day of the week\n\n\ndddd\nSunday-Saturday\nThe name of the day of the week\n\n\nH\n0-23\nThe hour\n\n\nHH\n00-23\n两位数小时，24小时制\n\n\nh\n1-12\nThe hour, 12-hour clock\n\n\nhh\n01-12\nThe hour, 12-hour clock, 2-digits\n\n\nm\n0-59\nThe minute\n\n\nmm\n00-59\n两位数分钟\n\n\ns\n0-59\nThe second\n\n\nss\n00-59\nThe second, 2-digits\n\n\nSSS\n000-999\nThe millisecond, 3-digits\n\n\nZ\n+05:00\nThe offset from UTC, ±HH:mm\n\n\nA\nAM PM\n\n\n\na\nam pm\n\n\n\nDo\n1st 2nd … 31st\nDay of Month with ordinal\n\n\n\n可以通过”[]“添加自定义字符。通过这些语法，可以定制符合中文语法的日期格式，如：date-format: \"YYYY[年]M[月]D[日] HH:mm\"\n\n\n\n\n\n\nTip\n\n\n\n关于日期的详细指南，详见：https://quarto.org/docs/reference/dates.html。"
  },
  {
    "objectID": "quarto_foundation/yaml_settings.html#sec-theme",
    "href": "quarto_foundation/yaml_settings.html#sec-theme",
    "title": "27  YAML设置",
    "section": "\n27.3 theme主题设置",
    "text": "27.3 theme主题设置\ntheme定义了编译文档的主题。可以直接调用Quarto内置的Bootswatch主题，如”default”、“cerulean”和”cosmo”等，也可以通过Sassy Cascading Style Sheets (SCSS)文件来自定义主题。theme参数既可以在YAML中直接定义，也可以在不同的format内定义，这样可以对不同的编译格式应用不同的主题。关于Quarto主题的详细指南，参考Quarto Guide。\n\n---\nformat: \n  html:\n    theme: flatly\n---\n\nQuarto的HTML文档默认使用Bootstrap 5样式输出（theme: default）。Quarto内置了来自Bootswatch项目的25个主题。下面列出了可用的主题。关于这些主题的介绍详见：https://bootswatch.com。\n\n个人认为比较美观、清晰的主题有：Cosmo、Flatly、Lux和Darkly。可以通过light和dark分别设置一套亮色主题和一套深色主题，如：\n\n---\nformat: \n  html:\n    theme:\n      light: flatly\n      dark: darkly\n---\n\n这样，在输出的HTML网页的右上角会出现一个亮色/深色模式的切换开关。"
  },
  {
    "objectID": "quarto_foundation/yaml_settings.html#sec-toc",
    "href": "quarto_foundation/yaml_settings.html#sec-toc",
    "title": "27  YAML设置",
    "section": "\n27.4 toc目录设置",
    "text": "27.4 toc目录设置\n和theme一样toc同样可以在YAML中直接定义，也可以在不同的format内定义。\n\n---\ntoc: true\ntoc-title: Contents\ntoc-depth: 2 \ntoc-expand: 2 \ntoc-location: left\n---\n\n\ntoc：是否显示目录。\ntoc-title：目录的标题。\ntoc-depth：设置目录显示的最低层级（默认为显示到3级标题）。\ntoc-expand：在一开始目录显示到多少级，默认显示到一级标题。当向下浏览内容时目录会自动展开到toc-depth所设置的层级。设置为true时，则在一开始就展开所有目录；设置为false则在一开始折叠所有目录。\ntoc-location：设置目录的位置。默认在右侧（right）,可以设置为left或body（在文稿最开头显示）。"
  },
  {
    "objectID": "quarto_foundation/yaml_settings.html#sec-number_sections",
    "href": "quarto_foundation/yaml_settings.html#sec-number_sections",
    "title": "27  YAML设置",
    "section": "\n27.5 number-sections标题编号设置",
    "text": "27.5 number-sections标题编号设置\n和theme一样number-sections同样可以在YAML中直接定义，也可以在不同的format内定义。\n\nnumber-sections: true\nnumber-depth: 3\n\n\nnumber-sections：设置为true时会给各级标题编号。默认为false。\nnumber-depth：编号的最低标题层级。默认给所有级别的标题编号。\n{.unnumbered}：如果想要某一个标题不编号，则把这行命令粘贴到该标题后面。如”第三章{.unnumbered}“。\n{.unlisted}：将某个标题设置为不在目录中列出。如”第三章{.unlisted}“。如果想要某个标题既不编号也不在目录中列出就可以这样写：”标题{.unnumbered .unlisted}“。"
  },
  {
    "objectID": "quarto_foundation/yaml_settings.html#排版设置",
    "href": "quarto_foundation/yaml_settings.html#排版设置",
    "title": "27  YAML设置",
    "section": "\n27.6 排版设置",
    "text": "27.6 排版设置\n主要定义了图/表标题的位置、参考文献/脚注的位置、页面大小和页边距等。可以在YAML中直接定义，也可以在不同的format内定义。\n\n---\nfig-cap-location: bottom\ntbl-cap-location: top\nreference-location: margin \ncitation-location: document  \n---\n\n\n\nfig-cap-location：图片标题的位置。默认在图片底部（bottom）。\n\ntbl-cap-location：表格标题的位置。默认在表格上方（top）。\n\nreference-location：脚注的默认展示位置。默认为文档最后 (document)。\n\ncitation-location：参考文献的默认展示位置。默认为文档最后 (document)。\n\n\n\nTable 27.1: 图/表标题位置、参考文献/脚注的位置设置\n\n\n\n\n\nOption\nDescription\n\n\n\nreference-location\nWhere to place footnotes. Defaults to document.\n[document | section | block | margin ]\n\n\ncitation-location\nWhere to place citations. Defaults to document.\n[document | margin ]\n\n\ncap-location\nWhere to place figure and table captions. Defaults to bottom for figures and top for tables. | [top | bottom | margin]\n\n\nfig-cap-location\nWhere to place figure captions. Defaults to bottom.\n[top | bottom | margin]\n\n\ntbl-cap-location\nWhere to place table captions. Defaults to top.\n[top | bottom | margin]"
  },
  {
    "objectID": "quarto_foundation/yaml_settings.html#execute代码块执行设置",
    "href": "quarto_foundation/yaml_settings.html#execute代码块执行设置",
    "title": "27  YAML设置",
    "section": "\n27.7 execute代码块执行设置",
    "text": "27.7 execute代码块执行设置\nexecute用来指定代码块的执行行为，例如是否运行、是否显示警告信息和是否缓存运行结果等。\n\n---\nexecute:\n      eval: false\n      warning: false\n      cache: true\n---\n\n\neval：设置为false时只显示代码，不运行。默认为true。\necho：设置为false时在输出文件中不显示代码，仅显示代码的运行结果。设置为fenced，会将代码块的设置，即”#|“符号后的内容，也展示出来。Figure 27.1 这个代码块就用了echo: fenced这个设定，可以看一下效果。默认为true。\noutput：设置为false时，只运行代码不显示运行结果。默认为true。\nwarning：是否显示代码运行的警告信息。默认为true。\ncache：是否开启运算结果缓存。默认为false。如果设置为true，就会在编译时将源代码的运算结果保存到文件目录中后缀为”_cache”的文件夹中。这样在重新编译同一个文档时会加快编译速度。\n\n除了对代码执行行为的全局设置，我们也可以针对每个代码块设置其执行行为。许多参数和YAML中的语法相似，只不过需要在每个参数前加上”#|”符号。如：\n\n```{r}\n#| eval: true\n#| warning: false\n#| output: true\n#| label: fig-箱型图\n#| fig-cap: 箱型图\nboxplot(1:100)\n```\n\n\n\nFigure 27.1: 箱型图\n\n\n\n\n\n\n\n\n\nCaution\n\n\n\n有时候当一个代码块需要读取一个较大的对象时（如包含大量细胞的Seurat对象），尽管运行该代码块不会报错，但是在编译时可能会出现如下报错：\nlong vectors not supported yet: /Volumes/Builds/R4/R-4.3.2/src/main/connections.c:6093\n这时我们可以通过添加#| cache-lazy: false命令，取消延迟缓存来解决这个问题：\n\n```{r}\n#| cache-lazy: false\nlibrary(Seurat)\nseurat_integrated &lt;- readRDS(\"output/scRNA-seq_online/seurat_clustered.rds\")\n```"
  },
  {
    "objectID": "quarto_foundation/yaml_settings.html#crossref交叉引用设置",
    "href": "quarto_foundation/yaml_settings.html#crossref交叉引用设置",
    "title": "27  YAML设置",
    "section": "\n27.8 crossref交叉引用设置",
    "text": "27.8 crossref交叉引用设置\ncrossref定义了图/表的标签、默认引用样式、编号类型等。\n\n---\ncrossref:\n  fig-title: 图     \n  tbl-title: 表     \n  title-delim: \"：\"  \n  fig-prefix: 图   \n  tbl-prefix: 表    \n  sec-prefix: 章节 \n  ref-hyperlink: true \n  fig-labels: arabic    \n  tbl-labels: arabic   \n  subref-labels: alpha A \n---\n\n\nfig-title: 图的默认标签文字（默认是”Figure”）\ntbl-title: 表的默认标签文字（默认是”Table”）\ntitle-delim: 图、表标签文字和后面的图、表标题之间的连接符（默认是”:“）\nfig-prefix: 图的默认引用样式（默认是”Figure”）\ntbl-prefix: 表的默认引用样式（默认是”Table”）\nsec-prefix: 章节的默认引用样式（默认是”Section”）\nref-hyperlink: 是否为交叉引用加上内部链接（默认是”true”）\nfig-labels: 图片的编号类型（默认是阿拉伯数字：arabic)\ntbl-labels: 表格的编号类型（默认是阿拉伯数字：arabic）\nsubref-labels: 次级引用编号类型，如组图中的小图（默认是小写字母：alpha a）\n\n可用的编号类型包括：\n\narabic (1, 2, 3)\nroman (I, II, III, IV)\nroman i (i, ii, iii, iv)\nalpha x (start from letter ‘x’)\nalpha X (start from letter ‘X’)"
  },
  {
    "objectID": "quarto_foundation/yaml_settings.html#sec-ref_settings",
    "href": "quarto_foundation/yaml_settings.html#sec-ref_settings",
    "title": "27  YAML设置",
    "section": "\n27.9 参考文献设置",
    "text": "27.9 参考文献设置\n只要在编辑qmd文档时插入了参考文献，YAML中会新增参考文献的配置选项：bibliography: references.bib。同时根目录下会生成一个名为”references.bib”的参考文献配置文件。该配置文件包括了qmd文档中所插入的所有参考文献的列表。以BibTeX/Citation风格语言编写。bibliography指定了这个参考文献配置文件所在的路径。\n\n---\nbibliography: references.bib\n---"
  },
  {
    "objectID": "quarto_foundation/yaml_settings.html#format编译设置",
    "href": "quarto_foundation/yaml_settings.html#format编译设置",
    "title": "27  YAML设置",
    "section": "\n27.10 format编译设置",
    "text": "27.10 format编译设置\nformat定义了qmd文档编译后的文件类型，例如：“html”, “pdf”, “docx”, “odt”, “pptx”, “revealjs”, “beamer”, “gfm”（GitHub风格的Markdown文档）, “commonmark”, “mediawiki”, “epub”, “ipynb”。不同的编译格式对应的子项设置各不相同，有些参数适用于某些格式但是在另一些格式中则无法兼容。所有支持的编译格式详见Quarto官方文档。下面的案例为编译HTML和GFM的常用设置。\n\n---\nformat: \n  html:\n    theme: \n      light: flatly \n      dark: darkly \n  gfm:\n    toc: true\n    toc-depth: 1\n    number-sections: true\n    citation-location: document\n    output-file: \"README.md\" \n---\n\n编译Quarto文档时，首先knitr将运行所有代码块，并创建一个新的markdown（.md）文档，其中包括源代码及其输出结果。接下来，生成的markdown文件经过pandoc（RStudio内置了pandoc）处理后，被转换成HTML、PDF或者Word等我们需要的文档格式。RStudio封装了这些操作，当我们完成Quarto编辑，点击渲染时，就会完成上述过程。\nQuarto的渲染工作流\n\n编译HTML\n\n---\nformat: \n  html:\n    theme: \n      light: flatly \n      dark: darkly \n    embed-resources: false\n    code-tools: true\n    title-block-banner: images/banner.jpg \n    title-block-banner-color: \"black\"\n    toc: true\n    toc-title: 目录\n    toc-location: left\n    toc-depth: 2\n    toc-expand: 1\n    number-sections: true\n    number-depth: 3\n    anchor-sections: true\n    link-external-icon: true\n    link-external-newwindow: true\n    df-print: kable \n    code-link: true\n---\n\n\ntheme：主题。同 Section 27.3 。\nembed-resources：是否将所有源文件嵌入HTML文件以方便分享。默认为”false”。\ncode-tools：是否在网页右上角显示”&lt;code&gt;“按钮。点击该按钮可以看到Quarto文档的原始markdown代码。\n\ntitle-block-banner：标题横幅设置。title-block-banner有以下选项：\n\ntrue：将标题以网页横幅的形式展示，样式为them中所选样式的默认样式。\n具体颜色：如title-block-banner: \"#003262\"。\n图片路径：如title-block-banner: images/banner.jpeg。\n\n\ntoc相关设置：同 Section 27.4 。\nnumber-sections、number-depth：同 Section 31.5 。\nanchor-sections: 设置为true时，当鼠标移到各级标题上时会显示anchor link，方便我们复制直接定位到该标题的超链接。\nlink-external-icon：设置为true时会在外部链接上显示一个小图标。\nlink-external-newwindow：是否在新标签页打开外部链接。\ndf-print：表格输出样式\n\ncode-copy：设置代码复制按钮：\n\ntrue: 总是在代码块右上角显示代码复制按钮。\nfalse: 隐藏代码复制按钮。\nhover：（默认）当鼠标移过时显示代码复制按钮。\n\n\ncode-fold: 是否折叠代码。\ncode-link: 是否自动为函数加上超链接。该功能基于downlit包，可以自动为识别到的函数加上一个链接到官方文档的超链接。\n编译GitHub Flavored Markdown（GFM）\n我们可以将Quarto文档转换为GitHub风格的Markdown文档（GitHub Flavored Markdown，GFM）。这可以用来生成GitHub项目的README.md文档。\n\n---\ntitle: \"My Project\"\nformat: \n  gfm:\n    identifier-prefix: readme # 标识符\n    # preview-mode: raw # 预览原始markdown\n    keep-yaml: true\n    toc: true\n    toc-depth: 1\n    number-sections: true\n    citation-location: document\n    output-file: \"README.md\" # 输出文档的文件名\n---\n\n编译PDF\n如果要在rmarkdown、bookdown中使用PDF输出功能， 可以在在R中安装tinytex扩展包并安装TinyTeX编译软件：\n\ninstall.packages('tinytex')\ntinytex::install_tinytex()\n\n其中上面第一行命令安装R的tinytex扩展包， 第二行将下载LaTeX编译程序的服务器设置为清华大学tuna镜像站， 第三行安装LaTeX编译程序。\n如果安装成功， TinyTeX软件包在MS Windows系统中一般会安装在 C:\\Users\\用户名\\AppData\\Roaming\\TinyTeX目录中， 其中”用户名”应替换成系统当前用户名。 如果需要删除TinyTeX软件包， 只要直接删除那个子目录就可以。\n为了判断TinyTeX是否安装成功， 在RStudio中运行：\n\ntinytex::is_tinytex()\n\n结果应为TRUE, 出错或者结果为FALSE都说明安装不成功。\n当用户使用RMarkdown和tinytex包转换latex并编译为PDF时， 如果缺少某些latex宏包， tinytex会自动安装缺少的宏包。"
  },
  {
    "objectID": "quarto_foundation/images_settings.html#sec-Settings_for_inserting_figs",
    "href": "quarto_foundation/images_settings.html#sec-Settings_for_inserting_figs",
    "title": "28  图片设置",
    "section": "\n28.1 插入图片的设置",
    "text": "28.1 插入图片的设置\n图片可以通过复制粘贴直接插入，Quarto定义图像的基本语法是：\n![图片标题](images/crossref-figure.png){#fig-elephant width=\"290\"}。\n其中，方括号内的是对象的caption（可选），小括号内是图像所在目录，“{}”内的内容是图像的label以及其他可选设置，各参数间用空格进行分割。常用的图像设置如下：\n\nwidth和height：图像的宽、高。默认单位为像素。\nfig-align：图片的对齐方式，如”left”，“right”。\n可以在小括号内添加超链接，如[![](``images/crossref-figure.png``)](https://en.wikipedia.org/wiki/Elephant)，当点击该图像时会跳转该网站。\ncaption和label的设置会使该图像能够被交叉引用（详见 Section 29.2 ）。\n\n.column-page：让图片以整个文档的宽度展示。需要首先建立一个Pandoc Div块（Figure 28.1）。然后在Pandoc Div块的参数项内填上{.column-page}。如下所示：\n\n:::{.column-page}\n![](images/elephant.jpg)\n:::\n\n这样这张图片就会以文档最大宽度显示：\n\n\n\n\n\n\n\n\n\n\n\n应用于代码块时为：#| column: page\n\n\n\n\n\n.column-screen：让图片占满整个网页的宽度。应用于代码块时为：#| column: screen。\n\n\n\n\n\n\ncolumn-screen-inset-shaded：让图片以整个文档的宽度展示，但是在后方加上一个网页宽度的阴影。应用于代码块时为：#| column: screen-inset-shaded。\n\n\n\n\n组图的设置\n要容纳和排版组图，需要首先建立一个Pandoc Div块（Figure 28.1）。\n\n\nFigure 28.1: 建立Div块\n\nDiv块的图像排版基本语法如下：\n\n\nFigure 28.2: Div块的基本语法\n\n\n“{}”内为组图的label、排版设置。\n在所有图片最后可输入组图的总标题，如上图中的”交叉引用的设置”。\n\n设置图片的排版方式。\nlayout-ncol和layout-nrow：设置组图的行和列分别排多少张图片。如::: {layout-ncol=\"2\"}。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nLayout复杂排版\n其基本语法和 Section 28.2 一致。不同点在于需要在Div块开头的”{}“内设置，同时layout后要接”=“，并且注意加引号，例如：layout=\"[[1，1]，[1]]\"。通过设置layout可以完成对多图的复杂排版。layout属性是一个二维数组，其中第一维定义行，第二维定义列。layout=\"[[1，1]，[1]]\"表示：创建两行，第一行有两列大小相等的列，第二行只有一列。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n组图复杂排版设置\n\n\n\n\n\n\n\n\n\nNote\n\n\n\n关于图片设置的详细指南，参考：https://quarto.org/docs/authoring/figures.html。"
  },
  {
    "objectID": "quarto_foundation/images_settings.html#sec-Code_chunk_figs_output_settings",
    "href": "quarto_foundation/images_settings.html#sec-Code_chunk_figs_output_settings",
    "title": "28  图片设置",
    "section": "\n28.2 代码块图片输出设置",
    "text": "28.2 代码块图片输出设置\n对于代码块运行后生成的图片，我们也可以对其进行各种设置以使其在编译后的文档中符合理想的展示要求。基本语法和 中类似，只不过需要在前面加上”#|”符号，然后将其放置在代码块开头。常用的参数有：\n\n#| lable：图片标签。\n#| fig-cap：图片标题（caption）。fig-cap和lable共同用于图片的交叉引用，详见 Section 29.2 。\n#| fig-width：图片的宽度。\n#| fig-height：图片的高度。\n\n其他设置包括#| fig-align、#| fig-cap-location等，见 Section 28.1 。\n\n```{r}\n#| eval: true\n#| label: fig-散点图\n#| fig-cap: \"38种流行车型的城市和高速公路里程\"\n#| fig-width: 6\n#| fig-height: 3.5\nlibrary(ggplot2)\nggplot(mpg, aes(x = hwy, y = cty, color = cyl)) +\n  geom_point(alpha = 0.5, size = 2) +\n  scale_color_viridis_c() +\n  theme_minimal()\n```\n\n\n\nFigure 28.3: 38种流行车型的城市和高速公路里程\n\n\n\n代码块组图输出设置\n如果一个代码块运行后可以生成多张图像，那么我们也可以和 Section 28.1.1 中一样，对这些图片进行组图排版。常用的参数包括：\n\nlayout-ncol和layout-nrow：设置组图的行和列分别排多少张图片。如layout-ncol: \"2\"。\nlabel：组图的标签。\nfig-cap：每张图的标题。通过”-“符号分别设置。效果如下所示：\n\n\n```{r}\n#| eval: true\n#| layout-ncol: 2\n#| label: fig-组图输出\n#| fig-cap:\n#|   - \"车辆的速度和停车距离\"\n#|   - \"汽压与温度的关系\"\n\nplot(cars)\nplot(pressure)\n```\n\n\n\n\n\nFigure 28.4: 车辆的速度和停车距离\n\n\n\n\n\nFigure 28.5: 汽压与温度的关系\n\n\n\n\n\n\n\nfig-subcap：每张图以小标题进行标注，如”(a) sub caption”、“(b) sub caption”。效果如下所示：\n\n\n```{r}\n#| eval: true\n#| label: fig-小标题组图输出\n#| fig-cap: \"小标题组图输出\"\n#| fig-subcap:\n#|   - \"汽车\"\n#|   - \"压力\"\n#| layout-ncol: 2\n\nplot(cars)\nplot(pressure)\n```\n\n\n\n\n\n(A) 汽车\n\n\n\n\n\n(B) 压力\n\n\n\nFigure 28.6: 小标题组图输出\n\n\n\n用layout进行复杂排版\nlayout属性是一个二维数组，其中第一维定义行，第二维定义列。如layout: \"[[1，1]，[1]]表示：创建两行，第一行有两列大小相等的列，第二行只有一列。\n\n```{r}\n#| eval: true\n#| label: fig-输出复杂排版图片\n#| fig-cap: 复杂排版组图输出\n#| fig-subcap:\n#|   - 汽车\n#|   - 压力\n#|   - mtcars\n#| layout: [[1], [1, 1]]\n\nplot(cars)\nplot(pressure)\nplot(mtcars)\n```\n\n\n\n\n\n(A) 汽车\n\n\n\n\n\n\n\n(B) 压力\n\n\n\n\n\n(C) mtcars\n\n\n\nFigure 28.7: 复杂排版组图输出\n\n\n\nlayout后的”[]“中的数字大小表示各个图像的相对大小。所以可以用任何值来自定义：\n\n```{r}\n#| eval: true\n#| label: fig-输出复杂排版图片2\n#| fig-cap: 复杂排版组图输出2\n#| fig-subcap:\n#|   - 汽车\n#|   - 压力\n#|   - mtcars\n#| layout: [[100], [30, 70]]\n\nplot(cars)\nplot(pressure)\nplot(mtcars)\n```\n\n\n\n\n\n(A) 汽车\n\n\n\n\n\n\n\n(B) 压力\n\n\n\n\n\n(C) mtcars\n\n\n\nFigure 28.8: 复杂排版组图输出2\n\n\n\n如果我们输入负数，如下面的”-10”，则会在两个图之间加上相应的间距：\n\n```{r}\n#| eval: true\n#| label: fig-输出复杂排版图片3\n#| fig-cap: 复杂排版组图输出3\n#| fig-subcap:\n#|   - 汽车\n#|   - 压力\n#|   - mtcars\n#| layout: [[45,-10, 45], [100]]\n\nplot(cars)\nplot(pressure)\nplot(mtcars)\n```\n\n\n\n\n\n(A) 汽车\n\n\n\n \n\n\n\n\n(B) 压力\n\n\n\n\n\n\n\n(C) mtcars\n\n\n\nFigure 28.9: 复杂排版组图输出3"
  },
  {
    "objectID": "quarto_foundation/cross_references.html#标题节的交叉引用",
    "href": "quarto_foundation/cross_references.html#标题节的交叉引用",
    "title": "29  交叉引用",
    "section": "\n29.1 标题/节的交叉引用",
    "text": "29.1 标题/节的交叉引用\n只需通过sec-定义label，基本语法：Introduction {#sec-introduction}。注意：要使用节的引用，需要在YAML开启标题编号（number-sections: true），以便读者能够看到这些编号。"
  },
  {
    "objectID": "quarto_foundation/cross_references.html#sec-Cross_referencing_of_figs",
    "href": "quarto_foundation/cross_references.html#sec-Cross_referencing_of_figs",
    "title": "29  交叉引用",
    "section": "\n29.2 图片的交叉引用",
    "text": "29.2 图片的交叉引用\n实现的方法：\n\n方法一：在源代码模式下修改被引用对象的属性，如：![Example for cross reference](images/crossref-figure.png){#fig-elephant width=\"290\"}。其中，方括号内的是对象的caption，小括号内是图片所在的目录，“{}”内的内容是图像的label以及其他可选设置。\n方法二：点击待引用对象右上角的三个点，进入对象设置。分别输入caption和ID（即label）（Figure 29.1 )。\n\n\n\n\n\n\n\n\n\n\nFigure 29.1: 交叉引用的设置\n\n\n例如下面的图片，可以被引用：Figure 29.2 。\n\n\nFigure 29.2: Example for cross reference\n\n组图的交叉引用\n基本语法：\n\n案例：\n\n\n\n\n\n(A) 素描大象\n\n\n\n\n\n(B) 油画大象\n\n\n\nFigure 29.3: 组图的交叉引用\n\n\n现在，我们就可以将组图一起引用（Figure 29.3 ），或是单独引用组图内的某一张图（Figure 29.3 (B) ，Figure 29.3 (A) ）。"
  },
  {
    "objectID": "quarto_foundation/cross_references.html#表格的交叉引用",
    "href": "quarto_foundation/cross_references.html#表格的交叉引用",
    "title": "29  交叉引用",
    "section": "\n29.3 表格的交叉引用",
    "text": "29.3 表格的交叉引用\nMarkdown表格的引用\n只需在表格后加上: My Caption {#tbl-letters}即可使该表格能够被引用。如下面的表格 Table 29.1 。\n\n\nTable 29.1: 表格的交叉引用示例\n\nCol1\nCol2\nCol3\n\n\n\nA\nB\nC\n\n\nE\nF\nG\n\n\nA\nG\nG\n\n\n\n\n代码输出表格的引用\n\nlabel：tbl-：表格的标签。\ntbl-cap：表格的标题。\nknitr包提供了一个 kable() 函数可以用来把数据框或矩阵转化成有格式的表格，支持HTML、docx、LaTeX等格式。\n\n\n```{r}\n#| eval: true\n#| label: tbl-iris\n#| tbl-cap: \"Iris数据\"\n\nlibrary(knitr)\nkable(head(iris))\n```\n\n\n\nTable 29.2: Iris数据\n\nSepal.Length\nSepal.Width\nPetal.Length\nPetal.Width\nSpecies\n\n\n\n5.1\n3.5\n1.4\n0.2\nsetosa\n\n\n4.9\n3.0\n1.4\n0.2\nsetosa\n\n\n4.7\n3.2\n1.3\n0.2\nsetosa\n\n\n4.6\n3.1\n1.5\n0.2\nsetosa\n\n\n5.0\n3.6\n1.4\n0.2\nsetosa\n\n\n5.4\n3.9\n1.7\n0.4\nsetosa\n\n\n\n\n\n\n现在，就可以通过 Table 29.2 来引用该表格了。\n\n\n\n\n\n\nNote\n\n\n\n关于表格的详细指南，参考：https://quarto.org/docs/authoring/tables.html。"
  },
  {
    "objectID": "quarto_foundation/insert_other_content.html#插入参考文献",
    "href": "quarto_foundation/insert_other_content.html#插入参考文献",
    "title": "30  插入其他内容",
    "section": "\n30.1 插入参考文献",
    "text": "30.1 插入参考文献\n在插入菜单中选择”Citation”：\n\n\nFigure 30.1: 参考文献的引用\n\n然后通过DOI或标题检索参考文献，选择目标文献：\n\n\nFigure 30.2: 参考文献的选择\n\n现在就会出现参考文献的交叉引用，如： (Fujii et al. 2023) 、(Sprumont et al. 2023)。并且会在文档最后生成参考文献列表，同时YAML中会新增参考文献的配置选项：bibliography: references.bib。同时根目录下会生成一个名为”references.bib”的参考文献配置文件。\n如果想改变参考文献展示的位置，可以在YAML中设置，如：\n\n---\ncitation-location: margin\n---\n\n可用的值参见 Table 27.1 。这份文档的参考文献就设置为了在页面最后展示（citation-location: document）。\n\n\n\n\n\n\nNote\n\n\n\n关于参考文献和脚注的详细指南，参考：https://quarto.org/docs/authoring/footnotes-and-citations.html。"
  },
  {
    "objectID": "quarto_foundation/insert_other_content.html#插入callouts",
    "href": "quarto_foundation/insert_other_content.html#插入callouts",
    "title": "30  插入其他内容",
    "section": "\n30.2 插入Callouts",
    "text": "30.2 插入Callouts\nCallouts会生成一个标注框，可以用来标注重要内容：\n\n例如：\n\n\n\n\n\n\nTip\n\n\n\n这是一个Callouts示例。\n\n\n其样式包括：\n\n\ncallout-note\n\n\n\ncallout-tip\n\n\n\ncallout-important\n\n\n\ncallout-caution\n\n\n\ncallout-warning"
  },
  {
    "objectID": "quarto_foundation/insert_other_content.html#插入在线视频",
    "href": "quarto_foundation/insert_other_content.html#插入在线视频",
    "title": "30  插入其他内容",
    "section": "\n30.3 插入在线视频",
    "text": "30.3 插入在线视频\n通过以下语法可以在输出文档中插入可直接播放的在线视频：\n\n{{&lt; video https://www.youtube.com/embed/wo9vZccmqwc &gt;}}\n\n\n\n\n\n\n\nFujii, Kouichi, Jin Kikuchi, Masatoshi Uchida, Masanari Machida, Midori Tsuchiya, Kentaro Hayashi, Nana Maekawa, Hajime Houzumi, Arata Honda, and Koji Wake. 2023. “Tiger Attack at a Japanese Safari Park: A Case Report.” International Journal of Emergency Medicine 16 (1). https://doi.org/10.1186/s12245-023-00556-3.\n\n\nSprumont, Adrien, Ana Rodrigues, Simon J. McGowan, Colin Bannard, and Oliver Bannard. 2023. “Germinal Centers Output Clonally Diverse Plasma Cell Populations Expressing High- and Low-Affinity Antibodies.” Cell, November. https://doi.org/10.1016/j.cell.2023.10.022."
  },
  {
    "objectID": "quarto_foundation/quarto_books.html#项目设置",
    "href": "quarto_foundation/quarto_books.html#项目设置",
    "title": "31  Quarto Books",
    "section": "\n31.1 项目设置",
    "text": "31.1 项目设置\n\n---\nproject:\n  type: book\n  output-dir: \"docs\" \n  execute-dir: project \n---\n\n\nproject：项目类型。定义了项目编译后的文档类型，包括default, website（Quarto Websites）和book（Quarto Book）。这里我们在新建项目时选择了Quarto Books，所以这里自动填写了book。\noutput-dir：输出文件夹。编译后的HTML文件、PDF文件以及运行code chunk后产生的图像、数据等的输出文件夹。上面的例子中将输出文件夹指定为”docs”文件夹可以方便将输出的HTML文件通过GitHub Pages发布（详见 Chapter 32 ）。\nexecute-dir：在编译时，各个qmd文件内的code chunk脚本运行的根目录，默认是file，即当前qmd文档所在目录，可设置为 “project”，这样在编译过程中执行代码块时会将脚本运行根目录设置为项目根目录。"
  },
  {
    "objectID": "quarto_foundation/quarto_books.html#书结构设置",
    "href": "quarto_foundation/quarto_books.html#书结构设置",
    "title": "31  Quarto Books",
    "section": "\n31.2 书结构设置",
    "text": "31.2 书结构设置\nbook参数定义了Quarto Book的章节结构以及顶栏、导航栏等内容。是Quarto Books的YAML配置的核心。\n标题/作者/日期信息\n\n---\nbook:\n  title: \"R语言数据科学\"\n  subtitle: \"从数据清洗到高级统计学和生物信息学\"\n  author: \"杜俊宏\"\n  date: 2023/11/10\n  date-format: \"YYYY[年]M[月]D[日]\"\n  cover-image: images/book_cover.png\n---\n\n\ntitle：标题。\nsubtitle：副标题。在标题下方以较小字号展示。\nauthor：作者姓名。\ndate：文档发行日期。日期既可以手动添加，如”2023/11/10”，也可以通过now（输出样式：2023年11月11日 19:01）或today（输出样式：2023年11月11日）自动生成日期。\ndate-format：日期格式（详见： Section 27.2.1 ）。\ncover-image：封面图片。\n\n\n\n\n\n\n\nTip\n\n\n\n上面列出的信息也可以在index.qmd文件中定义。\n\n\n\nchapter章节\n章节的定义是Quarto Books的YAML配置的核心。通过chapter函数将多个不同的qmd文件（章节）按照指定的顺序结合起来就形成了一本书或者网站。\n\n---\nbook:\n  chapters:\n    - text: 主页\n      file: index.qmd\n    - intro.qmd\n    - text: \"---\" \n    - part: r_basic/r_basics.qmd\n      chapters:\n        - r_basic/environment_configuration.qmd\n        - r_basic/data_input_output.qmd\n    - part: bioinformatics/single_cell/r_single_cell.qmd\n      chapters:\n        - bioinformatics/single_cell/seurat_command_list.qmd\n        - bioinformatics/single_cell/seurat_tutorial.qmd\n        - bioinformatics/single_cell/data_visualization_methods_in_seurat.qmd\n        - bioinformatics/single_cell/sctransform.qmd\n        - bioinformatics/single_cell/integration.qmd\n    - part: quarto_foundation/quarto_foundation.qmd\n      chapters:\n        - quarto_foundation/yaml_settings.qmd\n        - quarto_foundation/images_settings.qmd\n        - quarto_foundation/cross_references.qmd\n        - quarto_foundation/insert_other_content.qmd\n        - quarto_foundation/quarto_books.qmd\n        - quarto_foundation/github_pages.qmd\n    - text: \"---\"\n    - part: \"参考文献\"\n      chapters:\n        - references.qmd\n---\n\n\n\npart：如果一本书有大量的qmd文件（章节），那么我们可以按照不同的主题将这些qmd文件分成不同的篇章。part可以用qmd文件或者字符定义。如果提供的是qmd文件，那么该qmd文件在编译后会是该篇章的首页，并以单独的一个页面显示。每个篇章可由多个不同的qmd文件（章节）组成。篇章的首页内容会以单独的一个页面显示，一般写该篇章的内容概要。如果提供的是字符，那么这个篇章只会反映在左侧导航栏上，而不会有单独的篇章首页。如上面的part: \"参考文献\"。\n\nchapters：章节。在其下方列出需要包含的所有qmd文件。part和chapters共同完成对章节的组织。\n\ntext： “---”：分隔符。会在导航栏对应位置上显示一条横线。\n\n上面的配置在编译后的效果：\n\n侧边栏\n侧边栏是传统意义上的总目录，默认在网页的左侧显示，其内容反映了上面chapter中定义的章节编排。通过sidebar对侧边栏的样式、内容等进行进一步的设定。\n\n---\nbook:\n  sidebar:\n    style: \"docked\" \n    collapse-level: 1 \n    search: true \n    logo: images/logo.png \n    tools:\n      - icon: twitter \n        href: https://twitter.com \n      - icon: youtube\n        href: https://youtube.com\n---\n\n\nstyle：侧边导航栏的风格。默认为docked，固定导航栏。也可以选择浮动导航栏，floating。\ncollapse-level：侧边导航栏初始显示到多少级标题，默认显示到一级标题，只有当浏览到某一篇章时才会展开该篇章下的2级标题。\nsearch：是否打开侧边栏上的搜索框。注意如果开启了顶栏（见下一节顶部导航栏），那么搜索按钮会默认在顶栏显示。\nlogo：在侧边导航栏上方显示图像。\ntools：定制侧边栏工具。语法同下一节顶部导航栏中的left和right内的定义类似。\n\n采用上述配置后的侧边栏样式：\n\n顶部导航栏\n除了添加侧边导航栏之外，还可以通过navbar参数添加顶部导航栏。\n\n---\nbook:\n  navbar:\n    logo: images/logo.jpg\n    background: \"#f1f1f3\" \n    foreground: \"black\" \n    search: true\n    left:\n      - text: \"Home\"\n        file: index.qmd\n      - file: intro.qmd\n      - text: \"Parts\"\n        menu:\n          - r_basic/r_basics.qmd\n          - bioinformatics/single_cell/r_single_cell.qmd\n          - quarto_foundation/quarto_foundation.qmd\n      - file: references.qmd\n    right:\n      - icon: book-fill\n        text: Bookdown\n        href: https://bookdown.org\n      - icon: github\n        text: GitHub\n        menu:\n          - text: Source Code\n            url: https://github.com/djhcod/r-notes\n          - text: Report a Bug\n            url: https://github.com/djhcod/r-notes/issues\n          - text: Pull Request\n            url: https://github.com/djhcod/r-notes/pulls\n---\n\n\nlogo：顶栏左侧的logo。\nbackground：顶栏背景色（默认为primary，网页主色）。\nforeground：顶栏字体颜色。\nsearch：是否在顶栏右侧显示搜索按钮。\n\nleft和right：分别定义顶栏左侧和右侧显示的内容：\n\nfile：qmd文件。qmd文件内的一级标题就是编译后显示在导航栏上的文字。\ntext：显示文字。在其下方添加qmd文件即可将文字链接到对应的qmd文件编译后的页面。这可以用于自定义某个qmd文件在导航栏上显示的文字。例如这里的index.qmd的标题是”主页”（title：主页），如果我们直接用file把它列出来，那么在导航栏上就会显示index.qmd的标题，即”主页”。但是我们通过text: \"Home\"，并在其下方接file: index.qmd，那么在编译后的HTML中顶栏上会显示”Home”文字，点击后还是链接到index.qmd编译后的首页。如果text下方提供的是url，那么点击该文字后就会跳转到指定网站。\nicon：图标，和text的作用类似。Quarto可以调用Bootstrap Icons图标库，只需指定图标在Bootstrap Icons网站中的的官方名字，如”github”、“twitter”，就可以直接调用该图标。\n\n\n\nFigure 31.1: Bootstrap Icons图标库\n\n\nmenu：下拉菜单。效果如 Figure 31.2 所示。\nurl和herf：效果类似，都是添加外部网址。\n\n\n\n\n\nFigure 31.2: 顶栏示例\n\n\n\n\n\n\n\nTip\n\n\n\n顶栏和侧边导航栏的更多设置，参考Quarto官方指南。\n\n\n右侧页内导航\n右侧页内导航显示的是当前页面的目录。可在book内的page-navigation和format-html内的toc相关函数中共同配置。\n\n\n---\nbook:\n  page-navigation: true\n  repo-url: https://github.com/djhcod/r-notes \n  repo-actions: [source, issue, edit] \n---\n\n\npage-navigation：是否打开右侧的页内导航。\nrepo-url：（可选）GitHub仓库的链接。\nrepo-actions：（可选）在右侧页内导航的下方显示导航到GitHub仓库各板块的链接。可选的值有source、issue、edit。如果是source，repo-actions会首先根据当前所浏览的页面，在repo-url定义的URL后加上当前页面源码的后缀（如”/blob/main/quarto_foundation/quarto_books.qmd”），这样就会得到一个指向GitHub项目中编译该页面的源码的链接。如果是edit则会在此链接的基础上再加上编辑该页面源码的后缀（“/edit/main/quarto_foundation/quarto_books.qmd”）。如果是issue则会在GitHub仓库链接的基础上加上定位到问题报告的后缀（“/issues/new”）。\n搜索框设置\nsearch可以用来指定搜索按钮的样式。同时，对于既有顶栏又有左侧导航栏的book，可以通过search来指定搜索按钮出现的位置。\n\n---\nbook:\n  search:\n    location: sidebar\n    type: textbox\n---\n\n\nlocation：搜索按钮的位置。默认为出现在顶栏（ ）最右侧（navbar）；也可以定义为sidebar，让其在侧边栏（ Section 31.2.3 ）的上方显示。\ntype：搜索按钮的样式。可以仅搜索图标（overlay），也可以展示搜索框（textbox）。\n页脚设置\n页脚出现在每个页面的最下面，通过page-footer统一配置。\n\n\nFigure 31.3: 页脚示例\n\n\n---\nbook:\n  page-footer:\n    left:\n      - text: \"This book was built with Quarto\"\n    center: \"Copyright 2023, Du Junhong\"\n    right:\n      - icon: github\n        href: https://github.com/djhcod\n    border: true  \n---\n\n页脚的配置和 Section 31.2.4 的语法基本一致，此处不再赘述。\n网站分享设置\n\n---\nbook:\n  favicon: images/logo.png # \n  sharing: [twitter, facebook] # \n  twitter-card: true\n  site-url: https://example.com\n---\n\n\n\nfavicon：网页的图标。会在标签页上显示。\n\n\n\n\nsharing：显示分享到社交网络图标。调用的是Bootstrap Icons图标库。效果如下：\n\n\n\n用户批注功能\nQuarto Books编译后的HTML网页支持配置Hypothesis标注功能。配置后不同的读者在登录Hypothesis账号后可以在页面上进行标注和评论。效果如下：\n\n\n---\nbook:\n  comments:\n    hypothesis:\n      theme: classic\n      openSidebar: false\n      showHighlights: always\n      enableExperimentalNewNoteButton: true\n---"
  },
  {
    "objectID": "quarto_foundation/quarto_books.html#format编译设置",
    "href": "quarto_foundation/quarto_books.html#format编译设置",
    "title": "31  Quarto Books",
    "section": "\n31.3 format编译设置",
    "text": "31.3 format编译设置\nformat定义了Quarto Books最终编译成的格式。Quarto Books可以编译成各种格式，如HTML、PDF、MS Word、EPub，或AsciiDoc。最常用和最好的编译格式是HTML。HTML books实际上是一种特殊类型的Quarto Website，因此支持包括全文搜索在内的网站功能。这两者最重要的一个区别是，HTML books能够使用章节编号，因此支持不同章节之间的交叉引用。因此下面只介绍编译成HTML的相关设置。\n\n---\nformat:\n  html:\n    theme:\n      light: Flatly \n      dark: darkly\n    embed-resources: false \n    code-tools: true\n    code-link: true\n    anchor-sections: true \n    link-external-newwindow: true \n    toc-depth: 3 \n    toc-expand: 1 \n---\n\n\ntheme：定义了编译文档的主题（详见： Section 27.3 ）。\nembed-resources：是否将所有源文件嵌入HTML文件以方便分享。默认为”false”。\ncode-tools：是否在网页右上角显示”&lt;code&gt;“按钮。点击该按钮可以看到Quarto文档的原始markdown代码。\ncode-link: 是否自动为函数加上超链接。该功能基于downlit包，可以自动为识别到的函数加上一个链接到官方文档的超链接。\nanchor-sections: 设置为true时，当鼠标移到各级标题上时会显示anchor link，方便我们复制直接定位到该标题的超链接。\nlink-external-icon：设置为true时会在外部链接上显示一个小图标。\nlink-external-newwindow：是否在新标签页打开外部链接。\ntoc：是否显示页内目录。对于HTML格式的Quarto Books，开启该选项后会在每个网页的右侧显示一个页面内的导航目录（ Section 31.2.5 ）。\ntoc-title：页内目录的标题。\ntoc-depth：设置页内目录显示的最低层级（默认为显示到3级标题）。\ntoc-expand：设置页内目录在一开始显示到多少级，默认显示到一级标题。当向下浏览内容时目录会自动展开到toc-depth所设置的层级。设置为true时，则在一开始就展开所有目录；设置为false则在一开始折叠所有目录。\ntoc-location：设置页内目录的位置。默认在右侧（right）,可以设置为left或body（在文稿最开头显示）。"
  },
  {
    "objectID": "quarto_foundation/quarto_books.html#代码块执行设置",
    "href": "quarto_foundation/quarto_books.html#代码块执行设置",
    "title": "31  Quarto Books",
    "section": "\n31.4 代码块执行设置",
    "text": "31.4 代码块执行设置\nexecute用来指定代码块的执行行为，例如是否运行、是否显示警告信息和是否缓存运行结果等。\n\n---\nexecute:\n  eval: true\n  warning: false\n  cache: true\n---\n\n\neval：设置为false时只显示代码，不运行。默认为true。\necho：设置为false时在输出文件中不显示代码，仅显示代码的运行结果。设置为fenced，会将代码块的设置，即”#|“符号后的内容，也展示出来。Figure 27.1 这个代码块就用了echo: fenced这个设定，可以看一下效果。默认为true。\noutput：设置为false时，只运行代码不显示运行结果。默认为true。\nwarning：是否显示代码运行的警告信息。默认为true。\ncache：是否开启运算结果缓存。默认为false。如果设置为true，就会在编译时将源代码的运算结果保存到文件目录中后缀为”_cache”的文件夹中。这样在重新编译同一个文档时会加快编译速度。"
  },
  {
    "objectID": "quarto_foundation/quarto_books.html#sec-number_sections",
    "href": "quarto_foundation/quarto_books.html#sec-number_sections",
    "title": "31  Quarto Books",
    "section": "\n31.5 标题编号设置",
    "text": "31.5 标题编号设置\n\n---\nnumber-sections: true \nnumber-depth: 2 \n---\n\n\nnumber-sections：设置为true时会给各级标题编号。默认为false。\nnumber-depth：编号的最低标题层级。默认给所有级别的标题编号。\n{.unnumbered}：如果想要某一个标题不编号，则把这行命令粘贴到该标题后面。如”第三章{.unnumbered}“。\n{.unlisted}：将某个标题设置为不在目录中列出。如”第三章{.unlisted}“。如果想要某个标题既不编号也不在目录中列出就可以这样写：”标题{.unnumbered .unlisted}“。"
  },
  {
    "objectID": "quarto_foundation/quarto_books.html#交叉引用设置",
    "href": "quarto_foundation/quarto_books.html#交叉引用设置",
    "title": "31  Quarto Books",
    "section": "\n31.6 交叉引用设置",
    "text": "31.6 交叉引用设置\n\n---\ncrossref:\n  appendix-title: \"附录\" \n  appendix-delim: \":\" \n  fig-title: 图    \n  tbl-title: 表    \n  fig-prefix: 图  \n  tbl-prefix: 表   \n  fig-labels: arabic   \n  tbl-labels: arabic   \n  subref-labels: alpha A \n---\n\n\nappendix-title: 附录的标签文字\nappendix-delim: 附录标签文字和附录标题的分隔符\nfig-title: 图的默认标签文字（默认是”Figure”）\ntbl-title: 表的默认标签文字（默认是”Table”）\ntitle-delim: 图、表标签文字和后面的图、表标题之间的连接符（默认是”:“）\nfig-prefix: 图的默认引用样式（默认是”Figure”）\ntbl-prefix: 表的默认引用样式（默认是”Table”）\nsec-prefix: 章节的默认引用样式（默认是”Section”）\nref-hyperlink: 是否为交叉引用加上内部链接（默认是”true”）\nfig-labels: 图片的编号类型（默认是阿拉伯数字：arabic)\ntbl-labels: 表格的编号类型（默认是阿拉伯数字：arabic）\nsubref-labels: 次级引用编号类型，如组图中的小图（默认是小写字母：alpha a）\n\n可用的编号类型包括：\n\narabic (1, 2, 3)\nroman (I, II, III, IV)\nroman i (i, ii, iii, iv)\nalpha x (start from letter ‘x’)\nalpha X (start from letter ‘X’)"
  },
  {
    "objectID": "quarto_foundation/quarto_books.html#排版设置",
    "href": "quarto_foundation/quarto_books.html#排版设置",
    "title": "31  Quarto Books",
    "section": "\n31.7 排版设置",
    "text": "31.7 排版设置\n\n---\nfig-cap-location: bottom\ntbl-cap-location: top\nreference-location: margin \ncitation-location: document \n---\n\n\n\nfig-cap-location：图片标题的位置。默认在图片底部（bottom）。\n\ntbl-cap-location：表格标题的位置。默认在表格上方（top）。\n\nreference-location：脚注的默认展示位置。默认为文档最后 (document)。\n\ncitation-location：参考文献的默认展示位置。默认为文档最后 (document)。\n\n\n\n\n\n\n\nOption\nDescription\n\n\n\nreference-location\nWhere to place footnotes. Defaults to document.\n[document | section | block | margin ]\n\n\ncitation-location\nWhere to place citations. Defaults to document.\n[document | margin ]\n\n\ncap-location\nWhere to place figure and table captions. Defaults to bottom for figures and top for tables. | [top | bottom | margin]\n\n\nfig-cap-location\nWhere to place figure captions. Defaults to bottom.\n[top | bottom | margin]\n\n\ntbl-cap-location\nWhere to place table captions. Defaults to top.\n[top | bottom | margin]"
  },
  {
    "objectID": "quarto_foundation/quarto_books.html#参考文献设置",
    "href": "quarto_foundation/quarto_books.html#参考文献设置",
    "title": "31  Quarto Books",
    "section": "\n31.8 参考文献设置",
    "text": "31.8 参考文献设置\n\n---\nbibliography: references.bib # 参考文献目录\n---\n\n只要在编辑qmd文档时插入了参考文献，YAML中会新增参考文献的配置选项：bibliography: references.bib。同时根目录下会生成一个名为”references.bib”的参考文献配置文件。该配置文件包括了qmd文档中所插入的所有参考文献的列表。以BibTeX/Citation风格语言编写。bibliography指定了这个参考文献配置文件所在的路径。\n\n\n\n\n\n\nTip\n\n\n\n关于Quarto Books的详细指南，参考：https://quarto.org/docs/books/book-structure.html。"
  },
  {
    "objectID": "quarto_foundation/quarto_books.html#附制作about-pages",
    "href": "quarto_foundation/quarto_books.html#附制作about-pages",
    "title": "31  Quarto Books",
    "section": "\n31.9 附：制作About Pages",
    "text": "31.9 附：制作About Pages\nindex.qmd文件会编译形成首页/封面文件（index.html），如果我们将书籍/网页发布（详见： Chapter 32 ），这是打开网站链接后首先看到的页面。我们可以通过Quarto提供的About Pages模板来快速创建一个美观的首页，其核心是about命令。下面是一个采用了About Pages模板的index.qmd文件的示例：\n\n---\ntitle: \"关于这本笔记\"\nsidebar: false # 关闭左侧栏\ntoc: false # 关闭右侧的页面目录\nnumber-sections: false # 取消对标题的编号\ncode-tools: false # 关闭代码工具\nabout:\n  template: trestles # 模板\n  image: images/book_cover.jpg # 封面图片\n  # 添加链接\n  links:\n    - icon: book-fill # 添加图标（https://icons.getbootstrap.com）\n      text: Bookdown # 图标的文字\n      href: https://bookdown.org # 图标的链接\n    - icon: github\n      text: Github\n      href: https://github.com/djhcod/r-notes\n    - text: Email\n      href: mailto::du.jh@icloud.com\n---\n\nFinley Malloc is the Chief Data Scientist at Wengo Analytics. When not innovating on data platforms, Finley enjoys spending time unicycling and playing with her pet iguana.\n\n------------------------------------------------------------------------ # 分割线\n\n## Education\n\nUniversity of California, San Diego \\| San Diego, CA PhD in Mathematics \\| Sept 2011 - June 2015\n\nMacalester College \\| St. Paul MA B.A in Economics \\| Sept 2007 - June 2011\n\n------------------------------------------------------------------------\n\n## Experience\n\nWengo Analytics \\| Head Data Scientist \\| April 2018 - present\n\nGeoScynce \\| Chief Analyst \\| Spet 2012 - April 2018\n\n\n\n\n\n\n\nNote\n\n\n\nmailto是一种特殊的超链接，其语法是mailto::youremail.com。点击mailto::后的邮箱地址之后会打开设备的邮件应用，并且自动填写邮箱地址。\n\n\n\n\n\n\n\n\nTip\n\n\n\n更多关于About Pages的技巧，参考：Creating your personal website using Quarto。"
  },
  {
    "objectID": "quarto_foundation/github_pages.html",
    "href": "quarto_foundation/github_pages.html",
    "title": "32  发布到GitHub Pages",
    "section": "",
    "text": "33 .gitignore在 Git 中忽略文件和文件夹\n如上面的@sec-将本地静态html文件发布到github-pages 所述，我们通过git add .命令将项目中的新文件或有变动的文件信息暂存到Git库，然后用git commit -m \"my commit message\"命令提交文件。其中git add后面跟的是需要提交的文件目录，这里我们用了”.”，表示把Git文件夹内的所有文件变动信息都记录下来。当继续使用git commit命令时，每一个文件都会被添加。但是，我们有时候不想将某些特定的文件或文件夹上传，或者某些文件超出了GitHub允许的单个文件容量上限（100MB），这个时候我们就需要通过新建一个.gitignore隐藏文件来告诉Git忽略和不要追踪某些特定文件。\n.gitignore文件是一个纯文本文件，里面列出我们要求Git忽略和不追踪的的文件的列表。在.gitignore中，可以通过提及特定文件或文件夹的名称或模式来告诉Git只忽略一个文件或一个文件夹。也可以用同样的方法告诉Git忽略多个文件或文件夹。\n通常，将.gitignore文件放在仓库的根目录下。我们可以通过命令行工具来创建一个.gitignore文件。要在基于 Unix 的系统（如 macOS 或 Linux）上用命令行创建一个.gitignore文件，打开终端程序（如 macOS 上的 Terminal.app）。然后，用cd命令导航到包含项目的根文件夹（或者通过RStudio打开.Rproject项目文件，然后打开RStudio内的终端面板）。然后输入以下命令：\ntouch .gitignore\n这和 Section 32.7 一样，不会返回任何信息，但是会在项目根目录中生成一个文件名为.gitignore的隐藏文件：\n我们用文本编辑工具或者RStudio打开这个文件。会发现里面已经有一些自动帮我们填好的文件列表："
  },
  {
    "objectID": "quarto_foundation/github_pages.html#注册github账户",
    "href": "quarto_foundation/github_pages.html#注册github账户",
    "title": "32  发布到GitHub Pages",
    "section": "\n32.1 注册GitHub账户",
    "text": "32.1 注册GitHub账户\n关于注册GitHub账户的详细指南，参考：https://happygitwithr.com/github-acct。"
  },
  {
    "objectID": "quarto_foundation/github_pages.html#安装git",
    "href": "quarto_foundation/github_pages.html#安装git",
    "title": "32  发布到GitHub Pages",
    "section": "\n32.2 安装Git",
    "text": "32.2 安装Git\n在终端APP或者RStudio的终端面板输入：\n\nwhich git\n\n如果返回”/usr/bin/git”，则表示Git已被安装到电脑上。如果返回”git: command not found”则表示Git未安装，则参阅《Happy Git and GitHub for the useR》进行安装。\n可以通过运行下面的命令进一步查看Git的版本：\n\ngit --version\n\n会返回”git version 2.39.3 (Apple Git-145)“这样的信息。"
  },
  {
    "objectID": "quarto_foundation/github_pages.html#配置git",
    "href": "quarto_foundation/github_pages.html#配置git",
    "title": "32  发布到GitHub Pages",
    "section": "\n32.3 配置Git",
    "text": "32.3 配置Git\n在终端（RStudio的终端面板或系统的终端）中逐个运行下面的命令，把其中的user.name和user.email替换成自己的用户名和GItHub账户的邮箱。这里的用户名不一定要和GitHub账户的的用户名一致，它会给本的Git仓库提供一个便于识别的标记。\n\ngit config --global user.name \"dujunhong\"\ngit config --global user.email \"du.jh@icloud.com\"\n\n或者，通过usethis包在R中进行配置：\n\nlibrary(usethis)\nuse_git_config(user.name = \"djhcod\", user.email = \"du.jh@icloud.com\")\n\n\n\n\n\n\n\nNote\n\n\n\nusethis is a package that facilitates interactive workflows for R project creation and development\n\n\n然后通过在终端中运行git config –global –list查看配好的Git信息。或者通过usethis包的git_sitrep函数查看：\n\nusethis::git_sitrep()"
  },
  {
    "objectID": "quarto_foundation/github_pages.html#获取github个人访问令牌personal-access-tokenpat",
    "href": "quarto_foundation/github_pages.html#获取github个人访问令牌personal-access-tokenpat",
    "title": "32  发布到GitHub Pages",
    "section": "\n32.4 获取GitHub个人访问令牌（personal access token，PAT）",
    "text": "32.4 获取GitHub个人访问令牌（personal access token，PAT）\nPAT相当于GitHub账户的密码，所以通过PAT才能让本地的Git仓库和远程的GitHub个人仓库建立连接。需要为每台想连接GitHub的电脑配置一个专属PAT。可以通过https://github.com/settings/tokens进行配置，或者运行下面的代码直接进入配置页面：\n\ncreate_github_token()\n\n在配置页面的”NOTE”中填写这个PAT的备注，建议写此PAT将要应用的设备的名称。在它的下方可以选择该PAT的到期时间：\n\n其他的设置保持默认，然后滑到页面最下方，点击”Generate token”：\n\n现在就会看到我们生成的PAT，记得把它即时复制下来，因为只要关闭了这个页面就无法再查看该密钥了：\n\n接下来，通过运行gitcreds包内的gitcreds_set函数来将PAT存储到本地：\n\ngitcreds::gitcreds_set()\n\n运行该函数后会在Console中要求我们输入token，输入刚刚获取的PAT密钥点击回车即可。\n\n如果此前已经存储了PAT，运行这个函数后会出现如下的对话框，可以选择更新已到期的PAT也可以查看已经存储的PAT。\n\n接下来我们再次运行git_sitrep函数，\n\nusethis::git_sitrep()\n\n如果看到如下红框内的信息，证明已经成功连接到了GitHub：\n\n\n\n\n\n\n\nNote\n\n\n\n更多关于PAT的获取指南，参考：https://ucsb-meds.github.io/meds-install-mac.html。"
  },
  {
    "objectID": "quarto_foundation/github_pages.html#将r-project文件夹初始化为git存储库",
    "href": "quarto_foundation/github_pages.html#将r-project文件夹初始化为git存储库",
    "title": "32  发布到GitHub Pages",
    "section": "\n32.5 将R Project文件夹初始化为Git存储库",
    "text": "32.5 将R Project文件夹初始化为Git存储库\n创建Quarto Books项目的内容参考 Chapter 31 。\n\n\n\n\n\n\nCaution\n\n\n\n项目文件夹的名称就是最终上传到GitHub库的名称，所以不要使用中文和空格，并起一个简单和有意义的名字。\n对于Quarto Books或者Quarto Websites项目，为了方便项目管理和GitHub Pages的转换应该在项目的YAML配置文件中将编译文件的输出文件夹设置为”docs”（ Chapter 31 ）：\nproject:\n  type: book\n  output-dir: \"book\" \n这样qmd文件编译后生成的HTML文件、脚本文件以及图片等文件都被存放在docs文件夹内。后面我们就可以指定GitHub Pages将这个docs文件夹作为构建网页的依据。\n\n\n\n通过运行use_git函数以将R Project文件夹初始化为Git存储库：\n\nusethis::use_git()\n\nConsole中会提示已经将当前项目文件夹设置为了Git存储库。当系统询问是否可以提交任何未提交的文件时，请选择是，则会将所有文件进行上传。如果要求重新启动R，请选择是。\n\n重启后，会看到RStudio的右下角窗格中出现了一个新的Git选项卡。里面列出了Git存储库，也就是我们的项目文件夹里面的所有文件，左侧用不同的颜色标注了文件的状态。\n\n这个函数的原理是在项目文件夹中生成了一个名为”.git”的隐藏文件夹，从而将其认定为Git本地存储库。在Mac上通过快捷键Command+Shift+句号可以显示/隐藏这些隐藏文件。\n\n\n\nGit存储库的结构"
  },
  {
    "objectID": "quarto_foundation/github_pages.html#连接本地git仓库和远程github仓库",
    "href": "quarto_foundation/github_pages.html#连接本地git仓库和远程github仓库",
    "title": "32  发布到GitHub Pages",
    "section": "\n32.6 连接本地Git仓库和远程GitHub仓库",
    "text": "32.6 连接本地Git仓库和远程GitHub仓库\n运行use_github函数后会首先创建一个项目同名的GitHub仓库，然后将所有本地Git库的文件上传到这个GitHub库中，完成后会自动打开浏览器并导航到建好的GitHub项目仓库。\n\nusethis::use_github()\n\n\n为了和GitHub统一，现在需要通过在RStusio的终端中运行下面的命令来检查一下当前项目的主分枝的名称是不是”main”。\n\ngit branch\n\n或者在RStudio中检查Git面板右上角的标签是不是”main”：\n\n同时，GitHub项目主页左上角的默认分枝也应该是”main”：\n\n如果是，则可以直接进入下一步。否则，如果当前分支的名称为”master”，需要通过运行git_default_branch_rename函数将默认分枝的名称更新为”main”。\n\nusethis::git_default_branch_rename(from = \"master\", to = \"main\")\n\n或者在终端中输入：\n\ngit config --global init.defaultBranch main\n\n然后通过git status再次检查默认分枝的名称，并回到GitHub项目主页刷新后查看默认分枝的名称是否已同步更改为”main”。"
  },
  {
    "objectID": "quarto_foundation/github_pages.html#sec-Publish_html_files_to_github_pages",
    "href": "quarto_foundation/github_pages.html#sec-Publish_html_files_to_github_pages",
    "title": "32  发布到GitHub Pages",
    "section": "\n32.7 将本地静态HTML文件发布到GitHub Pages",
    "text": "32.7 将本地静态HTML文件发布到GitHub Pages\n首先，在项目根目录中创建一个名为.nojekyll的文件，该文件告诉GitHub Pages不要使用Jekyll（GitHub默认网页生成工具）对我们的文件进行额外处理。有两种方法可以做到这一点：\n\n\n在RStudio终端中运行下面的命令：\n\ntouch .nojekyll\n\n该命令运行后不会有任何提示，但是在项目的根目录中会创建一个名为.nojekyll的隐藏文件：\n\n\n在RStudio中依次点击File&gt;New File&gt;Text File，然后点击保存，文件名写成”.nojekyll”即可。\n\n\n\n然后在Git面板中选中所有的文件（Git面板中列出的都是监测到有变动的文件）。这一操作等价于在终端输入：git add .。之后点击”Commit”（等价：git commit -m \"my commit message\"）。\n\n这会打开commit说明窗口，填写右侧的commit说明后点击右下角的”Commit”就会上传所有的文件更改。\n\n上传完成后关闭窗口，这时Git面板中不会有任何文件，是因为我们已经提交了所有更改。最后点击”Push”，就会把所有文件上传到GitHub仓库（等价：git push）。\n\n完成上述操作后，我们打开浏览器进入GitHub项目主页，点击设置按钮。\n\n点击左侧导航栏的”Pages”选项，然后将GitHub Pages的创建来源选择为docs文件夹。\n\n一段时间的等待后，我们就会在这个页面的上方看到已经生成的GitHub Pages的链接。\n\n点击进去之后就可以看到我们的在线网页了。\n\n\n\n\n\n\n\nWarning\n\n\n\n不要更改docs文件夹内的任何内容。\n不要更改index.qmd文件的名称。"
  },
  {
    "objectID": "references.html",
    "href": "references.html",
    "title": "References",
    "section": "",
    "text": "Blondel, Vincent D, Jean-Loup Guillaume, Renaud Lambiotte, and Etienne\nLefebvre. 2008. “Fast Unfolding of Communities in Large\nNetworks.” Journal of Statistical Mechanics: Theory and\nExperiment 2008 (10): P10008. https://doi.org/10.1088/1742-5468/2008/10/p10008.\n\n\nBrennecke, Philip, Simon Anders, Jong Kyoung Kim, Aleksandra A\nKołodziejczyk, Xiuwei Zhang, Valentina Proserpio, Bianka Baying, et al.\n2013. “Accounting for Technical Noise in Single-Cell RNA-Seq\nExperiments.” Nature Methods 10 (11): 1093–95. https://doi.org/10.1038/nmeth.2645.\n\n\nChoudhary, Saket, and Rahul Satija. 2022a. “Comparison and\nEvaluation of Statistical Error Models for scRNA-Seq.” Genome\nBiology 23 (1). https://doi.org/10.1186/s13059-021-02584-9.\n\n\n———. 2022b. “Comparison and Evaluation of Statistical Error Models\nfor scRNA-Seq.” Genome Biology 23 (1). https://doi.org/10.1186/s13059-021-02584-9.\n\n\n———. 2022c. “Comparison and Evaluation of Statistical Error Models\nfor scRNA-Seq.” Genome Biology 23 (1). https://doi.org/10.1186/s13059-021-02584-9.\n\n\nCrowell, Helena L., Charlotte Soneson, Pierre-Luc Germain, Daniela\nCalini, Ludovic Collin, Catarina Raposo, Dheeraj Malhotra, and Mark D.\nRobinson. 2020. “Muscat Detects Subpopulation-Specific State\nTransitions from Multi-Sample Multi-Condition Single-Cell\nTranscriptomics Data.” Nature Communications 11 (1). https://doi.org/10.1038/s41467-020-19894-4.\n\n\nDing, Jiarui, Xian Adiconis, Sean K. Simmons, Monika S. Kowalczyk,\nCynthia C. Hession, Nemanja D. Marjanovic, Travis K. Hughes, et al.\n2020. “Systematic Comparison of Single-Cell and Single-Nucleus\nRNA-Sequencing Methods.” Nature Biotechnology 38 (6):\n737–46. https://doi.org/10.1038/s41587-020-0465-8.\n\n\nFujii, Kouichi, Jin Kikuchi, Masatoshi Uchida, Masanari Machida, Midori\nTsuchiya, Kentaro Hayashi, Nana Maekawa, Hajime Houzumi, Arata Honda,\nand Koji Wake. 2023. “Tiger Attack at a Japanese Safari Park: A\nCase Report.” International Journal of Emergency\nMedicine 16 (1). https://doi.org/10.1186/s12245-023-00556-3.\n\n\nIlicic, Tomislav, Jong Kyoung Kim, Aleksandra A. Kolodziejczyk, Frederik\nOtzen Bagger, Davis James McCarthy, John C. Marioni, and Sarah A.\nTeichmann. 2016. “Classification of Low Quality Cells from\nSingle-Cell RNA-Seq Data.” Genome Biology 17 (1). https://doi.org/10.1186/s13059-016-0888-1.\n\n\nJunttila, Sini, Johannes Smolander, and Laura L Elo. 2022.\n“Benchmarking Methods for Detecting Differential States Between\nConditions from Multi-Subject Single-Cell RNA-Seq Data.”\nBriefings in Bioinformatics 23 (5). https://doi.org/10.1093/bib/bbac286.\n\n\nKang, Hyun Min, Meena Subramaniam, Sasha Targ, Michelle Nguyen, Lenka\nMaliskova, Elizabeth McCarthy, Eunice Wan, et al. 2017.\n“Multiplexed Droplet Single-Cell RNA-Sequencing Using Natural\nGenetic Variation.” Nature Biotechnology 36 (1): 89–94.\nhttps://doi.org/10.1038/nbt.4042.\n\n\nKorsunsky, Ilya, Nghia Millard, Jean Fan, Kamil Slowikowski, Fan Zhang,\nKevin Wei, Yuriy Baglaenko, Michael Brenner, Po-ru Loh, and Soumya\nRaychaudhuri. 2019. “Fast, Sensitive and Accurate Integration of\nSingle-Cell Data with Harmony.” Nature Methods 16 (12):\n1289–96. https://doi.org/10.1038/s41592-019-0619-0.\n\n\nLause, Jan, Philipp Berens, and Dmitry Kobak. 2021. “Analytic\nPearson Residuals for Normalization of Single-Cell RNA-Seq UMI\nData.” Genome Biology 22 (1). https://doi.org/10.1186/s13059-021-02451-7.\n\n\nLevine, Jacob H., Erin F. Simonds, Sean C. Bendall, Kara L. Davis,\nEl-ad D. Amir, Michelle D. Tadmor, Oren Litvin, et al. 2015.\n“Data-Driven Phenotypic Dissection of AML Reveals Progenitor-Like\nCells That Correlate with Prognosis.” Cell 162 (1):\n184–97. https://doi.org/10.1016/j.cell.2015.05.047.\n\n\nLuecken, Malte D., M. Büttner, K. Chaichoompu, A. Danese, M. Interlandi,\nM. F. Mueller, D. C. Strobl, et al. 2021. “Benchmarking\nAtlas-Level Data Integration in Single-Cell Genomics.” Nature\nMethods 19 (1): 41–50. https://doi.org/10.1038/s41592-021-01336-8.\n\n\nMacosko, Evan Z., Anindita Basu, Rahul Satija, James Nemesh, Karthik\nShekhar, Melissa Goldman, Itay Tirosh, et al. 2015a. “Highly\nParallel Genome-Wide Expression Profiling of Individual Cells Using\nNanoliter Droplets.” Cell 161 (5): 1202–14. https://doi.org/10.1016/j.cell.2015.05.002.\n\n\n———, et al. 2015b. “Highly Parallel Genome-Wide Expression\nProfiling of Individual Cells Using Nanoliter Droplets.”\nCell 161 (5): 1202–14. https://doi.org/10.1016/j.cell.2015.05.002.\n\n\nNestorowa, Sonia, Fiona K. Hamey, Blanca Pijuan Sala, Evangelia\nDiamanti, Mairi Shepherd, Elisa Laurenti, Nicola K. Wilson, David G.\nKent, and Berthold Göttgens. 2016. “A Single-Cell Resolution Map\nof Mouse Hematopoietic Stem and Progenitor Cell Differentiation.”\nBlood 128 (8): e20–31. https://doi.org/10.1182/blood-2016-05-716480.\n\n\nSprumont, Adrien, Ana Rodrigues, Simon J. McGowan, Colin Bannard, and\nOliver Bannard. 2023. “Germinal Centers Output Clonally Diverse\nPlasma Cell Populations Expressing High- and Low-Affinity\nAntibodies.” Cell, November. https://doi.org/10.1016/j.cell.2023.10.022.\n\n\nSquair, Jordan W., Matthieu Gautier, Claudia Kathe, Mark A. Anderson,\nNicholas D. James, Thomas H. Hutson, Rémi Hudelle, et al. 2021.\n“Confronting False Discoveries in Single-Cell Differential\nExpression.” Nature Communications 12 (1). https://doi.org/10.1038/s41467-021-25960-2.\n\n\nStuart, Tim, Andrew Butler, Paul Hoffman, Christoph Hafemeister,\nEfthymia Papalexi, William M. Mauck, Yuhan Hao, Marlon Stoeckius, Peter\nSmibert, and Rahul Satija. 2019a. “Comprehensive Integration of\nSingle-Cell Data.” Cell 177 (7): 1888–1902.e21. https://doi.org/10.1016/j.cell.2019.05.031.\n\n\n———. 2019b. “Comprehensive Integration of Single-Cell\nData.” Cell 177 (7): 1888–1902.e21. https://doi.org/10.1016/j.cell.2019.05.031.\n\n\nTirosh, Itay, Benjamin Izar, Sanjay M. Prakadan, Marc H. Wadsworth,\nDaniel Treacy, John J. Trombetta, Asaf Rotem, et al. 2016.\n“Dissecting the Multicellular Ecosystem of Metastatic Melanoma by\nSingle-Cell RNA-Seq.” Science 352 (6282): 189–96. https://doi.org/10.1126/science.aad0501.\n\n\nTran, Hoa Thi Nhu, Kok Siong Ang, Marion Chevrier, Xiaomeng Zhang,\nNicole Yee Shin Lee, Michelle Goh, and Jinmiao Chen. 2020. “A\nBenchmark of Batch-Effect Correction Methods for Single-Cell RNA\nSequencing Data.” Genome Biology 21 (1). https://doi.org/10.1186/s13059-019-1850-9.\n\n\nZimmerman, Kip D., Mark A. Espeland, and Carl D. Langefeld. 2021.\n“A Practical Solution to Pseudoreplication Bias in Single-Cell\nStudies.” Nature Communications 12 (1). https://doi.org/10.1038/s41467-021-21038-1."
  }
]