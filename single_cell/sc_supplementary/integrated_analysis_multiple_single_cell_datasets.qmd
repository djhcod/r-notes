---
title: "多个单细胞数据集整合分析"
---

> 参考：[单细胞多数据集整合示例](https://mp.weixin.qq.com/s/51PtUi7ZKp1nbrFGElU74A)

有时候，为了扩大数据量和得到更加可靠的结论，我们可能获取和下载了多个单细胞数据集。如果我们只关注某一细胞类型，如T cells或B cells或髓系细胞，那么就需要合并分析这些数据集，提取感兴趣的细胞亚群。这时候有两种方法可以选择：

-   **对各个数据集分别降维分群，然后提取各个数据集的感兴趣细胞亚群并整合到一起**

-   **在一开始分析的时候就对这些数据集进行整合，然后分群，提起感兴趣细胞群**

**这个部分怎么分析并没有一个特定的答案或者规则，具体还是得看数据集适合以上提出的哪种分析顺序。**

例如[@gong2023]就用了第二种方法。选取了三个鼻咽癌单细胞转录组数据： GSE150825, GSE150430, GSE162025。首先对三组数据进行整合，然后选取其中的一部分T细胞进行进一步分析。

![](images/截屏2024-01-10%2012.00.48.png){width="600"}

这里我们介绍第一种方式，即**对各数据集分别降维分群，然后提取并整合各个数据集的感兴趣细胞亚群。**

## 加载包

```{r}
library(Seurat)
library(ggplot2)
library(beepr)
library(cowplot)
library(dplyr)
library(clustree)
```

## GSE150430

这里我们直接载入 @sec-reading_non_standard_large_volume_text 中构建好的Seurat对象，该案例数据的介绍及读取过程参见该章节。

### 数据导入

```{r}
merged_seurat <- readRDS("output/sc_supplementary/GSE150430_merged_seurat.rds")
merged_seurat
head(merged_seurat, 4)
unique(merged_seurat$samples)
```

### 质控

```{r}
#| fig-width: 3
# Add number of genes per UMI for each cell to metadata
merged_seurat$log10GenesPerUMI <- log10(merged_seurat$nFeature_RNA) / log10(merged_seurat$nCount_RNA)
summary(merged_seurat$log10GenesPerUMI)

# Compute percent mito ratio
merged_seurat$mitoRatio <- PercentageFeatureSet(object = merged_seurat, 
                                                pattern = "^MT-")
merged_seurat$mitoRatio <- merged_seurat$mitoRatio / 100
summary(merged_seurat$mitoRatio)
boxplot(merged_seurat$mitoRatio)

# Add cell IDs to metadata
merged_seurat$cells <- rownames(merged_seurat@meta.data)
```

```{r}
#| layout-ncol: 2
# Visualize the number of cell counts per sample
merged_seurat@meta.data  |> 
    ggplot(aes(x = samples, fill = samples)) + 
    geom_bar() +
    theme_classic() +
    theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust = 1)) +
    theme(plot.title = element_text(hjust = 0.5, face = "bold")) +
    ggtitle("NCells")

# Visualize the number UMIs/transcripts per cell
merged_seurat@meta.data |> 
    ggplot(aes(color = samples, x = nCount_RNA, fill = samples)) + 
    geom_density(alpha = 0.2) + 
    scale_x_log10() + 
    theme_classic() +
    ylab("Cell density") +
    geom_vline(xintercept = 500)

# Visualize the distribution of genes detected per cell via histogram
merged_seurat@meta.data |>
    ggplot(aes(color = samples, x = nFeature_RNA, fill= samples)) + 
    geom_density(alpha = 0.2) + 
    theme_classic() +
    scale_x_log10() + 
    geom_vline(xintercept = 200)

# Visualize the overall complexity of the gene expression by visualizing the genes detected per UMI (novelty score)
merged_seurat@meta.data |>
    ggplot(aes(x = log10GenesPerUMI, color = samples, fill=samples)) +
    geom_density(alpha = 0.2) +
    theme_classic() +
    geom_vline(xintercept = 0.8)

# Visualize the distribution of mitochondrial gene expression detected per cell
merged_seurat@meta.data |>
    ggplot(aes(color = samples, x = mitoRatio, fill = samples)) + 
    geom_density(alpha = 0.2) + 
    scale_x_log10() + 
    theme_classic() +
    geom_vline(xintercept = 0.2)
```

```{r}
#| fig-width: 10
#| fig-height: 10
# Visualize the correlation between genes detected and number of UMIs and determine whether strong presence of cells with low numbers of genes/UMIs
merged_seurat@meta.data |> 
    ggplot(aes(x = nCount_RNA, y = nFeature_RNA, color = mitoRatio)) + 
    geom_point() + 
    scale_colour_gradient(low = "gray90", high = "black") +
    stat_smooth(method = lm) +
    scale_x_log10() + 
    scale_y_log10() + 
    theme_classic() +
    geom_vline(xintercept = 500) +
    geom_hline(yintercept = 250) +
    facet_wrap(~samples)
```

可以看到该数据集已经进行了质控，各项指标均在正常范围内，因此，我们可以跳过细胞/基因过滤，直接进入下面的环节。

### 归一化及消除非期望变异来源

::: callout-caution
由于这里`SCTransform`的数据量太大，在我的16GB MacBook Pro上超出了R内存分配上限，出现了“Error: vector memory exhausted (limit reached?)”报错。因此，这里在运行下面的脚本之前通过 @sec-Raising_memory_limit 的方法进行了处理。
:::

```{r}
#| cache-lazy: false
# SCTranform
merged_seurat <- SCTransform(merged_seurat, verbose = FALSE); beep()
gc() # 释放未使用内存
merged_seurat

# Check which assays are stored in objects
merged_seurat@assays
# 查看目前默认的assay
DefaultAssay(merged_seurat)
# 查看默认assay的layers
Layers(merged_seurat)
```

#### 评估细胞周期的影响

```{r}
#| cache-lazy: false
#| fig-width: 10
# Load cell cycle markers
s.genes <- cc.genes$s.genes
g2m.genes <- cc.genes$g2m.genes

# Score cells for cell cycle
merged_seurat <- CellCycleScoring(merged_seurat, 
                                  g2m.features = g2m.genes, 
                                  s.features = s.genes)

# 现在的meta.data中多出了细胞周期评分“S.Score”和“G2M.Score”，以及推断的细胞所处的周期“Phase”
head(merged_seurat@meta.data)
# 查看一下细胞周期的分布情况
table(merged_seurat$Phase)

# 执行PCA
merged_seurat <- RunPCA(merged_seurat)

# Plot the PCA colored by cell cycle phase
p1 <- DimPlot(merged_seurat,
              reduction = "pca",
              group.by= "Phase")
p2 <- DimPlot(merged_seurat,
              reduction = "pca",
              group.by= "Phase",
              split.by = "Phase")
plot_grid(p1, p2, ncol = 2, labels = "AUTO")
```

可以看到细胞周期不是变异来源。

#### **评估线粒体基因的影响**

```{r}
#| cache-lazy: false
#| fig-width: 3
#| fig-height: 3
# Check quartile values
mito_sum <- summary(merged_seurat$mitoRatio)
mito_sum

# Turn mitoRatio into categorical factor vector based on quartile values
merged_seurat$mitoFr <- cut(merged_seurat$mitoRatio, 
                            breaks=c(-Inf, mito_sum[2], mito_sum[3], mito_sum[5], Inf),
                            labels=c("Low", "Medium", "Medium high", "High"))
plot(merged_seurat$mitoFr)
```

```{r}
#| cache-lazy: false
#| fig-width: 15
# Plot the PCA colored by cell cycle phase
p1 <- DimPlot(merged_seurat,
              reduction = "pca",
              group.by= "mitoFr")
p2 <- DimPlot(merged_seurat,
              reduction = "pca",
              group.by= "mitoFr",
              split.by = "mitoFr")
plot_grid(p1, p2, ncol = 2, labels = "AUTO")
```

可以看到线粒体基因比例不是变异来源。

由于细胞周期和线粒体基因比例都不是非期望变异来源，所以我们这里不需要再次运行SCTransform来回归这些变量。接下来，直接进入数据整合环节。

### 数据整合

#### **不进行整合时检验细胞分群情况**

```{r}
#| cache-lazy: false
#| fig-width: 15
#| fig-height: 15
# 查看降维信息
names(merged_seurat@reductions)

# Run UMAP
merged_seurat <- RunUMAP(merged_seurat, 
                         dims = 1:40, 
                         reduction = "pca",
                         reduction.name = "umap.unintegrated"); beep()

# 分群
# Determine the K-nearest neighbor graph
merged_seurat <- FindNeighbors(merged_seurat, 
                               dims = 1:40, 
                               reduction = "pca")
merged_seurat <- FindClusters(merged_seurat, 
                              cluster.name = "unintegrated_clusters")

# Plot UMAP
p1 <- DimPlot(merged_seurat, 
              reduction = "umap.unintegrated",
              group.by = "samples")
p2 <- DimPlot(merged_seurat, 
              reduction = "umap.unintegrated",
              split.by = "samples")
plot_grid(p1, p2, 
          ncol = 1, labels = "AUTO")

# 由于样本数较多，我们再按照样本类型“Normal” vs. “Cancer”画一下UMAP图
merged_seurat$groups <- ifelse(merged_seurat$samples == "N01", "Normal", "Cancer")
p1a <- DimPlot(merged_seurat, 
               reduction = "umap.unintegrated",
               group.by = "groups")
p2a <- DimPlot(merged_seurat, 
               reduction = "umap.unintegrated",
               split.by = "groups")
plot_grid(p1a, p2a, 
          ncol = 1, labels = "AUTO")
```

#### 整合

这里我们用Harmony整合算法。

```{r}
#| cache-lazy: false
# 整合，比较耗时间，进度条会一直显示0%直至运算完成
seurat_integrated <- IntegrateLayers(object = merged_seurat,
                                     method = HarmonyIntegration,
                                     assay = "SCT", # Integrating SCTransformed data
                                     orig.reduction = "pca",
                                     verbose = FALSE); beep()


# 整合后合并RNA layer
seurat_integrated[["RNA"]] <- JoinLayers(seurat_integrated[["RNA"]])

# 查看整合后的降维信息
names(seurat_integrated@reductions)
```

#### **整合后检验细胞分群情况**

```{r}
#| cache-lazy: false
#| fig-width: 10
#| fig-height: 20
set.seed(123456)
# Run UMAP
seurat_integrated <- RunUMAP(seurat_integrated, 
                             dims = 1:40,
                             reduction = "harmony", # 更改降维来源为整合后的"harmony"
                             reduction.name = "umap.integrated"); beep()
names(seurat_integrated@reductions)

# 分群
seurat_integrated <- FindNeighbors(seurat_integrated, 
                                   dims = 1:40, 
                                   reduction = "harmony") #更改降维来源为"harmony"
seurat_integrated <- FindClusters(seurat_integrated, 
                                  cluster.name = "integrated_clusters")
colnames(seurat_integrated@meta.data)

# Plot UMAP                             
p3 <- DimPlot(seurat_integrated, 
              reduction = "umap.integrated", 
              group.by = "samples")
p4 <- DimPlot(seurat_integrated, 
              reduction = "umap.integrated", 
              split.by = "samples")
plot_grid(p1, p3, p2, p4, 
          ncol = 1, 
          labels = c("Before Harmony", "After Harmony", 
                     "Before Harmony", "After Harmony"))

# 保存
saveRDS(seurat_integrated, 
        file = "output/sc_supplementary/GSE150430_seurat_integrated.RDS"); beep()
```

------------------------------------------------------------------------

### 聚类

```{r}
#| cache-lazy: false
rm(list = ls())
gc()

seurat_integrated <- readRDS("output/sc_supplementary/GSE150430_seurat_integrated.RDS")
```

```{r}
#| cache-lazy: false
# Determine the clusters for various resolutions                                
seurat_integrated <- FindClusters(seurat_integrated,
                                  resolution = c(0.01, 0.05, 0.1, 0.2, 0.3, 0.4, 0.5, 0.8, 1),
                                  verbose = F); beep()
# Explore resolutions
head(seurat_integrated@meta.data, 5)
# 查看各个分辨率下的细胞分群情况
select(seurat_integrated@meta.data, starts_with(match = "SCT_snn_res.")) %>%  
  lapply(levels)
```

绘制聚类树展示不同分辨率下的细胞分群情况及相互关系

```{r}
#| cache-lazy: false
#| fig-width: 10
tree <- clustree(seurat_integrated@meta.data, 
                 prefix = "SCT_snn_res.")#指定包含聚类信息的列
tree
```

通常情况下，为了决定合适的聚类分辨率，可使用以下两种策略：

1.  选择透明箭头出现较少的分辨率聚类结果

2.  基于marker基因表达选择有生物学意义的分辨率聚类结果

接下来分析，按照分辨率为0.5进行

```{r}
#| cache-lazy: false
Idents(seurat_integrated) <- "SCT_snn_res.0.5"
```

聚类可视化

```{r}
#| cache-lazy: false
# Plot the UMAP
DimPlot(seurat_integrated,
        reduction = "umap.integrated",
        label = FALSE)
```

### **细胞分群质量评估**

#### **分析样本类型是否影响细胞分群**

```{r}
#| cache-lazy: false
# 先简单查看不同cluster的细胞数
table(seurat_integrated@active.ident)

# 查看不同样本类型中的细胞分群情况
DimPlot(seurat_integrated, 
        reduction = "umap.integrated",
        label = TRUE, 
        split.by = "groups") + 
  NoLegend()
```

#### **分析细胞周期是否影响细胞分群**

```{r}
#| cache-lazy: false
# Explore whether clusters segregate by cell cycle phase
DimPlot(seurat_integrated,
        reduction = "umap.integrated",
        label = TRUE, 
        split.by = "Phase") + 
  NoLegend()
```

#### **分析其他非期望变异来源是否会影响细胞分群**

```{r}
#| cache-lazy: false
#| fig-width: 10
# Determine metrics to plot present in seurat_clustered@meta.data
metrics <-  c("nCount_RNA", "nFeature_RNA", "S.Score", "G2M.Score", "mitoRatio")

FeaturePlot(seurat_integrated, 
            reduction = "umap.integrated", 
            features = metrics,
            pt.size = 0.4, 
            order = TRUE,
            min.cutoff = 'q10', 
            label = TRUE)
```

保存

```{r}
#| cache-lazy: false
saveRDS(seurat_integrated, 
        file = "output/sc_supplementary/GSE150430_seurat_clustered.RDS"); beep()
```

------------------------------------------------------------------------

### 细胞注释

#### **探索cell type markers的表达**

这里的marker基因选用 @sec-Universal_Marker_for_initial_Cell_clustering 中的细胞初步分群通用marker。

```{r}
#| cache-lazy: false
#| fig-width: 8
#| fig-height: 8
rm(list = ls())
gc()
seurat_clustered <- readRDS("output/sc_supplementary/GSE150430_seurat_clustered.RDS")

genes_to_check = c('PTPRC', 
                   "CD163","AIF1", 
                   'CD3D', 'CD3E', 'CD4', 'CD8A', 
                   'CD19', 'CD79A', 'MS4A1', "SDC1", "CD27", "CD38",
                   'IGHG1', 'MZB1', 'SDC1', "JCHAIN", 
                   'CD68', 'CD163', 'CD14', 
                   'S100A9', 'S100A8', 'MMP19',
                   'C1QA',  'C1QB', 
                   'TPSAB1', 'TPSB2', 
                   'KLRB1', "KLRD1", 'NCR1', "GNLY", "NKG7", 
                   'FGF7', 'MME', 'ACTA2', "COL3A1", 
                   'PECAM1', 'VWF', 
                   'EPCAM', 'KRT19', 'PROM1', 'ALDH1A1') |> unique()

DotPlot(seurat_clustered, 
        features = genes_to_check) + 
  coord_flip()
```

#### 手动注释

```{r}
#| cache-lazy: false
seurat_clustered <- RenameIdents(seurat_clustered, 
                                 "0" = "B cells",
                                 "1" = "T cells",
                                 "2" = "Epithelial/cancer",
                                 "3" = "T cells",
                                 "4" = "T cells",
                                 "5" = "Macrophages",
                                 "6" = "T cells",
                                 "7" = "Plasma cells",
                                 "8" = "B cells",
                                 "9" = "Epithelial/cancer",
                                 "10" = "B cells",
                                 "11" = "B cells",
                                 "12" = "Unknown",
                                 "13" = "NK cells",
                                 "14" = "Unknown",
                                 "15" = "Epithelial/cancer",
                                 "16" = "Myeloid (unspecific)",
                                 "17" = "Epithelial/cancer",
                                 "18" = "Epithelial/cancer",
                                 "19" = "Epithelial/cancer",
                                 "20" = "B cells")
table(Idents(seurat_clustered))

# Plot the UMAP
DimPlot(seurat_clustered, 
        reduction = "umap.integrated", 
        label = T)
```

在注释好的数据中再次检查marker基因的表达情况：

```{r}
#| cache-lazy: false
#| fig-width: 8
#| fig-height: 10
DotPlot(seurat_clustered, 
        features = genes_to_check) + 
  coord_flip() +
  theme(axis.text.x = element_text(angle = 30,vjust = 0.85,hjust = 0.75)
) 
```

因为接下来我们要提取髓系细胞进一步分析，所以通过几种可视化方法检查一下髓系细胞通用marker（CD163和AIF1）的表达情况：

```{r}
#| cache-lazy: false
#| fig-height: 8
RidgePlot(seurat_clustered, features = c("CD163", "AIF1"), ncol = 1)
```

```{r}
#| cache-lazy: false
VlnPlot(seurat_clustered, features = c("CD163", "AIF1"))
```

```{r}
#| cache-lazy: false
#| fig-width: 8
FeaturePlot(seurat_clustered, features = c("CD163", "AIF1"), label = T)
```

保存

```{r}
#| cache-lazy: false
saveRDS(seurat_clustered, 
        file = "output/sc_supplementary/GSE150430_seurat_annotated.RDS"); beep()
```

### 提取髓系细胞

```{r}
#| cache-lazy: false
sub_seurat <- subset(seurat_clustered, 
                     idents = c("Macrophages", 
                                "Myeloid (unspecific)"))
sub_seurat
colnames(sub_seurat@meta.data)
myeloid_seurat <- CreateSeuratObject(counts = sub_seurat@assays[["RNA"]],
                                     meta.data = sub_seurat@meta.data[,c(1:7, 10:13, 16)])
myeloid_seurat
```

::: callout-warning
可以看到在重新创建Seurat之后，默认的“RNA” assay之中只有一个layer。为了后面执行`SCTransform`及整合，**这里需要将其按照样本拆分成不同的layers**。

```{r}
#| cache-lazy: false
myeloid_seurat[["RNA"]] <- split(myeloid_seurat[["RNA"]], 
                                 f = myeloid_seurat$samples)
myeloid_seurat
```
:::

```{r}
#| cache-lazy: false
# 补充原细胞注释信息
myeloid_seurat$old_clusters <- Idents(sub_seurat)
table(myeloid_seurat$old_clusters)

# 保存
saveRDS(myeloid_seurat, file = "output/sc_supplementary/GSE150430_myeloid_seurat.RDS")
```

------------------------------------------------------------------------

### 髓系细胞进一步归一化、整合、降维、分群

#### SCTransform、PCA

```{r}
rm(list = ls())
gc()

myeloid_seurat <- readRDS("output/sc_supplementary/GSE150430_myeloid_seurat.RDS")

# SCTranform
myeloid_seurat <- SCTransform(myeloid_seurat, verbose = FALSE)
myeloid_seurat

# Check which assays are stored in objects
myeloid_seurat@assays
# 查看目前默认的assay
DefaultAssay(myeloid_seurat)
# 查看默认assay的layers
Layers(myeloid_seurat)

# 执行PCA
myeloid_seurat <- RunPCA(myeloid_seurat)
```

#### 不进行整合时检查细胞分群情况：

```{r}
#| fig-height: 15
#| fig-width: 10
# 查看降维信息
names(myeloid_seurat@reductions)

# Run UMAP
myeloid_seurat <- RunUMAP(myeloid_seurat, 
                          dims = 1:40, 
                          reduction = "pca",
                          reduction.name = "umap.unintegrated")

# 分群
# Determine the K-nearest neighbor graph
myeloid_seurat <- FindNeighbors(myeloid_seurat, 
                                dims = 1:40, 
                                reduction = "pca")
myeloid_seurat <- FindClusters(myeloid_seurat, 
                               cluster.name = "unintegrated_clusters")

# Plot UMAP
p1 <- DimPlot(myeloid_seurat, 
              reduction = "umap.unintegrated",
              group.by = "samples")
p2 <- DimPlot(myeloid_seurat, 
              reduction = "umap.unintegrated",
              split.by = "samples")
plot_grid(p1, p2, 
          ncol = 1, labels = "AUTO")
```

#### 整合

```{r}
# 整合
myeloid_integrated <- IntegrateLayers(object = myeloid_seurat,
                                      method = HarmonyIntegration,
                                      verbose = FALSE)


# 整合后合并RNA layer
myeloid_integrated[["RNA"]] <- JoinLayers(myeloid_integrated[["RNA"]])

# 查看整合后的降维信息
names(myeloid_integrated@reductions)
```

#### **整合后检验细胞分群情况**

```{r}
#| fig-width: 10
#| fig-height: 15
set.seed(123456)
# Run UMAP
myeloid_integrated <- RunUMAP(myeloid_integrated, 
                              dims = 1:40,
                              reduction = "harmony", # 更改降维来源为整合后的"harmony"
                              reduction.name = "umap.integrated")
names(myeloid_integrated@reductions)

# 分群
myeloid_integrated <- FindNeighbors(myeloid_integrated, 
                                    dims = 1:40, 
                                    reduction = "harmony") #更改降维来源为"harmony"
myeloid_integrated <- FindClusters(myeloid_integrated, 
                                   cluster.name = "integrated_clusters")
colnames(myeloid_integrated@meta.data)

# Plot UMAP                             
p3 <- DimPlot(myeloid_integrated, 
              reduction = "umap.integrated", 
              group.by = "samples")
p4 <- DimPlot(myeloid_integrated, 
              reduction = "umap.integrated", 
              split.by = "samples")
plot_grid(p1, p3, p2, p4, 
          ncol = 1, 
          labels = c("Before Harmony", "After Harmony", 
                     "Before Harmony", "After Harmony"))
```

#### 聚类

```{r}
# Determine the clusters for various resolutions                                
myeloid_integrated <- FindClusters(myeloid_integrated,
                                   resolution = c(0.01, 0.05, 0.1, 0.2, 0.3, 
                                                  0.4, 0.5, 0.8, 1),
                                   verbose = F)
# Explore resolutions
head(myeloid_integrated@meta.data, 5)
# 查看各个分辨率下的细胞分群情况
select(myeloid_integrated@meta.data, 
       starts_with(match = "SCT_snn_res.")) %>%  
  lapply(levels)
```

绘制聚类树展示不同分辨率下的细胞分群情况及相互关系

```{r}
tree <- clustree(myeloid_integrated@meta.data, 
                 prefix = "SCT_snn_res.") # 指定包含聚类信息的列
tree
```

这里，选取分辨为0.2

```{r}
Idents(myeloid_integrated) <- "SCT_snn_res.0.2"
```

聚类可视化

```{r}
# Plot the UMAP
DimPlot(myeloid_integrated,
        reduction = "umap.integrated",
        label = FALSE)
```

#### **细胞分群质量评估**

分析样本类型是否影响细胞分群

```{r}
# 先简单查看不同cluster的细胞数
table(myeloid_integrated@active.ident)

# 查看不同样本类型中的细胞分群情况
DimPlot(myeloid_integrated, 
        reduction = "umap.integrated",
        label = TRUE, 
        split.by = "groups") + 
  NoLegend()
```

分析细胞周期是否影响细胞分群

```{r}
# Explore whether clusters segregate by cell cycle phase
DimPlot(myeloid_integrated,
        reduction = "umap.integrated",
        label = TRUE, 
        split.by = "Phase") + 
  NoLegend()
```

分析其他非期望变异来源是否会影响细胞分群

```{r}
#| fig-width: 10
#| fig-height: 10
# Determine metrics to plot present in seurat_clustered@meta.data
metrics <-  c("nCount_RNA", "nFeature_RNA", "S.Score", "G2M.Score", "mitoRatio")

FeaturePlot(myeloid_integrated, 
            reduction = "umap.integrated", 
            features = metrics,
            pt.size = 0.4, 
            order = TRUE,
            min.cutoff = 'q10', 
            label = TRUE)
```

保存

```{r}
saveRDS(myeloid_integrated, 
        file = "output/sc_supplementary/GSE150430_myeloid_clustered.RDS")
```

#### 亚群细胞注释

```{r}

```
