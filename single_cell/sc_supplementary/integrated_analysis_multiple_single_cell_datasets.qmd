---
title: "多个单细胞数据集整合分析"
---

> 参考：[单细胞多数据集整合示例](https://mp.weixin.qq.com/s/51PtUi7ZKp1nbrFGElU74A)

有时候，为了扩大数据量和得到更加可靠的结论，我们可能获取和下载了多个单细胞数据集。如果我们只关注某一细胞类型，如T cells或B cells或髓系细胞，那么就需要合并分析这些数据集，提取感兴趣的细胞亚群。这时候有两种方法可以选择：

-   **对各个数据集分别降维分群，然后提取各个数据集的感兴趣细胞亚群并整合到一起**

-   **在一开始分析的时候就对这些数据集进行整合，然后分群，提起感兴趣细胞群**

**这个部分怎么分析并没有一个特定的答案或者规则，具体还是得看数据集适合以上提出的哪种分析顺序。**

例如[@gong2023]就用了第二种方法。选取了三个鼻咽癌单细胞转录组数据： GSE150825, GSE150430, GSE162025。首先对三组数据进行整合，然后选取其中的一部分T细胞进行进一步分析。

![](images/截屏2024-01-10%2012.00.48.png){width="600"}

这里我们介绍第一种方式，即**对各数据集分别降维分群，然后提取并整合各个数据集的感兴趣细胞亚群。**

## 加载包

```{r}
library(Seurat)
library(ggplot2)
library(beepr)
library(cowplot)
```

## GSE150430

这里我们直接载入 @sec-reading_non_standard_large_volume_text 中构建好的Seurat对象，该案例数据的介绍及读取过程参见该章节。

### 数据导入

```{r}
merged_seurat_1 <- readRDS("output/sc_supplementary/GSE150430_merged_seurat.rds")
merged_seurat_1
head(merged_seurat_1, 4)
unique(merged_seurat_1$samples)
```

### 质控

```{r}
#| fig-width: 3
# Add number of genes per UMI for each cell to metadata
merged_seurat_1$log10GenesPerUMI <- log10(merged_seurat_1$nFeature_RNA) / log10(merged_seurat_1$nCount_RNA)
summary(merged_seurat_1$log10GenesPerUMI)

# Compute percent mito ratio
merged_seurat_1$mitoRatio <- PercentageFeatureSet(object = merged_seurat_1, 
                                                  pattern = "^MT-")
merged_seurat_1$mitoRatio <- merged_seurat_1$mitoRatio / 100
summary(merged_seurat_1$mitoRatio)
boxplot(merged_seurat_1$mitoRatio)

# Add cell IDs to metadata
merged_seurat_1$cells <- rownames(merged_seurat_1@meta.data)
```

```{r}
#| layout-ncol: 2
# Visualize the number of cell counts per sample
merged_seurat_1@meta.data  |> 
    ggplot(aes(x = samples, fill = samples)) + 
    geom_bar() +
    theme_classic() +
    theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust = 1)) +
    theme(plot.title = element_text(hjust = 0.5, face = "bold")) +
    ggtitle("NCells")

# Visualize the number UMIs/transcripts per cell
merged_seurat_1@meta.data |> 
    ggplot(aes(color = samples, x = nCount_RNA, fill = samples)) + 
    geom_density(alpha = 0.2) + 
    scale_x_log10() + 
    theme_classic() +
    ylab("Cell density") +
    geom_vline(xintercept = 500)

# Visualize the distribution of genes detected per cell via histogram
merged_seurat_1@meta.data |>
    ggplot(aes(color = samples, x = nFeature_RNA, fill= samples)) + 
    geom_density(alpha = 0.2) + 
    theme_classic() +
    scale_x_log10() + 
    geom_vline(xintercept = 200)

# Visualize the overall complexity of the gene expression by visualizing the genes detected per UMI (novelty score)
merged_seurat_1@meta.data |>
    ggplot(aes(x = log10GenesPerUMI, color = samples, fill=samples)) +
    geom_density(alpha = 0.2) +
    theme_classic() +
    geom_vline(xintercept = 0.8)

# Visualize the distribution of mitochondrial gene expression detected per cell
merged_seurat_1@meta.data |>
    ggplot(aes(color = samples, x = mitoRatio, fill = samples)) + 
    geom_density(alpha = 0.2) + 
    scale_x_log10() + 
    theme_classic() +
    geom_vline(xintercept = 0.2)
```

```{r}
#| fig-width: 10
#| fig-height: 10
# Visualize the correlation between genes detected and number of UMIs and determine whether strong presence of cells with low numbers of genes/UMIs
merged_seurat_1@meta.data |> 
    ggplot(aes(x = nCount_RNA, y = nFeature_RNA, color = mitoRatio)) + 
    geom_point() + 
    scale_colour_gradient(low = "gray90", high = "black") +
    stat_smooth(method = lm) +
    scale_x_log10() + 
    scale_y_log10() + 
    theme_classic() +
    geom_vline(xintercept = 500) +
    geom_hline(yintercept = 250) +
    facet_wrap(~samples)
```

可以看到该数据集已经进行了质控，各项指标均在正常范围内，因此，我们可以跳过细胞/基因过滤，直接进入下面的环节。

### 归一化及消除非期望变异来源

::: callout-caution
由于这里`SCTransform`的数据量太大，在我的16GB MacBook Pro上超出了R内存分配上限，出现了“Error: vector memory exhausted (limit reached?)”报错。因此，这里在运行下面的脚本之前通过 @sec-Raising_memory_limit 的方法进行了处理。
:::

```{r}
#| cache-lazy: false
# SCTranform
merged_seurat_1 <- SCTransform(merged_seurat_1, verbose = FALSE); beep()
gc() # 释放未使用内存
merged_seurat_1

# Check which assays are stored in objects
merged_seurat_1@assays
# 查看目前默认的assay
DefaultAssay(merged_seurat_1)
# 查看默认assay的layers
Layers(merged_seurat_1)
```

#### 评估细胞周期的影响

```{r}
#| cache-lazy: false
#| fig-width: 10
# Load cell cycle markers
s.genes <- cc.genes$s.genes
g2m.genes <- cc.genes$g2m.genes

# Score cells for cell cycle
merged_seurat_1 <- CellCycleScoring(merged_seurat_1, 
                                    g2m.features = g2m.genes, 
                                    s.features = s.genes)

# 现在的meta.data中多出了细胞周期评分“S.Score”和“G2M.Score”，以及推断的细胞所处的周期“Phase”
head(merged_seurat_1@meta.data)
# 查看一下细胞周期的分布情况
table(merged_seurat_1$Phase)

# 执行PCA
merged_seurat_1 <- RunPCA(merged_seurat_1)

# Plot the PCA colored by cell cycle phase
p1 <- DimPlot(merged_seurat_1,
              reduction = "pca",
              group.by= "Phase")
p2 <- DimPlot(merged_seurat_1,
              reduction = "pca",
              group.by= "Phase",
              split.by = "Phase")
plot_grid(p1, p2, ncol = 2, labels = "AUTO")
```

可以看到细胞周期不是变异来源。

#### **评估线粒体基因的影响**

```{r}
#| cache-lazy: false
#| fig-width: 3
#| fig-height: 3
# Check quartile values
mito_sum <- summary(merged_seurat_1$mitoRatio)
mito_sum

# Turn mitoRatio into categorical factor vector based on quartile values
merged_seurat_1$mitoFr <- cut(merged_seurat_1$mitoRatio, 
                              breaks=c(-Inf, mito_sum[2], mito_sum[3], mito_sum[5], Inf),
                              labels=c("Low", "Medium", "Medium high", "High"))
plot(merged_seurat_1$mitoFr)
```

```{r}
#| cache-lazy: false
#| fig-width: 15
# Plot the PCA colored by cell cycle phase
p1 <- DimPlot(merged_seurat_1,
              reduction = "pca",
              group.by= "mitoFr")
p2 <- DimPlot(merged_seurat_1,
              reduction = "pca",
              group.by= "mitoFr",
              split.by = "mitoFr")
plot_grid(p1, p2, ncol = 2, labels = "AUTO")
```

可以看到线粒体基因比例不是变异来源。

由于细胞周期和线粒体基因比例都不是非期望变异来源，所以我们这里不需要再次运行SCTransform来回归这些变量。接下来，直接进入数据整合环节。

### 数据整合

#### **不进行整合时检验细胞分群情况**

```{r}
#| cache-lazy: false
#| fig-width: 15
#| fig-height: 15
# 查看降维信息
names(merged_seurat_1@reductions)

# Run UMAP
merged_seurat_1 <- RunUMAP(merged_seurat_1, dims = 1:40, reduction = "pca"); beep()

# Plot UMAP
p1 <- DimPlot(merged_seurat_1, group.by = "samples", label = T)
p2 <- DimPlot(merged_seurat_1, split.by = "samples")
plot_grid(p1, p2, ncol = 1, labels = "AUTO")

# 由于样本数较多，我们再按照样本类型“Normal” vs. “Cancer”画一下UMAP图
merged_seurat_1$groups <- ifelse(merged_seurat_1$samples == "N01", "Normal", "Cancer")
p1a <- DimPlot(merged_seurat_1, group.by = "groups")
p2a <- DimPlot(merged_seurat_1, split.by = "groups")
plot_grid(p1a, p2a, ncol = 1, labels = "AUTO")
```

#### 整合

这里我们用Harmony整合算法。

```{r}
#| cache-lazy: false
# 整合，比较耗时间，进度条会一直显示0%直至运算完成
seurat_integrated <- IntegrateLayers(object = merged_seurat_1,
                                     method = HarmonyIntegration,
                                     assay = "SCT", # Integrating SCTransformed data
                                     orig.reduction = "pca",
                                     verbose = FALSE); beep()


# 整合后合并RNA layer
seurat_integrated[["RNA"]] <- JoinLayers(seurat_integrated[["RNA"]])

# 查看整合后的降维信息
names(seurat_integrated@reductions)
```

#### **整合后检验细胞分群情况**

```{r}
#| cache-lazy: false
#| fig-width: 15
#| fig-height: 15
set.seed(123456)
# Run UMAP
seurat_integrated <- RunUMAP(seurat_integrated, 
                             dims = 1:40,
                             reduction = "harmony") # 更改降维来源为整合后的"harmony"

# Plot UMAP                             
p3 <- DimPlot(seurat_integrated, reduction = "umap", group.by = "samples")
p4 <- DimPlot(seurat_integrated, reduction = "umap", split.by = "samples")
plot_grid(p1, p2, p3, p4, ncol = 2, labels = c("Before Harmony", "", "After Harmony", ""))
```
